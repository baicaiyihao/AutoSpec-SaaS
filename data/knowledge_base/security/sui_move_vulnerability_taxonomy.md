# Sui Move Smart Contract Vulnerability Taxonomy

## Overview

This document provides a comprehensive taxonomy of security vulnerabilities in Sui Move smart contracts, covering:
- Vulnerability types and characteristics
- Exploitation methods and attack chains
- Detection patterns and recommended checks

**Total Patterns in Database:** 286 (as of 2025-12-31)

---

## 1. Arithmetic Vulnerabilities

### 1.1 Integer Overflow
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-OVERFLOW-001 | Multiplication Overflow | Critical | `*`, `amount *`, `shares *` |
| SUI-VULN-OVERFLOW-002 | Addition Overflow | High | `total_`, `growth_`, `+=` |

**Exploitation Pattern:**
```move
// VULNERABLE: u64 * u64 can overflow
let shares = amount * total_shares / total_supply;

// SAFE: Cast to u128 first
let shares = ((amount as u128) * (total_shares as u128) / (total_supply as u128)) as u64;
```

**Spec Check:**
```move
requires((amount as u128) * (total_shares as u128) <= MAX_U128);
ensures(result == (amount as u128) * (total_shares as u128) / (total_supply as u128));
```

### 1.2 Bit-Shift Overflow (CRITICAL - Move Language Quirk)
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-BITSHIFT-001 | Left-Shift Overflow | Critical | `<<`, `shl`, `checked_shl` |
| SUI-VULN-BITSHIFT-002 | Mask Calculation Error | Critical | `mask`, `0xffff`, `<< 192` |

**IMPORTANT:** Move's left-shift operator (`<<`) does **NOT** abort on overflow, unlike `+` and `*`.

**Cetus checked_shlw Vulnerability:**
```move
// VULNERABLE: Incorrect mask - too large by factor of 2^64-1
let mask = 0xffffffffffffffff << 192;
if (n > mask) { abort }  // Most values > 2^192 pass through!

// FIXED: Correct mask
let mask = 1 << 192;
if (n >= mask) { abort }
```

**Detection Pattern:**
- Search for `<< 64`, `<< 128`, `<< 192` operations
- Verify all "checked" shift functions actually work
- Test with boundary values near 2^192

### 1.3 Type Truncation
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-TRUNCATE-001 | u256 to u64 Downcast | Critical | `as u64`, `as u128`, `truncate` |

**Exploitation Pattern:**
```move
// VULNERABLE: u128 * u128 = u256, but cast to u64 loses high bits
let result = (a as u256) * (b as u256);
return (result as u64);  // High 192 bits lost!

// SAFE: Bounds check before downcast
assert!(result <= MAX_U64);
return (result as u64);
```

### 1.4 Precision Loss
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-PRECISION-001 | Division Rounding | High | `/`, `shares`, `precision` |

**First Depositor Attack Chain:**
1. Attacker deposits 1 wei, receives 1 share
2. Attacker donates large amount directly to vault
3. Victim deposits, receives 0 shares due to rounding
4. Attacker withdraws all assets

---

## 2. Access Control Vulnerabilities

### 2.1 Missing Capability Checks
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-ACCESS-001 | Missing AdminCap | Critical | `withdraw`, `set_`, `admin` |
| SUI-VULN-ACCESS-002 | Sender Validation Bypass | High | `tx_context::sender` |

**Vulnerable Pattern:**
```move
// VULNERABLE: No capability check
public fun withdraw_all(vault: &mut Vault) { ... }

// SAFE: Requires AdminCap
public fun withdraw_all(vault: &mut Vault, _admin: &AdminCap) { ... }
```

---

## 3. Resource/Object Vulnerabilities

### 3.1 Resource Management
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-RESOURCE-001 | Resource Leak | Critical | `Coin<`, `return`, `abort` |
| SUI-VULN-RESOURCE-002 | Double Spend | Critical | `object::id`, `shared_object` |

**Resource Leak Pattern:**
```move
// VULNERABLE: coin leaked on early return
public fun process(coin: Coin<SUI>) {
    if (condition) { return } // coin leaked!
    transfer::public_transfer(coin, recipient);
}

// SAFE: Handle all paths
public fun process(coin: Coin<SUI>) {
    if (condition) {
        transfer::public_transfer(coin, sender);
        return
    }
    transfer::public_transfer(coin, recipient);
}
```

---

## 4. DeFi-Specific Vulnerabilities

### 4.1 Flash Loan Attacks
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-FLASHLOAN-001 | Price Manipulation | Critical | `flash_loan`, `oracle`, `price` |
| SUI-VULN-FLASHLOAN-002 | Fee Bypass | High | `repay`, `flash`, `fee` |

**Flash Loan Attack Chain:**
1. Flash borrow large amount
2. Manipulate on-chain price oracle
3. Exploit protocol using manipulated price
4. Reverse manipulation
5. Repay flash loan with profit

### 4.2 CLMM Vulnerabilities (Cetus-style)
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-CLMM-001 | Tick Manipulation | Critical | `tick`, `liquidity`, `cross` |
| SUI-VULN-CLMM-002 | Position Confusion | High | `Position<`, `Pool<`, `pool_id` |

**Cetus $260M Hack Pattern:**
- Arithmetic overflow in liquidity calculation
- Manipulated tick account to receive more liquidity credit
- Used spoof tokens with no economic value

### 4.3 Slippage Attacks
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-SLIPPAGE-001 | Missing Protection | High | `swap`, `min_amount_out` |

**Sandwich Attack Chain:**
1. Attacker front-runs victim's swap
2. Victim's swap executes at worse price
3. Attacker back-runs to capture profit

---

## 5. Oracle Vulnerabilities

| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-ORACLE-001 | Stale Price Data | High | `oracle`, `timestamp`, `last_update` |

**Spec Check:**
```move
requires(clock::timestamp_ms(clock) - oracle.last_update < MAX_STALENESS);
requires(abs(price - twap_price) < MAX_DEVIATION);
```

---

## 6. Upgrade/Version Vulnerabilities

| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-UPGRADE-001 | Version Mismatch | Medium | `checked_package_version` |
| SUI-VULN-INIT-001 | Unprotected Init | Critical | `init`, `one_time_witness` |

---

## 7. Sui-Specific Vulnerabilities

### 7.1 Object Model Issues
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-OBJECT-001 | Excessive Struct Abilities | High | `has copy, drop, store, key` |
| SUI-VULN-OBJECT-002 | Improper Capability Sharing | High | `share_object`, `AdminCap` |
| SUI-VULN-OBJECT-003 | Multi-Object Validation | Medium | `pool_id`, `position.pool_id` |
| SUI-VULN-OBJECT-004 | Unfrozen Metadata | Medium | `CoinMetadata`, `freeze` |

**Ability Assignment Best Practices:**
```move
// Events: copy + drop only
struct MyEvent has copy, drop { ... }

// Hot Potato Receipt: NO abilities (enforces return)
struct FlashLoanReceipt { amount: u64 }

// Capabilities: key + store (NO drop - prevent destruction)
struct AdminCap has key, store { id: UID }
```

**Capability Sharing Vulnerability:**
```move
// VULNERABLE: Anyone can access shared capability
transfer::share_object(admin_cap);

// SAFE: Only owner can use transferred capability
transfer::public_transfer(admin_cap, admin_address);
```

### 7.2 Generic Type Issues
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-GENERIC-001 | Type Confusion | Critical | `<T>`, `type_name`, `generic` |
| SUI-VULN-GENERIC-002 | Unvalidated Token Type | Critical | `Coin<T>`, `Pool<A, B>` |

**Token Substitution Attack (Cetus Hack):**
```move
// VULNERABLE: Accepts any token type without validation
public fun add_liquidity<T>(pool: &mut Pool<T>, coin: Coin<T>) { ... }

// SAFE: Validate token against whitelist or oracle
public fun add_liquidity<T>(pool: &mut Pool<T>, coin: Coin<T>) {
    assert!(is_valid_token_type<T>(), E_INVALID_TOKEN);
    assert!(has_liquidity<T>(), E_NO_LIQUIDITY);  // Reject worthless tokens
    ...
}
```

---

## 8. Ability System Vulnerabilities

### 8.1 Hot Potato Security
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-ABILITY-001 | Drop on Hot Potato | Critical | `has drop`, `Receipt`, `FlashLoan` |
| SUI-VULN-ABILITY-002 | Missing Phantom Type | High | `phantom`, `PaymentReceipt<T>` |
| SUI-VULN-ABILITY-003 | Copy+Drop Combination | Critical | `has copy, drop`, asset structs |

**Critical Rule:** Hot potatoes for enforcement (flash loan receipts) must have **ZERO** abilities.

```move
// VULNERABLE: drop allows bypass
struct FlashLoanReceipt has drop { amount: u64 }

// SAFE: No abilities enforces consumption
struct FlashLoanReceipt { amount: u64 }
```

**Testing Pattern:**
```move
#[test]
#[expected_failure]  // Must fail if secure
public fun test_cannot_drop_receipt() {
    let receipt = create_flash_loan_receipt();
    // If this compiles without consuming receipt, security is broken
}
```

### 8.2 Asset Ability Rules
| Asset Type | Allowed Abilities | Forbidden |
|------------|-------------------|-----------|
| Tokens/Coins | `key`, `store` | `copy`, `drop` |
| Events | `copy`, `drop` | `key`, `store` |
| Hot Potato/Receipt | **none** | all |
| Capabilities | `key`, `store` | `drop` |

---

## 9. Detection Methods

### 9.1 Static Analysis Patterns

| ID | Target | Method |
|----|--------|--------|
| SUI-DETECT-001 | Arithmetic | Scan for `*` with u64, check for u128 cast |
| SUI-DETECT-002 | Access Control | Match `public fun` + sensitive ops without Cap |
| SUI-DETECT-003 | Resource Leak | Track resource creation/consumption paths |
| SUI-DETECT-004 | Slippage | Check swap functions for min_amount_out |

### 9.2 Formal Verification Checks

```move
// Overflow check
requires((a as u128) * (b as u128) <= MAX_U64);

// Access control check
requires(object::owner(obj) == tx_context::sender(ctx));

// Resource safety
ensures(all Coin/Balance transferred or destroyed on all paths);

// Slippage protection
ensures(actual_output >= min_amount_out);
```

---

## 9. Audit Report Sources

### Cetus Protocol (CLMM)
- **MoveBit Audit**: 18 findings (1 Critical, 2 Major, 3 Medium, 12 Minor)
- **OtterSec Audit**: 9 findings (1 High, 1 Medium, 7 Informational)
- **Zellic Audit**: 3 findings (all Informational)

### Key Vulnerabilities from Audits

| ID | Source | Title | Severity |
|----|--------|-------|----------|
| CETUS-MB-001 | MoveBit | Function Parameter Order Error | Critical |
| CETUS-MB-002 | MoveBit | Recursive Function Causing Infinite Loop | Major |
| CETUS-OS-001 | OtterSec | Position Confusion in Add Liquidity | High |
| CETUS-OS-002 | OtterSec | Balance Validation Bypass | Medium |

---

## 10. Move VM / Infrastructure Vulnerabilities

### 10.1 Bytecode Verifier Bugs
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| MOVE-VM-001 | CFG Construction Bug | Critical | `get_successors`, 65534 instructions |
| MOVE-VM-002 | Stack Verifier Overflow | Critical | `stack_usage_verifier` |

**Billion Dollar Bug (Zellic Discovery):**
- Bug in `Bytecode::get_successors` caused incorrect CFG for functions with 65,534 instructions
- Final instruction jumps had no successors identified
- Bypassed: Locals Safety, Reference Safety, Paranoid Type Checks
- **Impact:** Could drop objects without `drop`, get multiple mutable references
- **Affected:** All Move chains (Sui, Aptos, Starcoin)

### 10.2 Validator/Network Vulnerabilities
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-VALIDATOR-001 | Narwhal OOM DoS | High | `GetCertificates`, digest query |

**Sui Network Shutdown Bug (Immunefi):**
- Unbounded `GetCertificates` handler in Narwhal mempool
- 37MB payload with 1.2M digests could crash 64GB validators
- **Fix:** Removed vulnerable handlers entirely
- **Bounty:** $50,000 SUI

### 10.3 HamsterWheel Attack (CertiK Discovery)
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-HAMSTERWHEEL-001 | Verification Deadloop | Critical | `AbstractState::join`, state merge |

**Attack Mechanism:**
- Novel attack: ~100 byte payload triggers infinite loop in validator verification
- Unlike crashes, nodes trapped in ceaseless operation without processing transactions
- **Persists after reboot** - conventional mitigations insufficient
- Root cause: State merge logic determined result before executing `AbstractValue::join`

**Fix:** Execute `AbstractValue::join` first, then set change flag based on comparing final result with original value.

**Bounty:** $500,000 (before mainnet launch)

---

## 11. Real-World Incidents

### Cetus Protocol Hack (May 22, 2025) - $223M
- **Type:** CLMM Math Library Overflow
- **Root Cause:** Flawed `checked_shlw` function with incorrect mask calculation
- **Technical Details:**
  - Mask was `0xffffffffffffffff << 192` instead of `1 << 192` (too large by 2^64-1)
  - Comparison used `>` instead of `>=`
  - Left-shift by 64 bits caused silent overflow (Move doesn't abort on shift overflow)
  - Result: Token requirement calculated as 1 instead of billions
- **Attack Steps:**
  1. Flash loan initialization
  2. Open position with narrow tick range [300000, 300200]
  3. Select liquidity value (~2^113) that passes flawed check but overflows
  4. Deposit 1 token, receive billions in liquidity credit
  5. Extract funds across multiple transactions
- **Aftermath:** $162M frozen on Sui, $60M bridged to Ethereum, protocol restarted after 17 days
- **Lessons:**
  - Move's `<<` does NOT abort on overflow like `+` and `*`
  - "Checked" operations must be verified to actually check
  - Multiple audits missed this (library code may have been out of scope)
  - Validate tokens for real economic value, not just type correctness

**Sources:**
- [Halborn Analysis](https://www.halborn.com/blog/post/explained-the-cetus-hack-may-2025)
- [Dedaub Analysis](https://dedaub.com/blog/the-cetus-amm-200m-hack-how-a-flawed-overflow-check-led-to-catastrophic-loss/)
- [SlowMist Analysis](https://slowmist.medium.com/slowmist-analysis-of-the-230-million-cetus-hack-ee569af040f2)

### Nemo Protocol Exploit (September 2025) - $2.4M
- **Type:** Oracle Price Manipulation
- **Root Cause:** Manipulable price oracle in lending/yield protocol
- **Attack Steps:**
  1. Manipulate price oracle to inflate collateral value
  2. Borrow/withdraw based on inflated prices
  3. Bridge stolen USDC: Sui → Arbitrum → Ethereum (avoid freeze)
- **Impact:** TVL dropped from $6M to $1.53M
- **Lessons:**
  - Use TWAP (Time-Weighted Average Price) for oracle prices
  - Implement price deviation checks against multiple sources
  - Add circuit breakers for abnormal price movements

**Source:** [CoinDesk](https://www.coindesk.com/markets/2025/09/08/sui-based-yield-protocol-nemo-exploited-for-usd2-4m-in-usdc/)

### Typus Finance Oracle Exploit (October 2025) - $3.44M
- **Type:** Custom Oracle Authorization Bypass
- **Root Cause:** Missing assert check in `update_v2` function of oracle module
- **Technical Details:**
  - Vulnerable oracle module deployed Nov 2024, NOT included in May 2025 MoveBit audit scope
  - Any address could update oracle prices (no authorization check)
  - Attacker manipulated prices, performed swaps at incorrect values
- **Attack Steps:**
  1. Call unprotected `update_v2` to set manipulated prices
  2. Execute swaps at favorable (incorrect) prices
  3. Bridge stolen funds: Sui → CCTP → Ethereum (swap to DAI)
- **Impact:** $3.44M drained (588K SUI, 1.6M USDC, 0.6 xBTC, 32 suiETH)
- **Lessons:**
  - **ALL** modules must be in audit scope
  - Use proven oracles (Chainlink) over custom implementations
  - Add authorization asserts to ALL update functions

**Source:** [Halborn Analysis](https://www.halborn.com/blog/post/explained-the-typus-finance-hack-october-2025)

### 2025 Sui DeFi Exploits Summary
| Date | Protocol | Amount | Vulnerability Type |
|------|----------|--------|-------------------|
| May 2025 | Cetus | $223M | Math library overflow |
| Sep 2025 | Nemo | $2.4M | Oracle manipulation |
| Oct 2025 | Typus | $3.44M | Missing authorization |
| **Total** | | **$228.84M** | |

---

## 12. CTF Security Challenges

### MoveCTF (by MoveBit)
Annual Move security competition. Key challenge types:

| Challenge | Vulnerability | Technique |
|-----------|--------------|-----------|
| Simple Game | Predictable PRNG | TxContext seed prediction |
| Flash Loan | Temporary balance | Borrow-call-repay in single tx |
| Move Lock | Weak crypto | Algebraic analysis / Z3 solver |
| ZK Proofs | Version mismatch | Library format incompatibility |

### Let's Move CTF (HOH Bootcamp)
Security training covering:
- Generics vulnerabilities (`<phantom T>`)
- Resource management & ownership
- Access control (TxContext validation)
- Logic bugs in state management
- PTB (Programmable Transaction Block) chaining

**Resources:**
- [MoveCTF 2024](https://movectf2024.movebit.xyz/)
- [Let's Move CTF](https://lets-ctf.vercel.app/)
- [GitHub: movectf](https://github.com/movectf)

---

## 13. One-Time Witness (OTW) Vulnerabilities

### 13.1 OTW Pattern Issues
| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-OTW-001 | Additional Cap Creation | High | `init`, `create_cap`, `AdminCap` |
| SUI-VULN-OTW-002 | Wrong Type Definition | Medium | `has drop`, `MODULE_NAME` |

**OTW Requirements:**
- Only `drop` ability, no other abilities
- No fields (or single bool field)
- Name matches module name in UPPERCASE

```move
// CORRECT OTW Definition
module example::my_token {
    struct MY_TOKEN has drop {}

    fun init(witness: MY_TOKEN, ctx: &mut TxContext) {
        // witness consumed here
    }
}
```

**Security Risk:** init doesn't prevent adding new functions that create additional capabilities later!

---

## 14. Package Upgrade Vulnerabilities

| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-UPGRADE-003 | Old Version Callable | Medium | `upgrade`, `version`, immutable |
| SUI-VULN-UPGRADE-004 | Single-Key UpgradeCap | Medium | `UpgradeCap`, governance |

**Key Risks:**
- Old package versions remain callable after upgrade (packages are immutable)
- Single private key controlling UpgradeCap creates centralization risk
- Data migration during upgrades may miss critical updates

**Mitigation:**
```move
// Option 1: Make package immutable
sui::package::make_immutable(upgrade_cap);

// Option 2: Use multi-sig governance for UpgradeCap
```

---

## 15. Cross-Chain Bridge Vulnerabilities

| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-BRIDGE-001 | Non-Standard ERC20 | Critical | `transfer`, `USDT`, `boolean` |

**MoveBit Discovery:** Cross-chain bridge incompatible with USDT (no boolean return).

```solidity
// VULNERABLE: USDT doesn't return boolean
bool success = token.transfer(to, amount);
require(success);  // USDT always fails here!

// SAFE: Use safeTransfer
IERC20(token).safeTransfer(to, amount);
```

---

## 16. Liquid Staking Vulnerabilities

| ID | Type | Severity | Detection Cues |
|----|------|----------|----------------|
| SUI-VULN-LSD-001 | Exchange Rate Manipulation | High | `exchange_rate`, `LST` |
| SUI-VULN-LSD-002 | Token Issuance Desync | High | `mint`, `burn`, `stake` |

**Key Audit Points (MoveBit):**
1. Validator selection reliability
2. Exchange rate update frequency
3. LST issuance/burning synchronization
4. Reward distribution fairness
5. Fund recovery on validator issues

---

## 17. Vulnerability Hunting Methodology

This section provides attack vector patterns mapped from other blockchain ecosystems (primarily Solidity/EVM) to Sui Move. While Move's type system prevents certain vulnerabilities (e.g., classic reentrancy), many DeFi logic vulnerabilities remain applicable.

### 17.1 What Doesn't Apply to Move

| EVM Vulnerability | Why Not Applicable in Move |
|-------------------|----------------------------|
| Classic Reentrancy | No external calls during execution; resource linearity |
| Integer Overflow (basic) | Move VM aborts on `+`, `-`, `*` overflow |
| Uninitialized Storage | All variables must be initialized |
| Delegatecall Exploits | No equivalent mechanism in Move |
| tx.origin Authentication | No equivalent; use Capabilities instead |

### 17.2 What DOES Apply to Move

| Attack Vector | Sui Move Applicability | Detection |
|--------------|------------------------|-----------|
| First Depositor Attack | ✅ Vault/pool share calculation | `shares = 0`, empty pool checks |
| Donation Attack | ✅ Direct balance manipulation | `balance::join`, `transfer_to_object` |
| Oracle Manipulation | ✅ Any oracle-dependent protocol | `price`, `oracle`, flash loan usage |
| Governance Attacks | ✅ Voting with borrowed tokens | `vote`, `governance`, token locking |
| Precision Loss | ✅ Integer division rounding | `/`, `shares`, accumulated errors |
| Sandwich/MEV | ✅ Transaction ordering games | `swap`, `min_amount_out` missing |
| Flash Loan Amplification | ✅ Same-tx borrow-exploit-repay | Hot Potato pattern usage |

### 17.3 Vulnerability Hunting Checklist

#### Vault/Pool Contracts
```
□ First depositor attack: Can attacker manipulate share price with dust deposit + donation?
□ Donation attack: Can direct token transfer manipulate exchange rates?
□ Empty pool edge case: What happens when total_supply = 0?
□ Share calculation overflow: Is (amount * total_shares) cast to u128?
□ Withdrawal slippage: Is min_amount_out enforced?
```

#### Oracle-Dependent Contracts
```
□ Single oracle dependency: Is there a backup price source?
□ Stale price: Is there a freshness check (timestamp)?
□ Flash loan manipulation: Can price be moved in same transaction?
□ Price deviation: Are large price swings validated?
□ Authorization: Who can update oracle prices?
```

#### DeFi Protocol Contracts
```
□ Flash loan integration: Can borrowed funds amplify attacks?
□ Liquidation logic: Can users self-liquidate profitably?
□ Reward manipulation: Can stake/unstake timing game rewards?
□ Fee bypass: Can operations avoid intended fees?
□ Admin functions: Are all sensitive functions capability-gated?
```

#### Cross-Contract Interactions
```
□ Read-only reentrancy: Can view functions return stale state during tx?
□ Callback validation: Are callback parameters validated?
□ Module trust: Are called modules from trusted packages?
□ Return value handling: Are all return values checked?
```

### 17.4 Attack Pattern Templates

#### HUNT-VAULT-001: First Depositor Attack
```move
// VULNERABLE: First depositor can manipulate share price
public fun deposit(vault: &mut Vault, coin: Coin<SUI>): u64 {
    let amount = coin::value(&coin);
    let shares = if (vault.total_shares == 0) {
        amount  // First deposit: 1:1 ratio
    } else {
        amount * vault.total_shares / vault.total_balance  // Can be manipulated!
    };
    // ...
}

// ATTACK SEQUENCE:
// 1. Deposit 1 wei → get 1 share
// 2. Donate 1000 SUI directly to vault
// 3. Victim deposits 500 SUI → gets 0 shares (500 * 1 / 1001 = 0)
// 4. Withdraw all assets

// MITIGATION: Minimum initial deposit + virtual shares
let shares = if (vault.total_shares == 0) {
    assert!(amount >= MIN_INITIAL_DEPOSIT, E_DUST_DEPOSIT);
    amount + VIRTUAL_SHARES
};
```

#### HUNT-ORACLE-001: Flash Loan Price Manipulation
```move
// VULNERABLE: Spot price from single DEX
public fun get_price(pool: &Pool): u64 {
    balance::value(&pool.reserve_a) / balance::value(&pool.reserve_b)
}

// ATTACK: Flash loan → swap → manipulate price → exploit → swap back → repay

// MITIGATION: TWAP + deviation check
public fun get_safe_price(oracle: &Oracle, pool: &Pool): u64 {
    let spot = get_spot_price(pool);
    let twap = oracle.twap_price;
    assert!(abs_diff(spot, twap) < MAX_DEVIATION, E_PRICE_DEVIATION);
    twap
}
```

#### HUNT-SLIPPAGE-001: Sandwich Attack
```move
// VULNERABLE: No slippage protection
public fun swap(pool: &mut Pool, coin_in: Coin<SUI>): Coin<USDC> {
    let amount_out = calculate_output(pool, coin::value(&coin_in));
    // User has no control over minimum received
}

// ATTACK: Front-run → User tx → Back-run (sandwich)

// MITIGATION: Require min_amount_out
public fun swap(
    pool: &mut Pool,
    coin_in: Coin<SUI>,
    min_amount_out: u64  // User-specified minimum
): Coin<USDC> {
    let amount_out = calculate_output(pool, coin::value(&coin_in));
    assert!(amount_out >= min_amount_out, E_SLIPPAGE);
    // ...
}
```

### 17.5 Sui-Specific Attack Vectors

| Vector | Description | Detection |
|--------|-------------|-----------|
| Shared Object Contention | Exploit consensus delays for profit | High-frequency shared object access |
| Object ID Prediction | Guess future object IDs for targeted attacks | Sequential ID patterns |
| PTB Chaining | Complex attack in single Programmable Transaction Block | Multiple operations in one tx |
| Capability Leakage | AdminCap transferred or wrapped incorrectly | `transfer::public_transfer(cap, ...)` |
| Type Confusion | Generic `<T>` without proper constraints | `public fun<T>` without ability bounds |

---

## 18. Academic Research Findings

### 18.1 MoveScanner Vulnerability Distribution (Aptos Mainnet)

Analysis of 37,302 deployed contracts revealed:

| Vulnerability Type | Percentage | Description |
|-------------------|------------|-------------|
| Arithmetic Overflow | 61.3% | Unchecked math operations |
| Cross-Module State Pollution | 18.5% | Public functions modifying external state |
| Privilege Leakage | 10.0% | Capability exposure in public functions |
| Unchecked Return Values | 9.8% | Ignored function results |
| Resource Leakage | 0.4% | Unconsumed resources on execution paths |

**Source:** [MoveScanner arXiv:2508.17964](https://arxiv.org/abs/2508.17964)

### 18.2 MoveScan Defect Categories (ISSTA 2024)

Eight types of defects identified through manual audit of 652 contracts:
- Resource leaks and improper consumption
- Unchecked return values
- Arithmetic overflow/underflow
- Cross-module security issues
- Capability/privilege leakage
- Type safety violations
- Access control misconfigurations
- Business logic flaws

**Detection Results:** 97,028 defects across all Aptos and Sui mainnet contracts.

**Source:** [MoveScan ISSTA 2024](https://dl.acm.org/doi/10.1145/3650212.3680391)

### 18.3 Move Prover Limitations

| Limitation | Impact | Mitigation |
|------------|--------|------------|
| Specification inconsistency | False positives (buggy code passes) | Enable `--check-inconsistency` flag |
| Vacuous truth from abort | Any postcondition satisfied | Enable `--unconditional-abort-as-inconsistency` |
| Missing temporal properties | Can't verify liveness, liquidity | Supplement with runtime monitoring |
| Scalability on complex contracts | Timeout or memory exhaustion | Break into smaller verification units |

**Source:** [CertiK Move Prover Analysis](https://www.certik.com/resources/blog/the-move-prover-quality-assurance-of-formal-verification)

### 18.4 PTB (Programmable Transaction Block) Security

| Risk | Description | Mitigation |
|------|-------------|------------|
| Gas exhaustion attack | Attacker controls gas to selectively revert | Consistent gas costs across paths |
| Randomness composition bypass | Split random logic across transactions | Store random in unreadable objects |
| Complex attack chaining | Multiple operations in single atomic tx | Entry function restrictions |

---

## 19. Tool & Automation Support

### 19.1 Static Analysis Tools

| Tool | Type | Capabilities |
|------|------|-------------|
| MoveScanner | Static analysis | 5 vulnerability types, bytecode analysis |
| MoveScan | Framework | 8 defect types, 98.85% precision |
| Move Prover | Formal verification | Mathematical proofs of specifications |
| sui-prover | Sui-specific | Specification verification |

### 19.2 Security Scanners

| Scanner | Focus | Notable |
|---------|-------|---------|
| MoveBit Scanner | Audit automation | First Move formal verification integration |
| BitsLabAI Scanner | AI-powered | Second place in SuiDex audit competition |
| Armur.ai | Vulnerability scanner | Move-specific patterns |

---

## 20. Move 2024 Edition Security Considerations

Move 2024 introduces significant language changes. Security implications:

### 20.1 Enum and Pattern Matching

| Risk | Description | Mitigation |
|------|-------------|------------|
| Guard expression default | Using `if` guards requires wildcard case | Avoid guards; explicitly match variants |
| Wildcard masking | `_` hides new enum variants | Explicitly list known variants first |
| Non-exhaustive patterns | Adding variants won't trigger errors | Review matches when extending enums |

```move
// RISKY: Wildcard may hide new variants
match status {
    Status::Active => handle_active(),
    Status::Paused => handle_paused(),
    _ => handle_unknown(), // New Status::Deprecated falls here silently
}

// SAFER: Explicit handling
match status {
    Status::Active => handle_active(),
    Status::Paused => handle_paused(),
    Status::Deprecated => handle_deprecated(),
}
```

### 20.2 Macro Functions

| Feature | Security Note |
|---------|---------------|
| Hygiene | Variables in macro body and lambda are distinct (safe) |
| Substitution | Arguments not evaluated if branch not taken |
| Control flow | `break`/`continue`/`return` scoped to definition site |

### 20.3 New Syntax Features

| Feature | Security Consideration |
|---------|----------------------|
| `let mut` | Explicit mutability improves code clarity |
| `public(package)` | Broader scope than `public(friend)` - audit access |
| Method syntax | Auto-borrowing may hide mutation |
| Index syntax `v[i]` | Bounds checking not visible in syntax |
| Positional fields | Refactoring field order silently breaks access |
| Loop labels | Type consistency across break points |

---

## 21. zkLogin and Authentication Security

### 21.1 zkLogin Attack Surface

| Component | Risk | Impact |
|-----------|------|--------|
| Ephemeral key | Exposure enables signing | Critical |
| ZK proof | Combined with key enables impersonation | Critical |
| JWT token | Leakage reveals identity | High |
| User salt | Combined with OAuth compromise enables takeover | Critical |

### 21.2 Security Model

```
┌──────────────────────────────────────────────────────┐
│                   zkLogin Security                    │
├──────────────────────────────────────────────────────┤
│  OAuth Account ──┬── Salt ──┬── Ephemeral Key        │
│                  │          │                        │
│  Compromise 1    │ + Salt   │ + ZK Proof             │
│  alone = SAFE    │ = RISK   │ = FULL COMPROMISE      │
└──────────────────────────────────────────────────────┘
```

### 21.3 Multisig Considerations

| Configuration | Risk Level | Notes |
|--------------|------------|-------|
| 1-of-N | High | Single point of failure |
| N-of-N | Medium | Requires all signers; key loss = lockout |
| K-of-N (K<N) | Low | Balanced security/availability |

---

## 22. Zero-Knowledge Proof Security

### 22.1 Groth16 on Sui

| Requirement | Security Impact |
|-------------|-----------------|
| Trusted setup ceremony | Random keys = proof forgery possible |
| Prepared verification key | Must prepare once, reuse |
| 8 public inputs max | Circuit design constraint |

### 22.2 zkLogin Cryptographic Risks

| Component | Quantum Vulnerable | Timeline |
|-----------|-------------------|----------|
| Groth16 proofs | Yes | Long-term risk |
| RSA signatures (JWT) | Yes | Long-term risk |
| Current security | Safe | Near-term |

---

## 23. AI-Generated Code Security

### 23.1 LLM Audit Tool Limitations

| Limitation | Impact | Mitigation |
|------------|--------|------------|
| ~10% hallucination rate | False positives | Manual verification |
| Context-dependent bugs | Missed vulnerabilities | Multiple audit methods |
| Business logic gaps | Incomplete coverage | Human expert review |

### 23.2 AI-Generated Contract Risks

| Risk | Description |
|------|-------------|
| Hidden vulnerabilities | AI code may pass human audits but contain exploitable flaws |
| Autonomous exploitation | AI agents can find and exploit AI-generated vulnerabilities |
| Over-reliance | Sole dependence on AI audits misses edge cases |

### 23.3 Best Practices

```
AI Audit Workflow:
1. AI initial scan → Triage findings
2. Human verification → Confirm real issues
3. Manual deep review → Business logic, edge cases
4. Combined report → Prioritized action items
```

---

## 24. 2025 Security Incident Summary

| Date | Protocol | Amount | Root Cause | Lessons |
|------|----------|--------|------------|---------|
| May 2025 | Cetus | $223M | Math library overflow (checked_shlw) | Audit dependencies; test edge cases |
| Sep 2025 | Nemo | $2.4M | Oracle manipulation | Use TWAP; multi-source oracles |
| Oct 2025 | Typus | $3.44M | Missing authorization in oracle update | ALL modules in audit scope |
| **Total** | | **$228.84M** | | |

### Key 2025 Takeaways

1. **Math library audits are critical** - Cetus had 3 professional audits but missed overflow
2. **All modules must be in scope** - Typus vulnerable module was excluded from audit
3. **Oracle security remains paramount** - 2 of 3 major exploits involved oracle manipulation
4. **Validator intervention is possible** - Sui froze $162M, raising decentralization questions

---

## 25. 2025 Sui Stack Security

The Sui Stack matured significantly in 2025 with new infrastructure components:

### 25.1 Walrus Decentralized Storage

| Component | Security Consideration |
|-----------|----------------------|
| Blob storage | Data replicated across nodes; no inherent encryption |
| RedStuff encoding | 2D erasure coding; survives 2/3 node failure |
| Quilt bundling | Up to 660 small files per blob; all-or-nothing retrieval |
| Access control | Requires Seal integration for encryption |

**Key Risks:**
- Storing unencrypted sensitive data
- Assuming 100% availability
- Bundle retrieval failures affecting multiple files

### 25.2 Seal Key Management

| Feature | Security Note |
|---------|---------------|
| On-chain policies | Access conditions enforced by blockchain |
| Encryption | Data encrypted before storage |
| Decryption triggers | Specific conditions unlock data |

**Key Risks:**
- Policy misconfiguration permanently locks data
- Overly permissive policies expose data
- Key rotation challenges

### 25.3 Nautilus TEE Computing

| Component | Risk | Mitigation |
|-----------|------|------------|
| Off-chain execution | Trust boundary | Verify attestations on-chain |
| TEE attestation | Forgery potential | Validate attestation format/signature |
| Result verification | Data integrity | Check results match expected schema |

### 25.4 DeepBook V3 CLOB

| Feature | Security Risk |
|---------|---------------|
| Flash loans | Price manipulation within single tx |
| Permissionless pools | Fake token listings |
| YLDS auto-conversion | Unexpected token type changes |
| Shared liquidity | Cross-pool attack surface |

### 25.5 Mysticeti V2 Consensus

- Latency reduced to <1 second
- Combined validation/consensus
- 35% latency improvement in Asia
- **Security Note:** Code assuming longer confirmation times may break

### 25.6 Move Registry (MVR)

| Risk | Mitigation |
|------|------------|
| Unverified packages | Check audit status |
| Malicious dependencies | Review source code |
| Version conflicts | Pin dependency versions |

### 25.7 AI Coding Assistant

| Risk | Impact | Mitigation |
|------|--------|------------|
| Vulnerable templates | Security gaps | Manual review |
| Autocomplete errors | Logic bugs | Test thoroughly |
| Overconfidence | Missed edge cases | Expert verification |

---

## References

### Security Research
- [SlowMist Sui Move Audit Primer](https://github.com/slowmist/Sui-MOVE-Smart-Contract-Auditing-Primer)
- [MoveBit Sui Objects Security Guide](https://www.movebit.xyz/blog/post/Sui-Objects-Security-Principles-and-Best-Practices.html)
- [MoveBit 2024 Security Review](https://www.movebit.xyz/blog/post/A-Deep-Dive-Analysis-A-2024-Comprehensive-Review-of-Technological-Innovations-and-Security-Events-in-the-Move-Ecosystem-20241204.html)
- [Zellic: Move Security Part 1 (Aptos)](https://www.zellic.io/blog/move-fast-and-break-things-pt-1/)
- [Zellic: Move Security Part 2 (Sui)](https://www.zellic.io/blog/move-fast-break-things-move-security-part-2/)
- [Zellic: Top 10 Aptos Move Bugs](https://www.zellic.io/blog/top-10-aptos-move-bugs/)
- [Trail of Bits: Sui Move Flash Loan Security](https://blog.trailofbits.com/2025/09/10/how-sui-move-rethinks-flash-loan-security/)
- [Mirage Audits: Sui Move Ability Mistakes](https://www.mirageaudits.com/blog/sui-move-ability-security-mistakes)

### Audit Reports
- [MoveBit Sampled Reports (28 Sui reports)](https://github.com/movebit/Sampled-Audit-Reports/tree/main/reports)
- [Cetus Protocol Audits](https://github.com/CetusProtocol/Audit)
- [Scallop Protocol Audits](https://docs.scallop.io/protocol/auditing)
- [Bucket Protocol Audits](https://medium.com/@bucketprotocol/bucket-protocol-sui-has-passed-the-audit-by-ottersec-one-of-the-leading-audit-firms-in-web3-4ef951581bb6)

### Incident Analysis
- [Halborn: Cetus Hack Explained](https://www.halborn.com/blog/post/explained-the-cetus-hack-may-2025)
- [Halborn: Typus Finance Hack](https://www.halborn.com/blog/post/explained-the-typus-finance-hack-october-2025)
- [Dedaub: Cetus Overflow Analysis](https://dedaub.com/blog/the-cetus-amm-200m-hack-how-a-flawed-overflow-check-led-to-catastrophic-loss/)
- [Cyfrin: Cetus Exploit Root Cause](https://www.cyfrin.io/blog/inside-the-223m-cetus-exploit-root-cause-and-impact-analysis)
- [Zellic: Billion Dollar Move Bug](https://www.zellic.io/blog/the-billion-dollar-move-bug/)
- [CertiK: HamsterWheel Vulnerability](https://www.certik.com/resources/blog/the-hamsterwheel-an-in-depth-exploration-of-a-novel-attack-vector-on-the-sui)
- [Immunefi: Sui Network Shutdown Bug](https://immunefi.com/blog/bug-fix-reviews/sui-network-shutdown/)
- [CoinDesk: Nemo Protocol Exploit](https://www.coindesk.com/markets/2025/09/08/sui-based-yield-protocol-nemo-exploited-for-usd2-4m-in-usdc/)

### Bug Bounty Programs
- [Sui Bug Bounty (HackenProof)](https://hackenproof.com/programs/sui-protocol)
- [Sui Security Page](https://www.sui.io/security)
- [Bucket Protocol Bug Bounty](https://hackenproof.com/programs/bucket-protocol-smart-contracts)

### Research Papers
- [MoveScanner: Security Risks Analysis (arXiv)](https://arxiv.org/html/2508.17964)
- [Four Types of Critical Move Vulnerabilities (Springer)](https://link.springer.com/article/10.1007/s10586-025-05439-1)
- [MoveScan: Empirical Study of Move Security (ACM ISSTA 2024)](https://dl.acm.org/doi/10.1145/3650212.3680391)

### CTF Competitions & Writeups
- [MoveCTF 2024 Official](https://movectf2024.movebit.xyz/)
- [MoveCTF 2022 Official](https://movectf.movebit.xyz/)
- [CTF MOVEment (Aptos)](https://ctfmovement.movebit.xyz/)
- [Let's Move CTF](https://lets-ctf.vercel.app/)
- [MoveCTF GitHub](https://github.com/movectf)
- [Move CTF 2022 Writeup (saruman9)](https://github.com/saruman9/move_ctf_writeup)
- [MetaTrust CTF 2023 Sui Writeup](https://leoq7.com/2023/09/MetaTrust-CTF-Sui/)
- [MOVEment CTF 2022 Writeup (Amber)](https://ambergroup.medium.com/movement-ctf-2022-writeup-4904ff8a82e)
- [CTF MOVEment Aptos 2022 Writeup](https://leoq7.com/2022/12/CTF-Movement-Aptos/)
- [Blockchain Security CTFs Collection](https://github.com/blockthreat/blocksec-ctfs)

### Learning Resources
- [Move Language Integers](https://move-language.github.io/move/integers.html)
- [Sui Documentation](https://docs.sui.io/)
- [CertiK Move CTF Recap](https://www.certik.com/resources/blog/4S8Z03H8zhOtquhHVUltPN-move-capture-the-flag-competition-recap)
