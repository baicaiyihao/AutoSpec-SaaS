"""
Exploit Chain Analyzer - 漏洞利用链分析模块

核心功能：
1. 分析漏洞的完整利用链（入口 → 触发 → 影响）
2. 利用 RAG 检索类似漏洞的历史利用方式
3. 评估漏洞的实际可利用性
4. 将"理论漏洞"转化为"可验证漏洞"

设计原则：
- 如果说不清楚利用链，就不能确认是真实漏洞
- 利用 RAG 知识库中的真实案例来辅助分析
- 输出必须包含：入口点、攻击路径、前置条件、最终影响
"""

import json
import re
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Tuple
from enum import Enum


class ExploitGoal(Enum):
    """攻击目标类型"""
    FUND_THEFT = "fund_theft"              # 资金窃取
    PRIVILEGE_ESCALATION = "privilege_escalation"  # 权限提升
    DENIAL_OF_SERVICE = "denial_of_service"  # 拒绝服务
    DATA_MANIPULATION = "data_manipulation"  # 数据篡改
    PROTOCOL_DISRUPTION = "protocol_disruption"  # 协议破坏
    UNKNOWN = "unknown"


class ExploitComplexity(Enum):
    """利用复杂度"""
    LOW = "low"        # 直接调用即可
    MEDIUM = "medium"  # 需要特定条件/多步骤
    HIGH = "high"      # 需要闪电贷/复杂状态构造
    CRITICAL = "critical"  # 需要特殊时机/多方配合


class ExploitConfidence(Enum):
    """利用链置信度"""
    VERIFIED = "verified"      # 已验证可利用
    HIGH = "high"              # 高度确信可利用
    MEDIUM = "medium"          # 较可能可利用
    LOW = "low"                # 理论上可能
    THEORETICAL = "theoretical"  # 纯理论，未找到利用路径


@dataclass
class EntryPoint:
    """漏洞入口点"""
    module: str                    # 模块名
    function: str                  # 函数名
    visibility: str                # public / public(friend) / entry
    parameters: List[Dict]         # 参数列表 [{name, type, constraint}]
    caller_requirement: str        # "anyone" / "admin" / "specific_role"
    accessible_via: str            # "direct_call" / "ptb" / "callback"

    def to_signature(self) -> str:
        params = ", ".join([f"{p['name']}: {p['type']}" for p in self.parameters])
        return f"{self.module}::{self.function}({params})"


@dataclass
class AttackStep:
    """攻击步骤"""
    step_number: int
    action: str                    # 具体操作描述
    function_call: Optional[str]   # 调用的函数 (如果有)
    purpose: str                   # 这一步的目的
    state_change: str              # 状态变化


@dataclass
class Precondition:
    """前置条件"""
    condition: str                 # 条件描述
    how_to_achieve: str            # 如何达成
    difficulty: str                # "easy" / "medium" / "hard"
    realistic: bool                # 在真实场景中是否容易满足


@dataclass
class ExploitImpact:
    """利用影响"""
    goal: ExploitGoal              # 攻击目标
    description: str               # 影响描述
    affected_parties: List[str]    # 受影响方
    max_loss: str                  # 最大损失估算
    reversible: bool               # 是否可逆


@dataclass
class ExploitChain:
    """完整的漏洞利用链"""
    vulnerability_id: str
    vulnerability_type: str

    # 利用链核心信息
    entry_point: EntryPoint
    attack_path: List[AttackStep]
    preconditions: List[Precondition]
    impact: ExploitImpact

    # 评估信息
    complexity: ExploitComplexity
    confidence: ExploitConfidence
    exploitability_score: float    # 0-10 分

    # RAG 辅助信息
    similar_exploits: List[str]    # 类似的历史漏洞
    reference_patterns: List[str]  # 参考的漏洞模式 ID

    # 总结
    exploit_summary: str           # 一句话描述利用方式
    why_exploitable: str           # 为什么可以利用
    why_not_exploitable: Optional[str] = None  # 如果不可利用，原因是什么

    def is_real_vulnerability(self) -> bool:
        """判断是否是真实可利用的漏洞"""
        return (
            self.confidence in [ExploitConfidence.VERIFIED, ExploitConfidence.HIGH]
            and self.exploitability_score >= 6.0
            and len(self.attack_path) > 0
        )

    def to_report(self) -> str:
        """生成利用链报告"""
        report = []
        report.append(f"## 漏洞利用链分析: {self.vulnerability_id}")
        report.append(f"**类型**: {self.vulnerability_type}")
        report.append(f"**可利用性评分**: {self.exploitability_score}/10")
        report.append(f"**置信度**: {self.confidence.value}")
        report.append("")

        # 一句话总结
        report.append(f"### 利用方式")
        report.append(f"> {self.exploit_summary}")
        report.append("")

        # 入口点
        report.append(f"### 1. 入口点")
        report.append(f"- **函数**: `{self.entry_point.to_signature()}`")
        report.append(f"- **可见性**: {self.entry_point.visibility}")
        report.append(f"- **调用者要求**: {self.entry_point.caller_requirement}")
        report.append(f"- **访问方式**: {self.entry_point.accessible_via}")
        report.append("")

        # 攻击路径
        report.append(f"### 2. 攻击路径")
        for step in self.attack_path:
            report.append(f"**Step {step.step_number}**: {step.action}")
            if step.function_call:
                report.append(f"  - 调用: `{step.function_call}`")
            report.append(f"  - 目的: {step.purpose}")
            report.append(f"  - 状态变化: {step.state_change}")
        report.append("")

        # 前置条件
        report.append(f"### 3. 前置条件")
        for pre in self.preconditions:
            realistic = "✅ 易达成" if pre.realistic else "⚠️ 较难"
            report.append(f"- {pre.condition}")
            report.append(f"  - 达成方式: {pre.how_to_achieve}")
            report.append(f"  - 难度: {pre.difficulty} {realistic}")
        report.append("")

        # 影响
        report.append(f"### 4. 攻击影响")
        report.append(f"- **目标**: {self.impact.goal.value}")
        report.append(f"- **描述**: {self.impact.description}")
        report.append(f"- **受影响方**: {', '.join(self.impact.affected_parties)}")
        report.append(f"- **最大损失**: {self.impact.max_loss}")
        report.append(f"- **可逆性**: {'可逆' if self.impact.reversible else '不可逆'}")
        report.append("")

        # 为什么可利用
        report.append(f"### 5. 可利用性分析")
        report.append(f"**为什么可以利用**: {self.why_exploitable}")
        if self.why_not_exploitable:
            report.append(f"**潜在限制**: {self.why_not_exploitable}")
        report.append("")

        # 参考信息
        if self.similar_exploits:
            report.append(f"### 6. 类似历史案例")
            for exp in self.similar_exploits:
                report.append(f"- {exp}")

        return "\n".join(report)


class ExploitChainAnalyzer:
    """
    漏洞利用链分析器

    职责：
    1. 接收漏洞发现结果
    2. 分析完整的利用链
    3. 利用 RAG 检索类似案例
    4. 评估可利用性
    5. 输出结构化的利用链报告
    """

    def __init__(self, rag_retriever=None, llm_client=None):
        """
        Args:
            rag_retriever: RAG 检索器，用于查询类似漏洞
            llm_client: LLM 客户端，用于分析
        """
        self.rag_retriever = rag_retriever
        self.llm_client = llm_client

        # 加载漏洞模式到利用方式的映射
        self.exploit_patterns = self._load_exploit_patterns()

    def _load_exploit_patterns(self) -> Dict:
        """加载漏洞类型到利用方式的映射"""
        return {
            # 算术漏洞
            "overflow": {
                "typical_entry": ["deposit", "mint", "swap", "add_liquidity", "calculate"],
                "attack_pattern": "传入精心构造的大数值，使乘法溢出后得到极小或极大的结果",
                "typical_goal": ExploitGoal.FUND_THEFT,
                "complexity": ExploitComplexity.MEDIUM,
                "example_chain": [
                    "1. 找到执行乘法的函数入口",
                    "2. 构造接近 u64::MAX 的输入值",
                    "3. 乘法溢出导致计算结果异常",
                    "4. 利用异常结果获利（如获得超额份额）"
                ],
            },
            "precision_loss": {
                "typical_entry": ["deposit", "redeem", "withdraw", "calculate_shares"],
                "attack_pattern": "利用整数除法的精度损失，通过捐赠或小额操作使后续用户损失",
                "typical_goal": ExploitGoal.FUND_THEFT,
                "complexity": ExploitComplexity.HIGH,
                "example_chain": [
                    "1. 在池子为空时存入最小金额（如 1 wei）",
                    "2. 直接向池子捐赠大量代币",
                    "3. 等待其他用户存款",
                    "4. 由于精度损失，其他用户获得 0 份额",
                    "5. 提取所有资产"
                ],
            },

            # 访问控制
            "access_control": {
                "typical_entry": ["withdraw_all", "set_fee", "pause", "mint", "burn", "upgrade"],
                "attack_pattern": "直接调用缺少权限检查的敏感函数",
                "typical_goal": ExploitGoal.PRIVILEGE_ESCALATION,
                "complexity": ExploitComplexity.LOW,
                "example_chain": [
                    "1. 识别没有 Capability 参数的敏感函数",
                    "2. 直接调用该函数",
                    "3. 执行本应受限的操作"
                ],
            },
            "capability_leak": {
                "typical_entry": ["init", "create", "transfer"],
                "attack_pattern": "利用被错误共享的 Capability 对象",
                "typical_goal": ExploitGoal.PRIVILEGE_ESCALATION,
                "complexity": ExploitComplexity.LOW,
                "example_chain": [
                    "1. 发现 AdminCap 被 share_object() 而非 transfer()",
                    "2. 任何人都可以获取共享的 AdminCap 引用",
                    "3. 调用需要 AdminCap 的函数",
                    "4. 执行管理员操作"
                ],
            },

            # 预言机
            "oracle_manipulation": {
                "typical_entry": ["swap", "borrow", "liquidate", "get_price"],
                "attack_pattern": "通过闪电贷或大额交易操纵价格预言机",
                "typical_goal": ExploitGoal.FUND_THEFT,
                "complexity": ExploitComplexity.HIGH,
                "example_chain": [
                    "1. 闪电贷借入大量资金",
                    "2. 在 DEX 中交易，操纵现货价格",
                    "3. 目标协议读取被操纵的价格",
                    "4. 以有利价格执行借贷/清算",
                    "5. 归还闪电贷，保留利润"
                ],
            },

            # 闪电贷
            "flash_loan_non_repayment": {
                "typical_entry": ["borrow", "flash_loan"],
                "attack_pattern": "绕过 Hot Potato 强制还款机制",
                "typical_goal": ExploitGoal.FUND_THEFT,
                "complexity": ExploitComplexity.MEDIUM,
                "example_chain": [
                    "1. 调用闪电贷借款函数",
                    "2. 如果 Receipt 有 drop 能力，直接丢弃",
                    "3. 不调用还款函数",
                    "4. 保留借出的资金"
                ],
            },

            # 滑点
            "slippage": {
                "typical_entry": ["swap", "remove_liquidity"],
                "attack_pattern": "三明治攻击：前后夹击用户交易",
                "typical_goal": ExploitGoal.FUND_THEFT,
                "complexity": ExploitComplexity.HIGH,
                "example_chain": [
                    "1. 监听 mempool 中的大额交易",
                    "2. 抢先交易：提前买入目标代币",
                    "3. 受害者交易以更差价格成交",
                    "4. 尾随交易：卖出代币获利"
                ],
            },

            # 资源安全
            "resource_leak": {
                "typical_entry": ["process", "handle", "execute"],
                "attack_pattern": "触发资源泄露路径，导致代币丢失",
                "typical_goal": ExploitGoal.DENIAL_OF_SERVICE,
                "complexity": ExploitComplexity.MEDIUM,
                "example_chain": [
                    "1. 找到有多个返回路径的函数",
                    "2. 构造输入使函数走向不处理资源的路径",
                    "3. 资源（如 Coin）未被转移或销毁",
                    "4. 资源永久丢失在函数中"
                ],
            },

            # 类型安全
            "type_confusion": {
                "typical_entry": ["generic functions", "create<T>", "process<T>"],
                "attack_pattern": "利用泛型参数缺乏约束，传入恶意类型",
                "typical_goal": ExploitGoal.PROTOCOL_DISRUPTION,
                "complexity": ExploitComplexity.MEDIUM,
                "example_chain": [
                    "1. 找到接受泛型参数 <T> 的函数",
                    "2. 创建满足最小约束的恶意类型",
                    "3. 用恶意类型调用函数",
                    "4. 绕过预期的类型检查"
                ],
            },
        }

    async def analyze(
        self,
        vulnerability: Dict,
        source_code: str,
        context: Optional[Dict] = None
    ) -> ExploitChain:
        """
        分析漏洞的完整利用链

        Args:
            vulnerability: 漏洞发现结果
            source_code: 相关源代码
            context: 额外上下文（如合约 ABI、依赖关系等）

        Returns:
            ExploitChain: 完整的利用链分析
        """
        vuln_type = vulnerability.get("category", "unknown")
        vuln_id = vulnerability.get("id", "UNKNOWN")

        # Step 1: 从 RAG 检索类似漏洞的利用方式
        similar_cases = await self._retrieve_similar_exploits(vulnerability)

        # Step 2: 分析入口点
        entry_point = await self._find_entry_point(vulnerability, source_code)

        # Step 3: 构建攻击路径
        attack_path = await self._construct_attack_path(
            vulnerability, source_code, entry_point, similar_cases
        )

        # Step 4: 识别前置条件
        preconditions = await self._identify_preconditions(
            vulnerability, source_code, attack_path
        )

        # Step 5: 评估影响
        impact = await self._assess_impact(vulnerability, attack_path)

        # Step 6: 计算可利用性
        exploitability = self._calculate_exploitability(
            entry_point, attack_path, preconditions, impact
        )

        # Step 7: 生成总结
        summary = self._generate_summary(
            vulnerability, entry_point, attack_path, impact
        )

        return ExploitChain(
            vulnerability_id=vuln_id,
            vulnerability_type=vuln_type,
            entry_point=entry_point,
            attack_path=attack_path,
            preconditions=preconditions,
            impact=impact,
            complexity=exploitability["complexity"],
            confidence=exploitability["confidence"],
            exploitability_score=exploitability["score"],
            similar_exploits=[c.get("title", "") for c in similar_cases[:3]],
            reference_patterns=[c.get("id", "") for c in similar_cases[:5]],
            exploit_summary=summary["one_liner"],
            why_exploitable=summary["why_exploitable"],
            why_not_exploitable=summary.get("limitations"),
        )

    async def _retrieve_similar_exploits(self, vulnerability: Dict) -> List[Dict]:
        """从 RAG 知识库检索类似的漏洞利用案例"""
        if not self.rag_retriever:
            return []

        # 构建查询
        query_parts = []

        # 使用漏洞类型
        if "category" in vulnerability:
            query_parts.append(vulnerability["category"])

        # 使用检测线索
        if "detection_cues" in vulnerability:
            query_parts.extend(vulnerability["detection_cues"][:3])

        # 使用描述
        if "description" in vulnerability:
            query_parts.append(vulnerability["description"][:200])

        query = " ".join(query_parts)

        # 检索相似案例
        results = await self.rag_retriever.search(
            query=query,
            top_k=10,
            filters={"has_exploit_chain": True}  # 只检索有利用链的案例
        )

        return results

    async def _find_entry_point(
        self,
        vulnerability: Dict,
        source_code: str
    ) -> EntryPoint:
        """分析漏洞的入口点"""
        vuln_type = vulnerability.get("category", "")
        location = vulnerability.get("location", {})

        # 从漏洞位置推断入口
        vuln_function = location.get("function", "")
        vuln_module = location.get("module", "")

        # 检查漏洞函数本身是否是入口
        if self._is_public_entry(vuln_function, source_code):
            # 漏洞函数本身就是入口
            params = self._extract_params(vuln_function, source_code)
            return EntryPoint(
                module=vuln_module,
                function=vuln_function,
                visibility=self._get_visibility(vuln_function, source_code),
                parameters=params,
                caller_requirement=self._infer_caller_requirement(vuln_function, source_code),
                accessible_via="direct_call"
            )
        else:
            # 需要找到调用漏洞函数的 public 入口
            callers = self._find_public_callers(vuln_function, source_code)
            if callers:
                entry_func = callers[0]
                params = self._extract_params(entry_func, source_code)
                return EntryPoint(
                    module=vuln_module,
                    function=entry_func,
                    visibility="public",
                    parameters=params,
                    caller_requirement=self._infer_caller_requirement(entry_func, source_code),
                    accessible_via="direct_call"
                )

        # 如果找不到明确入口，使用类型特定的典型入口
        pattern = self.exploit_patterns.get(vuln_type, {})
        typical_entries = pattern.get("typical_entry", [])

        for entry_name in typical_entries:
            if entry_name in source_code:
                return EntryPoint(
                    module=vuln_module,
                    function=entry_name,
                    visibility="public (inferred)",
                    parameters=[],
                    caller_requirement="unknown",
                    accessible_via="inferred"
                )

        # 默认：无法确定入口
        return EntryPoint(
            module=vuln_module,
            function="UNKNOWN",
            visibility="unknown",
            parameters=[],
            caller_requirement="unknown",
            accessible_via="unknown"
        )

    def _is_public_entry(self, func_name: str, source_code: str) -> bool:
        """检查函数是否是 public/entry"""
        # 匹配 public fun 或 public entry fun
        pattern = rf'public\s+(entry\s+)?fun\s+{func_name}\s*[<\(]'
        return bool(re.search(pattern, source_code))

    def _get_visibility(self, func_name: str, source_code: str) -> str:
        """获取函数可见性"""
        patterns = [
            (rf'public\s+entry\s+fun\s+{func_name}', "public entry"),
            (rf'public\(package\)\s+fun\s+{func_name}', "public(package)"),
            (rf'public\(friend\)\s+fun\s+{func_name}', "public(friend)"),
            (rf'public\s+fun\s+{func_name}', "public"),
            (rf'entry\s+fun\s+{func_name}', "entry"),
            (rf'fun\s+{func_name}', "private"),
        ]
        for pattern, visibility in patterns:
            if re.search(pattern, source_code):
                return visibility
        return "unknown"

    def _extract_params(self, func_name: str, source_code: str) -> List[Dict]:
        """提取函数参数"""
        # 简化的参数提取
        pattern = rf'fun\s+{func_name}\s*(?:<[^>]*>)?\s*\(([^)]*)\)'
        match = re.search(pattern, source_code)
        if not match:
            return []

        params_str = match.group(1)
        params = []
        for param in params_str.split(','):
            param = param.strip()
            if ':' in param:
                name, type_ = param.split(':', 1)
                params.append({
                    "name": name.strip(),
                    "type": type_.strip(),
                    "constraint": self._infer_constraint(type_.strip())
                })
        return params

    def _infer_constraint(self, type_: str) -> str:
        """推断参数约束"""
        if "Coin" in type_ or "Balance" in type_:
            return "must_have_balance"
        if "Cap" in type_:
            return "must_own_capability"
        if "u64" in type_ or "u128" in type_:
            return "numeric_range"
        return "none"

    def _infer_caller_requirement(self, func_name: str, source_code: str) -> str:
        """推断调用者要求"""
        # 查找函数体
        pattern = rf'fun\s+{func_name}[^{{]*\{{([^}}]*)\}}'
        match = re.search(pattern, source_code, re.DOTALL)
        if not match:
            return "unknown"

        func_body = match.group(1)

        # 检查是否有 Capability 参数
        if "AdminCap" in func_body or "OwnerCap" in func_body:
            return "admin"
        if "tx_context::sender" in func_body:
            return "specific_address"

        return "anyone"

    def _find_public_callers(self, func_name: str, source_code: str) -> List[str]:
        """找到调用指定函数的 public 函数"""
        callers = []

        # 找所有 public 函数
        public_funcs = re.findall(r'public\s+(?:entry\s+)?fun\s+(\w+)', source_code)

        for pub_func in public_funcs:
            # 检查这个 public 函数是否调用了目标函数
            # 简化检查：看函数体中是否包含目标函数名
            pattern = rf'fun\s+{pub_func}[^{{]*\{{[^}}]*{func_name}\s*\([^}}]*\}}'
            if re.search(pattern, source_code, re.DOTALL):
                callers.append(pub_func)

        return callers

    async def _construct_attack_path(
        self,
        vulnerability: Dict,
        source_code: str,
        entry_point: EntryPoint,
        similar_cases: List[Dict]
    ) -> List[AttackStep]:
        """构建攻击路径"""
        vuln_type = vulnerability.get("category", "")

        # 首先尝试从类似案例中获取攻击路径
        for case in similar_cases:
            if "attack_path" in case:
                # 调整为当前漏洞的上下文
                return self._adapt_attack_path(case["attack_path"], vulnerability)

        # 使用预定义的攻击模式
        pattern = self.exploit_patterns.get(vuln_type, {})
        example_chain = pattern.get("example_chain", [])

        if example_chain:
            steps = []
            for i, step_desc in enumerate(example_chain, 1):
                steps.append(AttackStep(
                    step_number=i,
                    action=step_desc,
                    function_call=self._extract_function_from_step(step_desc, source_code),
                    purpose=self._infer_purpose(step_desc),
                    state_change=self._infer_state_change(step_desc)
                ))
            return steps

        # 如果没有预定义模式，使用 LLM 分析
        if self.llm_client:
            return await self._llm_analyze_path(vulnerability, source_code, entry_point)

        # 默认：返回基本路径
        return [AttackStep(
            step_number=1,
            action=f"调用 {entry_point.to_signature()}",
            function_call=entry_point.to_signature(),
            purpose="触发漏洞",
            state_change="待分析"
        )]

    def _adapt_attack_path(self, template_path: List, vulnerability: Dict) -> List[AttackStep]:
        """将模板攻击路径适配到当前漏洞"""
        steps = []
        for i, step in enumerate(template_path, 1):
            if isinstance(step, str):
                steps.append(AttackStep(
                    step_number=i,
                    action=step,
                    function_call=None,
                    purpose="",
                    state_change=""
                ))
            elif isinstance(step, dict):
                steps.append(AttackStep(
                    step_number=i,
                    action=step.get("action", ""),
                    function_call=step.get("function"),
                    purpose=step.get("purpose", ""),
                    state_change=step.get("state_change", "")
                ))
        return steps

    def _extract_function_from_step(self, step_desc: str, source_code: str) -> Optional[str]:
        """从步骤描述中提取函数调用"""
        # 查找常见的函数名模式
        patterns = [
            r'调用\s+(\w+::\w+)',
            r'调用\s+(\w+)\s*\(',
            r'执行\s+(\w+)',
            r'(\w+)\s*函数',
        ]
        for pattern in patterns:
            match = re.search(pattern, step_desc)
            if match:
                return match.group(1)
        return None

    def _infer_purpose(self, step_desc: str) -> str:
        """推断步骤目的"""
        keywords = {
            "借入": "获取攻击资金",
            "闪电贷": "获取大量临时资金",
            "交易": "操纵价格/状态",
            "存款": "建立攻击位置",
            "提取": "获取利润",
            "归还": "完成闪电贷闭环",
            "溢出": "触发计算错误",
            "调用": "执行漏洞函数",
        }
        for keyword, purpose in keywords.items():
            if keyword in step_desc:
                return purpose
        return step_desc.split("，")[0] if "，" in step_desc else "执行攻击步骤"

    def _infer_state_change(self, step_desc: str) -> str:
        """推断状态变化"""
        keywords = {
            "借入": "获得临时代币",
            "存款": "份额增加",
            "提取": "余额减少",
            "交易": "价格变化",
            "溢出": "计算结果异常",
        }
        for keyword, change in keywords.items():
            if keyword in step_desc:
                return change
        return "状态变化"

    async def _llm_analyze_path(
        self,
        vulnerability: Dict,
        source_code: str,
        entry_point: EntryPoint
    ) -> List[AttackStep]:
        """使用 LLM 分析攻击路径"""
        prompt = f"""分析以下漏洞的攻击路径：

漏洞信息：
{json.dumps(vulnerability, indent=2, ensure_ascii=False)}

入口点：{entry_point.to_signature()}

源代码片段：
```move
{source_code[:3000]}
```

请输出攻击步骤，格式：
1. [步骤描述] - 调用: [函数名] - 目的: [目的] - 状态变化: [变化]
"""
        if self.llm_client:
            response = await self.llm_client.generate(prompt)
            return self._parse_llm_steps(response)
        return []

    def _parse_llm_steps(self, response: str) -> List[AttackStep]:
        """解析 LLM 输出的步骤"""
        steps = []
        lines = response.strip().split('\n')
        for line in lines:
            match = re.match(r'(\d+)\.\s*(.+)', line)
            if match:
                step_num = int(match.group(1))
                content = match.group(2)

                # 解析各部分
                action = content.split(' - ')[0] if ' - ' in content else content
                func_match = re.search(r'调用:\s*(\S+)', content)
                purpose_match = re.search(r'目的:\s*([^-]+)', content)
                state_match = re.search(r'状态变化:\s*(.+)', content)

                steps.append(AttackStep(
                    step_number=step_num,
                    action=action.strip(),
                    function_call=func_match.group(1) if func_match else None,
                    purpose=purpose_match.group(1).strip() if purpose_match else "",
                    state_change=state_match.group(1).strip() if state_match else ""
                ))
        return steps

    async def _identify_preconditions(
        self,
        vulnerability: Dict,
        source_code: str,
        attack_path: List[AttackStep]
    ) -> List[Precondition]:
        """识别攻击的前置条件"""
        preconditions = []
        vuln_type = vulnerability.get("category", "")

        # 通用前置条件
        common_preconditions = {
            "oracle_manipulation": [
                Precondition(
                    condition="目标协议使用可操纵的价格源",
                    how_to_achieve="协议使用 DEX 现货价格而非 TWAP",
                    difficulty="medium",
                    realistic=True
                ),
                Precondition(
                    condition="有足够的资金操纵价格",
                    how_to_achieve="通过闪电贷获取",
                    difficulty="easy",
                    realistic=True
                ),
            ],
            "overflow": [
                Precondition(
                    condition="能够传入大数值参数",
                    how_to_achieve="直接构造接近 u64::MAX 的值",
                    difficulty="easy",
                    realistic=True
                ),
            ],
            "access_control": [
                Precondition(
                    condition="敏感函数没有权限检查",
                    how_to_achieve="代码中确实缺少 Capability 参数",
                    difficulty="easy",
                    realistic=True
                ),
            ],
            "precision_loss": [
                Precondition(
                    condition="池子处于空或低余额状态",
                    how_to_achieve="新池子或低流动性池",
                    difficulty="medium",
                    realistic=True
                ),
                Precondition(
                    condition="能够直接向池子捐赠代币",
                    how_to_achieve="池子地址可接收任意转账",
                    difficulty="easy",
                    realistic=True
                ),
            ],
            "slippage": [
                Precondition(
                    condition="能够监控待处理交易",
                    how_to_achieve="监听 mempool 或使用 MEV 服务",
                    difficulty="medium",
                    realistic=True
                ),
                Precondition(
                    condition="能够抢先执行交易",
                    how_to_achieve="支付更高 gas 费或使用验证者服务",
                    difficulty="medium",
                    realistic=True
                ),
            ],
        }

        if vuln_type in common_preconditions:
            preconditions.extend(common_preconditions[vuln_type])

        # 从攻击路径推断额外前置条件
        for step in attack_path:
            if "闪电贷" in step.action:
                preconditions.append(Precondition(
                    condition="有可用的闪电贷协议",
                    how_to_achieve="使用 Sui 上的闪电贷服务（如 DeepBook）",
                    difficulty="easy",
                    realistic=True
                ))
            if "存款" in step.action or "余额" in step.action:
                preconditions.append(Precondition(
                    condition="攻击者持有目标代币",
                    how_to_achieve="购买或闪电贷借入",
                    difficulty="easy",
                    realistic=True
                ))

        return preconditions

    async def _assess_impact(
        self,
        vulnerability: Dict,
        attack_path: List[AttackStep]
    ) -> ExploitImpact:
        """评估攻击影响"""
        vuln_type = vulnerability.get("category", "")
        severity = vulnerability.get("severity", "medium")

        # 根据漏洞类型确定攻击目标
        pattern = self.exploit_patterns.get(vuln_type, {})
        goal = pattern.get("typical_goal", ExploitGoal.UNKNOWN)

        # 确定影响范围
        if vuln_type in ["access_control", "capability_leak"]:
            affected = ["所有用户", "协议资金"]
            max_loss = "协议全部 TVL"
        elif vuln_type in ["oracle_manipulation", "overflow"]:
            affected = ["流动性提供者", "协议用户"]
            max_loss = "池子余额"
        elif vuln_type in ["slippage"]:
            affected = ["单次交易用户"]
            max_loss = "交易金额的滑点损失"
        elif vuln_type in ["precision_loss"]:
            affected = ["后续存款用户"]
            max_loss = "后续存款的全部金额"
        else:
            affected = ["待确定"]
            max_loss = "待评估"

        return ExploitImpact(
            goal=goal,
            description=self._generate_impact_description(vuln_type, attack_path),
            affected_parties=affected,
            max_loss=max_loss,
            reversible=False  # 大多数资金损失不可逆
        )

    def _generate_impact_description(self, vuln_type: str, attack_path: List[AttackStep]) -> str:
        """生成影响描述"""
        descriptions = {
            "overflow": "攻击者可以通过溢出计算获得超额代币或份额",
            "access_control": "攻击者可以执行本应受限的管理员操作",
            "capability_leak": "任何人都可以获取管理员权限",
            "oracle_manipulation": "攻击者可以操纵价格进行套利",
            "precision_loss": "攻击者可以窃取其他用户的存款",
            "slippage": "攻击者可以通过三明治攻击获利",
            "flash_loan_non_repayment": "攻击者可以借款不还",
            "resource_leak": "用户资产可能被永久锁定",
        }
        return descriptions.get(vuln_type, "攻击者可以利用此漏洞获利或破坏协议")

    def _calculate_exploitability(
        self,
        entry_point: EntryPoint,
        attack_path: List[AttackStep],
        preconditions: List[Precondition],
        impact: ExploitImpact
    ) -> Dict:
        """计算可利用性评分"""
        score = 10.0  # 满分开始

        # 入口点可达性
        if entry_point.function == "UNKNOWN":
            score -= 4.0  # 找不到入口，大幅扣分
        elif entry_point.caller_requirement == "admin":
            score -= 3.0  # 需要管理员权限
        elif entry_point.caller_requirement == "specific_address":
            score -= 2.0  # 需要特定地址

        # 攻击路径复杂度
        if len(attack_path) == 0:
            score -= 5.0  # 没有攻击路径
        elif len(attack_path) > 5:
            score -= 1.0  # 路径较复杂

        # 前置条件难度
        hard_preconditions = sum(1 for p in preconditions if p.difficulty == "hard")
        unrealistic_preconditions = sum(1 for p in preconditions if not p.realistic)
        score -= hard_preconditions * 0.5
        score -= unrealistic_preconditions * 2.0

        # 影响评估
        if impact.goal == ExploitGoal.UNKNOWN:
            score -= 2.0

        score = max(0.0, min(10.0, score))  # 限制在 0-10

        # 确定复杂度
        if len(attack_path) <= 2 and hard_preconditions == 0:
            complexity = ExploitComplexity.LOW
        elif len(attack_path) <= 4 and hard_preconditions <= 1:
            complexity = ExploitComplexity.MEDIUM
        else:
            complexity = ExploitComplexity.HIGH

        # 确定置信度
        if score >= 8.0 and entry_point.function != "UNKNOWN":
            confidence = ExploitConfidence.HIGH
        elif score >= 6.0:
            confidence = ExploitConfidence.MEDIUM
        elif score >= 4.0:
            confidence = ExploitConfidence.LOW
        else:
            confidence = ExploitConfidence.THEORETICAL

        return {
            "score": round(score, 1),
            "complexity": complexity,
            "confidence": confidence
        }

    def _generate_summary(
        self,
        vulnerability: Dict,
        entry_point: EntryPoint,
        attack_path: List[AttackStep],
        impact: ExploitImpact
    ) -> Dict:
        """生成利用总结"""
        vuln_type = vulnerability.get("category", "")

        # 一句话总结
        if entry_point.function != "UNKNOWN" and len(attack_path) > 0:
            one_liner = (
                f"攻击者可以通过调用 `{entry_point.function}` 函数，"
                f"经过 {len(attack_path)} 步操作，"
                f"达成 {impact.goal.value} 的目的"
            )
        else:
            one_liner = f"理论上存在 {vuln_type} 风险，但未找到明确的利用路径"

        # 为什么可利用
        why_parts = []
        if entry_point.caller_requirement == "anyone":
            why_parts.append("入口函数可被任何人调用")
        if any("闪电贷" in step.action for step in attack_path):
            why_parts.append("可通过闪电贷获取攻击所需资金")

        pattern = self.exploit_patterns.get(vuln_type, {})
        if "attack_pattern" in pattern:
            why_parts.append(pattern["attack_pattern"])

        why_exploitable = "；".join(why_parts) if why_parts else "存在可利用的代码逻辑"

        # 潜在限制
        limitations = None
        if entry_point.caller_requirement != "anyone":
            limitations = f"需要 {entry_point.caller_requirement} 权限才能触发"

        return {
            "one_liner": one_liner,
            "why_exploitable": why_exploitable,
            "limitations": limitations
        }


# ============================================================================
# 集成到审计流程
# ============================================================================

class EnhancedSecurityAuditor:
    """
    增强版安全审计器 - 集成利用链分析

    流程:
    1. 漏洞扫描 (SecurityScanner)
    2. 利用链分析 (ExploitChainAnalyzer)
    3. 过滤理论漏洞
    4. 生成最终报告
    """

    def __init__(self, scanner, exploit_analyzer: ExploitChainAnalyzer):
        self.scanner = scanner
        self.exploit_analyzer = exploit_analyzer

    async def audit(self, source_code: str, context: Optional[Dict] = None) -> Dict:
        """
        执行完整审计流程

        Returns:
            {
                "verified_vulnerabilities": [...],    # 已验证的真实漏洞
                "theoretical_vulnerabilities": [...], # 理论漏洞（无法验证利用链）
                "false_positives": [...],             # 误报
                "summary": {...}
            }
        """
        # Step 1: 漏洞扫描
        scan_results = await self.scanner.scan(source_code)

        # Step 2: 对每个发现进行利用链分析
        verified = []
        theoretical = []
        false_positives = []

        for vuln in scan_results.get("findings", []):
            # 分析利用链
            exploit_chain = await self.exploit_analyzer.analyze(
                vulnerability=vuln,
                source_code=source_code,
                context=context
            )

            # 根据利用链分析结果分类
            if exploit_chain.is_real_vulnerability():
                vuln["exploit_chain"] = asdict(exploit_chain)
                vuln["exploit_report"] = exploit_chain.to_report()
                verified.append(vuln)
            elif exploit_chain.confidence == ExploitConfidence.THEORETICAL:
                vuln["reason"] = exploit_chain.why_not_exploitable or "未找到可行的利用路径"
                theoretical.append(vuln)
            else:
                # 中等置信度的作为需要进一步审查
                vuln["exploit_chain"] = asdict(exploit_chain)
                vuln["needs_review"] = True
                theoretical.append(vuln)

        return {
            "verified_vulnerabilities": verified,
            "theoretical_vulnerabilities": theoretical,
            "false_positives": false_positives,
            "summary": {
                "total_findings": len(scan_results.get("findings", [])),
                "verified_count": len(verified),
                "theoretical_count": len(theoretical),
                "verification_rate": len(verified) / max(1, len(scan_results.get("findings", [])))
            }
        }


# ============================================================================
# 用于 RAG 检索的利用链模板
# ============================================================================

EXPLOIT_CHAIN_TEMPLATES = """
# 漏洞利用链模板库

## 1. 整数溢出利用链

### 入口点
- deposit(), mint(), swap(), add_liquidity()
- 任何接受 u64 数值参数的函数

### 攻击路径
1. 找到执行 `a * b` 乘法的代码路径
2. 构造 a 和 b 使得 a * b > u64::MAX
3. 溢出后得到的小值被用于后续计算
4. 利用计算错误获得超额收益

### 前置条件
- 函数接受外部输入的数值
- 计算中没有使用 u128 中间值
- 没有溢出检查

### 影响
- 可以铸造超额代币
- 可以获得超额份额
- 可以以极小成本获得大量资产

---

## 2. 访问控制绕过利用链

### 入口点
- withdraw_all(), set_fee(), pause(), upgrade()
- 任何敏感操作函数

### 攻击路径
1. 确认函数签名中没有 Capability 参数
2. 确认函数体中没有 sender 检查
3. 直接调用该函数
4. 执行敏感操作

### 前置条件
- 函数是 public 或 entry
- 缺少权限检查

### 影响
- 可以执行管理员操作
- 可以提取协议资金
- 可以修改关键参数

---

## 3. 首存者攻击利用链

### 入口点
- deposit(), initialize_pool()

### 攻击路径
1. 在池子为空时存入 1 wei
2. 直接向池子地址转入大量代币（捐赠）
3. 等待其他用户存款
4. 由于精度损失，其他用户获得 0 份额
5. 提取所有资产

### 前置条件
- 池子允许小额首次存款
- 池子接受直接转账
- 份额计算使用整数除法

### 影响
- 可以窃取后续所有存款

---

## 4. 闪电贷价格操纵利用链

### 入口点
- swap(), borrow(), liquidate()

### 攻击路径
1. 从闪电贷协议借入大量资金
2. 在目标 DEX 执行大额交易，推动价格
3. 目标协议读取被操纵的价格
4. 以有利价格执行操作（借贷/清算）
5. 反向交易恢复价格
6. 归还闪电贷，保留利润

### 前置条件
- 协议使用 DEX 现货价格
- 有足够流动性的闪电贷
- 单笔交易能显著影响价格

### 影响
- 可以套利获利
- 可以恶意清算其他用户

---

## 5. AdminCap 共享泄露利用链

### 入口点
- 任何需要 AdminCap 的函数

### 攻击路径
1. 确认 AdminCap 被 share_object() 而非 transfer()
2. 获取共享 AdminCap 的对象 ID
3. 在交易中引用该共享对象
4. 调用需要 AdminCap 的函数

### 前置条件
- AdminCap 在 init 中被错误共享

### 影响
- 任何人都是管理员
- 可以执行所有管理操作
"""
