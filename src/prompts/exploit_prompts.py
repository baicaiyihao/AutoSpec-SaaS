"""
Exploit Chain Analysis Prompts - 漏洞利用链分析提示词

核心原则：
1. 必须明确入口点、路径、影响
2. 理论性漏洞必须标记为"无法验证"
3. 利用 RAG 检索的历史案例增强分析
4. 输出结构化的可操作信息

=== Prompt 使用位置索引 ===

Phase 3 (RoleSwapMechanism 多角色验证):
- AUDITOR_VERIFICATION_PROMPT    → role_swap.py: verify_finding() [Auditor 角色]
- EXPERT_VERIFICATION_PROMPT     → role_swap.py: verify_finding() [Expert 角色]
- ANALYST_VERIFICATION_PROMPT    → role_swap.py: verify_finding() [Analyst 角色]

Phase 4 (WhiteHatAgent 漏洞验证):
- WHITE_HAT_VERIFICATION_PROMPT  → white_hat_agent.py: verify_vulnerability() [统一的工具辅助利用链分析]

辅助函数:
- build_rag_query()              → white_hat_agent.py: _retrieve_similar_cases()
- format_rag_results()           → white_hat_agent.py: verify_vulnerability()
- get_exploit_hints()            → white_hat_agent.py: verify_vulnerability()
"""

# ============================================================================
# Sui Move 安全规则常量 (供 Agent 参考，判断误报)
# ============================================================================

SUI_MOVE_FALSE_POSITIVE_RULES = {
    "init_function": "init(witness, ctx) 由运行时保护，只能发布时调用一次，外部无法调用",
    "init_permission": "init 函数的权限/身份验证问题是误报，因为外部根本无法调用",
    "init_reinit": "init 重复初始化是误报，Sui 保证只能执行一次",
    "witness_type": "witness 类型无法跨模块伪造，类型路径不同",
    "private_function": "private 函数无法从模块外部调用",
    "txcontext": "TxContext 由运行时注入，无法伪造 sender",
    "overflow_bypass": "Move VM 溢出会 abort，无法用于绕过验证逻辑",
    "type_mismatch": "需验证代码中实际类型签名，而非想当然",
    "cross_module_forge": "Sui 类型系统阻止跨模块构造私有结构体",
}

SUI_MOVE_REAL_VULN_PATTERNS = {
    # 权限控制
    "shared_no_acl": "public 函数操作 shared 对象但无权限检查",
    "coin_type_confusion": "泛型 Coin<T> 未验证类型",

    # 算术安全
    "integer_overflow": "算术运算无溢出检查 (注意：Move 会 abort，是 DoS 风险)",

    # 热土豆/资源安全
    "flash_loan_no_receipt": "闪电贷未使用 Hot Potato 模式",
    "receipt_has_drop": "Receipt/凭证结构体有 drop 能力，可绕过验证",
    "receipt_bypass": "存在其他函数可销毁 Receipt，绕过还款验证",
    "repay_type_not_verified": "闪电贷 repay 函数未验证还款代币类型与借款类型一致",
    "state_not_cleared": "资源使用后状态未清除，可重复使用 (如双花)",
    "object_not_transferred": "创建的对象未 transfer，导致资源悬空",

    # 类型混淆
    "generic_type_not_verified": "泛型函数未验证类型参数与存储/预期类型匹配",
    "struct_field_ignored": "结构体解构时用 _ 忽略了关键安全字段",

    # 外部依赖
    "oracle_manipulation": "单一价格源可被操控",
}

# ============================================================================
# Few-shot 验证示例 (提升 LLM 对 Sui Move 误报的识别率)
# ============================================================================

VERIFICATION_EXAMPLE_CONFIRMED = """
### 示例: 确认的漏洞

**输入漏洞**: Missing Access Control in withdraw (vault::withdraw)

**验证过程**:
1. `get_function_code("vault", "withdraw")` → 发现签名: `public fun withdraw(vault: &mut Vault, amount: u64, ctx: &mut TxContext)`
2. 没有 AdminCap 参数，没有 assert 检查 sender
3. `get_callers("vault", "withdraw")` → 确认是 public entry 函数，任何人可调用

**结论**: confirmed
```json
{
    "verification_result": "confirmed",
    "confidence": 90,
    "reasoning": "withdraw 是 public 函数，接受任意 sender，没有权限检查。任何人可提取 vault 资金。",
    "code_evidence": "public fun withdraw(vault: &mut Vault, amount: u64, ctx: &mut TxContext) { ... }"
}
```
"""

VERIFICATION_EXAMPLE_FALSE_POSITIVE = """
### 示例: 误报 (Sui Move 语言保护)

**输入漏洞**: init function can be called multiple times (token::init)

**验证过程**:
1. `get_function_code("token", "init")` → 发现签名: `fun init(witness: TOKEN, ctx: &mut TxContext)`
2. 这是 Sui Move 标准的 **one-time witness 模式**
3. `TOKEN` witness 参数只能在模块发布时由 Sui 运行时创建一次
4. 外部代码无法构造 `TOKEN` 类型 (类型路径不同)

**结论**: false_positive
```json
{
    "verification_result": "false_positive",
    "confidence": 95,
    "reasoning": "Sui Move init 函数需要 witness 参数，该参数只能由运行时创建一次。外部无法调用。",
    "sui_move_rule_applied": "init_function + witness_type"
}
```
"""

VERIFICATION_EXAMPLES = f"""
## 验证示例参考

{VERIFICATION_EXAMPLE_CONFIRMED}

{VERIFICATION_EXAMPLE_FALSE_POSITIVE}
"""

# ============================================================================
# 🔥 Phase 4: 白帽漏洞验证 Prompt (统一的工具辅助利用链分析)
# 使用位置: white_hat_agent.py → verify_vulnerability()
# ============================================================================

WHITE_HAT_VERIFICATION_PROMPT = """
# 任务：验证漏洞是否真的可以被利用

你是一个专业的白帽黑客。前面的Agent发现了一个潜在漏洞，你的任务是：
**尝试构建一个完整的exploit，验证这个漏洞是否真的存在**。

## ⚠️ 重要：优先使用预构建上下文！

**如果上面已经提供了"预构建的代码上下文"，那里已经包含了：**
- 漏洞函数的完整实现
- 调用者和被调用者的代码
- 相关类型定义
- Phase 3 的分析结果

**请直接基于这些代码进行分析！不要重复获取已有的信息。**

## 🔧 工具使用原则

**只在以下情况才调用工具：**
1. 预构建上下文中没有你需要的函数/类型
2. 需要追踪更深的跨模块调用链
3. 需要搜索类似漏洞模式

**可用工具：**
- `get_function_code(module, function)` - 获取函数实现
- `get_callers(module, function)` - 查找入口点
- `get_callees(module, function)` - 分析调用链
- `get_type_definition(type_name)` - 获取类型定义

**效率要求：**
- 如果预构建上下文足够，可以直接输出分析结果，不调用任何工具
- 每轮最多调用 2 个工具
- 不要重复调用获取相同信息

## 你的工作方式

1. **不要只描述问题** - 要真正尝试利用它
2. **从攻击者视角思考** - 我有什么？我需要什么？我怎么得到？
3. **写出可执行的PoC** - 让其他安全研究员能复现
4. **诚实判断** - 如果无法利用，说清楚缺少什么

## 🔥 漏洞传播分析 - 必做！

**函数 A 有漏洞时，必须分析调用 A 的函数 B 是否也受影响：**

1. 使用 `get_callers(module, function)` 查找谁调用了漏洞函数
2. 获取调用方代码，分析它如何使用漏洞函数的返回值/状态
3. 如果调用方依赖该返回值做判断（如权限检查、金额计算），则形成**漏洞传播链**

**分析模式：**
```
函数 A 有漏洞 (返回异常值/修改状态)
     ↓ 被调用
函数 B 使用 A 的返回值做安全判断
     ↓ 判断被绕过
函数 B 也有漏洞！继续分析谁调用了 B...
```

**在 PoC 中必须包含完整的传播链！**

## 🔥 Sui Move 特定规则 - 必须检查！

**以下情况是误报，必须标记为 false_positive：**

1. **init() 函数重入/重复调用问题**：
   - Sui Move 的 `init(witness: TYPE, ctx: &mut TxContext)` 函数由运行时保护
   - witness 类型只能在模块发布时由 Sui 运行时创建一次
   - 即使 `init` 看起来是 public 的，外部也无法调用，因为无法构造 witness
   - **结论**：init 函数的"重入"或"重复调用"漏洞是误报

2. **witness 类型伪造问题**：
   - 如果代码有 `struct VOTE has drop {{}}` 这样的 one-time witness 类型
   - 外部模块无法创建相同类型的 witness（类型路径不同）
   - **结论**：声称可以伪造 witness 的漏洞是误报

3. **private 函数直接调用**：
   - Sui Move 的 private 函数不能从模块外部调用
   - 即使通过 PTB (Programmable Transaction Block) 也不行
   - **结论**：声称可以直接调用 private 函数的漏洞是误报

4. **整数溢出绕过验证**：
   - Move VM 对所有算术运算进行溢出检查
   - 溢出时会 **abort 交易**，而非静默回绕到小值
   - 溢出是 DoS 风险，但**不能用于绕过验证逻辑**
   - **结论**：声称"溢出后值变小从而绕过检查"的漏洞是误报

5. **类型签名不匹配声明**：
   - 如果漏洞声称"函数 A 调用函数 B 时传递了错误类型"
   - **必须验证代码中的实际类型签名**，而非想当然
   - 使用 `get_function_code` 查看两个函数的参数类型
   - ⚠️ **注意同名函数陷阱**: 不同模块可能有同名函数但签名完全不同
     - 检查时必须使用**完整模块限定名** (module::function)
     - 不要假设同名函数有相同的参数类型
   - **结论**：如果类型实际匹配，则是误报

6. **跨模块伪造对象**：
   - Sui 的类型系统确保每个结构体都有唯一的类型路径 (package::module::Type)
   - 外部模块**无法构造**其他模块的私有结构体
   - 即使结构体名称相同，类型路径不同就是不同类型
   - **结论**：声称可以伪造其他模块私有对象的漏洞是误报

---

## 🔥 Sui Move 资源处理规则 - 写 PoC 必须遵守！

### 1. 对象必须被处理 (Linear Type)

Move 是线性类型语言，**所有创建的对象必须在函数结束前被处理**：

```move
// ❌ 错误：cred 没有被处理，编译失败
let cred = register(auth, payment, ctx);
// 函数结束，cred 悬空 → 编译器报错

// ✅ 正确：将对象转移给调用者
let cred = register(auth, payment, ctx);
public_transfer(cred, tx_context::sender(ctx));
```

**处理方式**（三选一）：
- `public_transfer(obj, recipient)` - 转移给某地址
- `destroy_xxx(obj)` - 调用析构函数销毁
- 作为返回值返回 - 让调用者处理

### 2. 热土豆模式 (Hot Potato Pattern)

**定义**：没有 `drop`、`store`、`copy` 能力的结构体，**必须在同一交易中被"消费"**。

```move
// 典型的热土豆：闪电贷 Receipt
struct Receipt {{ amount: u64 }}  // 注意：没有 drop 能力！

// 借款时返回 Receipt
public fun flash_borrow(pool: &mut Pool): (Coin, Receipt) {{ ... }}

// 还款时必须传入 Receipt 并销毁
public fun repay(pool: &mut Pool, coin: Coin, receipt: Receipt) {{
    // 验证还款金额
    assert!(coin::value(&coin) >= receipt.amount, E_INSUFFICIENT);
    // 销毁 Receipt（热土豆被消费）
    let Receipt {{ amount: _ }} = receipt;
}}
```

**安全审计要点**：
- 检查 Receipt 是否有 `drop` 能力 → 有则可绕过还款！
- 检查是否有其他函数可以销毁 Receipt → 可能绕过验证
- 检查 Receipt 字段是否可被篡改 → 可能伪造金额

### 3. 对象能力 (Abilities) 安全检查

| 能力 | 含义 | 安全风险 |
|------|------|----------|
| `key` | 可作为对象存储 | - |
| `store` | 可存入其他对象 | 可能被转移到意外位置 |
| `drop` | 可被丢弃 | 热土豆模式失效！ |
| `copy` | 可被复制 | 可能导致双花 |

**审计时检查**：
- 敏感凭证（Receipt, Capability）不应有 `drop`
- 代币类资产不应有 `copy`

---

## 请像真正的安全研究员一样分析

### Step 1: 理解漏洞点
- **使用 get_function_code 查看漏洞函数**
- 前面Agent说的问题在代码哪一行？
- 这个问题的本质是什么？

### Step 2: 寻找入口点
- **使用 get_callers 找到 public/entry 函数**
- 有没有 public/entry 函数可以触发这个漏洞？
- 攻击者需要什么权限才能调用？
- 需要什么对象/参数？

### Step 3: 构建攻击路径
- **使用 get_callees 理解函数调用关系**
- 从入口到漏洞触发，具体怎么走？
- 每一步做什么？传什么参数？
- 状态会怎么变化？

### Step 4: 验证可行性
- 前置条件在现实中能满足吗？
- 攻击成本是多少？收益是多少？
- 有没有什么会阻止攻击？

### Step 5: 写完整的 Exploit 模块

**PoC 必须是完整可执行的 Move 模块**，参照目标合约的实际代码编写。

**核心要求：**
1. 包含所有必要的 `use` 导入（从目标合约提取）
2. 函数签名使用目标合约中的**实际类型名**
3. 展示完整攻击流程：准备 → 触发漏洞 → 获利/造成影响
4. 每一步有注释说明目的
5. **不要编造函数名或类型名**

## 🚨 PoC 常见错误 - 必须避免！

1. **`coin::destroy_zero()` 误用**
   - 只能用于**确实为空**的 Coin
   - 对有余额的 Coin 使用会 abort
   - 要"偷"代币应该用 `public_transfer` 转给攻击者

2. **资源未处理**
   - Move 是线性类型，所有资源必须被消费
   - 创建的对象必须 transfer/destroy/返回
   - 函数结束时不能有悬空资源

3. **单函数调用不是 PoC**
   - PoC 要展示**完整攻击链**，不是只调用漏洞函数
   - 必须展示：攻击者如何准备、如何触发、最终获得什么

4. **热土豆未处理**
   - 无 drop 能力的 Receipt 必须在同一交易内消费
   - 检查是否有其他函数可以消费它（可能是绕过点）

5. **类型混淆攻击要完整展示**
   - 如果漏洞是泛型参数未验证，PoC 要展示用错误类型调用
   - 展示借 A 还 B 的完整流程

**PoC 质量检查：**
- [ ] 代码能实际编译运行吗？
- [ ] 所有资源都正确处理了吗？
- [ ] 攻击者最终获得/造成了什么？（必须明确）
- [ ] 是完整攻击链还是只有单步？

---

## 判断标准

| 状态 | 可利用性评分 | 标准 |
|------|-------------|------|
| verified | 8-10 | 找到完整利用链，单笔交易可触发，任何人可利用 |
| likely | 5-7 | 有明确攻击路径，但需要特定条件（闪电贷、多步骤） |
| theoretical | 2-4 | 理论上存在，但条件苛刻，经济上不可行 |
| false_positive | 0-1 | 代码逻辑正确，不存在漏洞 |

---

## 输出格式 (JSON)

### 🔥 关键要求：exploit 代码必须基于实际源代码

**你必须根据工具获取的代码来编写 exploit，不要编造函数名或类型名！**

### 🔴 所有输出必须使用中文！

**JSON 中所有文本字段都必须用中文！包括但不限于：**
- `title`: 漏洞标题 (如 "withdraw 函数缺少访问控制")
- `vulnerability_summary`: 漏洞摘要
- `root_cause`: 根本原因
- `attack_scenario`: 攻击步骤
- `reasoning`: 推理过程
- `recommended_mitigation`: 修复建议

**禁止输出英文描述！**
- ❌ 错误: `"title": "Missing Access Control in withdraw"`
- ✅ 正确: `"title": "withdraw 函数缺少访问控制"`
- ❌ 错误: `"vulnerability_summary": "The function lacks proper authorization checks..."`
- ✅ 正确: `"vulnerability_summary": "该函数缺少权限检查，任何人都可以调用提取资金..."`

### 如果漏洞可利用：

```json
{{
    "is_exploitable": true,
    "confidence": "high/medium/low",
    "exploitability_score": 0-10,

    "advisory": {{
        "title": "简洁描述问题本质",
        "severity": "Critical/High/Medium/Low",
        "vulnerability_type": "漏洞类型",
        "affected_component": "模块名::函数名（从代码提取）"
    }},

    "vulnerability_summary": "一段话描述：问题在哪、为什么能被利用、攻击者能得到什么",

    "technical_details": {{
        "root_cause": "漏洞的根本原因",
        "vulnerable_code": "从代码复制真实的漏洞代码片段",
        "vulnerable_line": "具体哪一行有问题"
    }},

    "exploit_reasoning": "利用思路链：发现X → 导致Y → 可以Z → 最终获得W",

    "exploit_analysis": {{
        "entry_function": "从代码复制真实的入口函数签名",
        "entry_visibility": "public/entry/public entry",
        "required_objects": ["列出需要的共享对象，从代码提取"],
        "required_capabilities": "需要什么权限？还是无需权限？",
        "attack_type": "直接调用 / 状态操控 / 闪电贷 / 三明治 / ..."
    }},

    "attack_scenario": [
        "Step 1: 具体描述第一步操作",
        "Step 2: 具体描述第二步操作",
        "..."
    ],

    "poc_code": "完整的 Move exploit 模块代码",

    "impact_assessment": {{
        "what_attacker_gains": "攻击者获得什么",
        "max_loss": "最大损失估算",
        "affected_users": "影响哪些用户",
        "attack_cost": "攻击成本",
        "profit_ratio": "收益/成本比"
    }},

    "preconditions": [
        {{"condition": "前置条件1", "difficulty": "easy/medium/hard", "realistic": true/false}}
    ],

    "recommended_mitigation": [
        "修复建议1",
        "修复建议2"
    ]
}}
```

### 如果漏洞不可利用：

```json
{{
    "is_exploitable": false,
    "confidence": "high",
    "exploitability_score": 2,

    "advisory": {{
        "title": "理论性问题 - [问题描述]",
        "severity": "Low",
        "vulnerability_type": "...",
        "affected_component": "..."
    }},

    "vulnerability_summary": "代码确实存在问题，但我尝试构建exploit时发现无法实际利用。",

    "technical_details": {{
        "root_cause": "问题的技术原因",
        "vulnerable_code": "相关代码",
        "why_its_a_problem": "为什么这段代码有问题"
    }},

    "exploit_attempt": {{
        "what_i_tried": "我尝试了什么方法来exploit",
        "where_it_failed": "在哪一步失败了",
        "missing_conditions": ["缺少什么条件才能成功exploit"]
    }},

    "why_not_exploitable": "详细解释为什么无法利用。例如：'虽然存在整数溢出，但要触发需要 total_shares 接近 u64::MAX (1.8e19)。按每次存款 1 SUI 计算，需要 1.8e19 次存款，这在经济上完全不可行。'",

    "blocking_factors": [
        {{
            "factor": "触发条件不现实",
            "explanation": "需要的数值超出实际可能范围"
        }}
    ],

    "risk_assessment": "虽然不可直接利用，但建议修复因为：...",

    "recommended_mitigation": [
        "虽然风险低，但建议..."
    ]
}}
```

## 核心要求

1. **你必须真正尝试构建exploit** - 不是理论分析
2. **主动使用工具查看代码** - 不要猜测，去看实际代码
3. **poc_code 必须可执行** - 给出完整的 Move 代码
4. **attack_scenario 必须具体** - Step 1/2/3 每一步做什么
5. **如果无法利用，说清楚为什么** - 你尝试了什么，在哪里失败
6. **量化影响** - 攻击者能获得多少，损失多少
"""


# ============================================================================
# 🔥 Phase 3: Auditor 工具辅助验证 Prompt
# 使用位置: role_swap.py → verify_finding() [Auditor 角色]
# ============================================================================

AUDITOR_VERIFICATION_PROMPT = """
## 角色
你是安全审计员，负责验证漏洞是否**真实存在且可被利用**。

## ⚠️ 核心原则：只确认可实际利用的漏洞

**不是所有代码问题都是安全漏洞！** 你必须回答：
1. 攻击者如何到达这个漏洞点？（入口点）
2. 攻击者能控制哪些输入？（可控参数）
3. 利用成功后攻击者能获得什么？（实际影响）

**如果无法回答以上任一问题 → 判定为 false_positive**

## 🔧 可用工具
1. `get_function_code(module, function)` - 获取函数实现
2. `get_callers(module, function, depth)` - 查找调用者 (找入口点)
3. `get_callees(module, function, depth)` - 查找被调用函数
4. `get_type_definition(type_name)` - 获取类型定义

## 🚫 必须排除的非漏洞类型 (v2.5.0)

以下情况**必须**判定为 **false_positive**，不要报告：

1. **硬编码常量**: 错误码、初始值、配置参数、费率、阈值
   - 例: `assert!(condition, 0)` 中的 `0` 是错误码，不是漏洞
   - 例: `fee = 100` 是初始配置，不是漏洞

2. **Mock/测试函数**: 包含 `abort 0` 的占位实现
   - 例: `fun emit_event() { abort 0 }` 是 mock 函数，不是漏洞

3. **纯 Getter 函数**: 只读取状态、不修改状态的函数
   - 函数名以 `get_`, `is_`, `has_`, `view_`, `read_` 开头
   - 没有 `&mut` 参数

4. **Sui Move 语言保护的情况**:
   - `init(witness, ctx)` 重入问题 → 运行时保护
   - `witness` 类型伪造 → 类型系统阻止
   - `private` 函数直接调用 → 语言层面阻止

## 验证检查点

### 1. 入口点验证
- 使用 `get_callers` 找到 public/entry 入口
- **问题**: 攻击者如何调用到这个漏洞函数？
- **如果没有 public 入口 → false_positive**

### 2. 输入可控性验证
- **问题**: 漏洞涉及的参数值能被攻击者控制吗？
- 区分: 用户输入 vs 合约内部计算值 vs 常量
- **如果参数完全由合约控制 → false_positive**

### 3. 实际影响验证
- **问题**: 成功利用后攻击者能得到什么具体收益？
- 必须是: 资金窃取 / 权限提升 / 合约状态破坏
- **如果只是 DoS 或理论性问题 → 降级或 false_positive**

## 判断标准
| 结论 | 条件 |
|------|------|
| confirmed | 有 public 入口、参数可控、能造成实际损失 |
| false_positive | 无入口/参数不可控/无实际影响/属于排除类型 |
| needs_more_info | 需要更多上下文来判断 |

## 🔴 所有输出必须使用中文！
**reasoning、code_evidence、concrete_impact 等文本字段必须用中文描述！**

## 输出 JSON
```json
{
    "verification_result": "confirmed|false_positive|needs_more_info",
    "confidence": 0-100,
    "reasoning": "验证过程（中文），包括使用了哪些工具、看到了什么代码",
    "code_evidence": "关键代码片段",
    "exploitation_check": {
        "entry_point": "public 函数名，若无则填 null",
        "controllable_params": ["可控参数列表（中文）"],
        "concrete_impact": "具体影响描述（中文）"
    },
    "exclusion_check": "是否属于排除类型（中文描述）",
    "severity_adjustment": "same|upgrade|downgrade",
    "adjusted_severity": "critical|high|medium|low"
}
```
""" + VERIFICATION_EXAMPLES


# ============================================================================
# 🔥 Phase 3: Expert 工具辅助验证 Prompt
# 使用位置: role_swap.py → verify_finding() [Expert 角色]
# ============================================================================

EXPERT_VERIFICATION_PROMPT = """
## 角色
你是 Move 语言专家，从语言特性角度验证漏洞是否**真的可被利用**。

## ⚠️ 核心原则：Move 语言有很强的安全保护

Move 类型系统和 Sui 运行时提供了许多内置保护。你的任务是判断：
**该漏洞是否能绑过这些保护实际造成危害？**

## 🔧 可用工具
1. `get_function_code(module, function)` - 获取函数实现
2. `get_type_definition(type_name)` - 获取 struct 定义和 abilities
3. `get_callees(module, function, depth)` - 分析调用链

## 🚫 必须排除的非漏洞类型 (v2.5.0)

以下情况 Move/Sui **语言层面**已经阻止攻击，判定为 **false_positive**：

1. **类型混淆声称**: 如 "可以用 Coin<A> 替代 Coin<B>"
   - Move 类型系统**严格匹配**，类型路径不同就是不同类型
   - **除非**漏洞是泛型函数未验证类型（如 `fun withdraw<T>(coin: Coin<T>)` 未检查 T）

2. **整数溢出绕过验证**: 如 "溢出后值变小从而绕过检查"
   - Move VM 溢出会 **abort 交易**，不会静默回绕
   - 溢出只是 DoS 风险，不是逻辑绕过

3. **跨模块对象伪造**: 如 "可以伪造 AdminCap"
   - Sui 类型系统确保私有结构体只能在定义模块内创建

4. **witness 伪造**: 如 "可以构造相同的 witness"
   - one-time witness 类型路径唯一，外部模块无法创建

## 验证检查点

### 1. 类型系统分析
- **问题**: 攻击是否需要绕过类型系统？如果是，Move 会阻止吗？
- 检查泛型函数是否真的未验证类型
- 检查类型转换是否合法

### 2. 能力约束分析
- 检查 abilities: `key`, `store`, `copy`, `drop`
- **热土豆** (无 drop): Receipt 有 drop 能力吗？有则可绕过！
- **双花风险**: 资产类型有 copy 能力吗？

### 3. 对象模型分析
- shared 对象: 任何人可访问 → 检查权限
- owned 对象: 只有所有者可操作 → 较安全
- **问题**: 漏洞涉及的对象类型是什么？谁能访问？

### 4. 实际利用可行性
- **问题**: 即使理论上有问题，攻击者能在实际中利用吗？
- 需要什么前置条件？这些条件现实吗？

## 判断标准
| 结论 | 条件 |
|------|------|
| confirmed | 类型系统/能力约束无法阻止、对象权限真的有问题 |
| false_positive | 语言层面阻止、能力约束阻止、类型系统阻止 |
| needs_context | 需要更多代码来判断 |

## 🔴 所有输出必须使用中文！
**reasoning、type_safety、ability_constraints、blocking_factors 等字段必须用中文！**

## 输出 JSON
```json
{
    "verification": {
        "status": "confirmed|false_positive|needs_context",
        "confidence": 0-100,
        "reasoning": "验证过程（中文）"
    },
    "move_analysis": {
        "type_safety": "类型系统是否阻止攻击（中文）",
        "ability_constraints": "能力约束分析（中文）",
        "object_model": "对象权限分析（中文）"
    },
    "language_protection_check": "Move/Sui 语言保护是否适用（中文）",
    "exploitability": {
        "is_exploitable": true/false,
        "attack_complexity": "low|medium|high",
        "blocking_factors": ["阻止攻击的因素（中文）"]
    }
}
```
"""


# ============================================================================
# 🔥 Phase 3: Analyst 工具辅助验证 Prompt
# 使用位置: role_swap.py → verify_finding() [Analyst 角色]
# ============================================================================

ANALYST_VERIFICATION_PROMPT = """
## 角色
你是业务分析师，从攻击者视角评估漏洞的**实际可利用性和影响**。

## ⚠️ 核心原则：量化实际影响

不要只说"可能有风险"，必须回答：
1. 攻击者需要投入多少成本？（gas、资金、时间）
2. 攻击者能获得多少收益？
3. 收益/成本比是否合理？**如果 < 1，可能不值得利用**

## 🔧 可用工具
1. `get_function_code(module, function)` - 理解业务逻辑
2. `get_callers(module, function, depth)` - 分析攻击路径
3. `get_function_purpose(function_id)` - 获取函数功能描述
4. `get_analysis_hints()` - 获取预分析的关键信息

## 🚫 应降级或排除的情况 (v2.5.0)

以下情况应判定为 **low 优先级**或直接认为不值得报告：

1. **经济不可行**:
   - 攻击成本 > 预期收益
   - 需要控制 > 50% 的池子/流动性
   - 需要的初始资金超过实际可能

2. **前置条件不现实**:
   - 需要合约处于特殊状态（如 total_supply = 0）
   - 需要精确时序（如在同一区块内）
   - 需要长时间等待（如锁定期后）

3. **影响有限**:
   - 只影响攻击者自己
   - 最大损失 < 1 SUI
   - 只是 DoS（可恢复）

## 评估检查点

### 1. 攻击者视角（量化！）
- 前置条件: 需要什么才能开始攻击？
- 攻击成本: gas费 + 初始资金 + 闪电贷成本
- 攻击收益: **具体金额或百分比**

### 2. 收益/成本分析
- 计算: profit = 收益 - 成本
- **如果 profit <= 0 或风险太高 → low 优先级**

### 3. 业务影响
- 影响范围: 所有用户 / 特定用户 / 仅攻击者
- 资金风险: TVL 的百分比？总额？
- 不可逆性: 能否恢复？

### 4. 修复紧迫性判断

| 优先级 | 条件 |
|--------|------|
| immediate | 攻击简单 + 收益高 + 任何人可执行 |
| high | 攻击可行 + 收益明显 + 条件不苛刻 |
| medium | 需要特定条件 OR 收益有限 |
| low | 理论漏洞 / 经济不可行 / 仅影响自己 |

## 🔴 所有输出必须使用中文！
**所有文本字段（preconditions、reasoning、attack_scenario 等）必须用中文描述！**

## 输出 JSON
```json
{
    "attack_analysis": {
        "preconditions": ["前置条件（中文）"],
        "attack_cost": "攻击成本估算（中文+具体数值）",
        "attack_profit": "预估收益（中文+具体数值）",
        "profit_cost_ratio": "收益/成本比"
    },
    "business_impact": {
        "affected_users": "受影响用户范围（中文）",
        "financial_risk": "资金风险（中文）",
        "protocol_impact": "对协议的影响（中文）",
        "is_recoverable": true/false
    },
    "economic_feasibility": {
        "is_profitable": true/false,
        "reasoning": "经济可行性分析（中文）"
    },
    "attack_scenario": "详细的攻击场景描述（中文 Step 1/2/3）",
    "mitigation_priority": "immediate|high|medium|low",
    "priority_reason": "为什么是这个优先级（中文）"
}
```
"""


# ============================================================================
# RAG 查询构建
# 使用位置: white_hat_agent.py → _retrieve_similar_cases()
# ============================================================================

def build_rag_query(vulnerability: dict) -> str:
    """构建 RAG 查询，检索类似漏洞的利用方式"""
    parts = []

    if "category" in vulnerability:
        parts.append(f"漏洞类型: {vulnerability['category']}")

    if "detection_cues" in vulnerability:
        parts.append(f"关键词: {' '.join(vulnerability['detection_cues'][:5])}")

    if "description" in vulnerability:
        desc = vulnerability["description"][:200]
        parts.append(f"描述: {desc}")

    if "severity" in vulnerability:
        parts.append(f"严重性: {vulnerability['severity']}")

    return " | ".join(parts)


def format_rag_results(results: list) -> str:
    """格式化 RAG 检索结果供 LLM 使用"""
    if not results:
        return "未找到类似的历史案例"

    formatted = []
    for i, result in enumerate(results[:5], 1):
        formatted.append(f"""
### 案例 {i}: {result.get('title', 'Unknown')}
- **ID**: {result.get('id', 'N/A')}
- **严重性**: {result.get('severity', 'N/A')}
- **类型**: {result.get('category', 'N/A')}
- **描述**: {result.get('description', 'N/A')[:300]}
- **利用方式**: {result.get('exploit_summary', result.get('recommendation', 'N/A'))}
""")

    return "\n".join(formatted)


# ============================================================================
# 漏洞类型到利用模式的映射
# 使用位置: white_hat_agent.py → verify_vulnerability() via get_exploit_hints()
# ============================================================================

EXPLOIT_PATTERN_HINTS = {
    "overflow": {
        "typical_entry": "deposit, mint, swap, calculate, add_liquidity",
        "attack_hint": "构造接近 u64::MAX 的输入值使乘法溢出",
        "precondition_hint": "函数接受外部数值输入，无溢出检查",
        "impact_hint": "获得超额代币或份额",
    },
    "access_control": {
        "typical_entry": "withdraw_all, set_fee, pause, mint, burn",
        "attack_hint": "直接调用缺少权限检查的敏感函数",
        "precondition_hint": "函数是 public 且无 Capability 参数",
        "impact_hint": "执行管理员操作，提取资金",
    },
    "oracle_manipulation": {
        "typical_entry": "swap, borrow, liquidate, get_price",
        "attack_hint": "通过闪电贷大额交易操纵 DEX 价格",
        "precondition_hint": "协议使用可操纵的价格源",
        "impact_hint": "套利或恶意清算",
    },
    "precision_loss": {
        "typical_entry": "deposit, redeem, calculate_shares",
        "attack_hint": "首存者攻击：小额存入 + 大额捐赠",
        "precondition_hint": "池子为空或低余额状态",
        "impact_hint": "窃取后续存款",
    },
    "slippage": {
        "typical_entry": "swap, remove_liquidity",
        "attack_hint": "三明治攻击：抢跑 + 尾随",
        "precondition_hint": "能监控并抢先执行交易",
        "impact_hint": "提取交易滑点利润",
    },
    "flash_loan": {
        "typical_entry": "borrow, flash_loan, flashloan",
        "attack_hint": "1) Receipt 有 drop 能力可直接丢弃; 2) repay 函数未验证还款类型可用便宜币还贵币; 3) 存在其他函数可销毁 Receipt",
        "precondition_hint": "检查: Receipt 的 abilities、repay 是否校验还款币种与借款币种一致、是否有其他消费 Receipt 的路径",
        "impact_hint": "借款不还或用低价值代币偿还高价值借款",
    },
    "type_confusion": {
        "typical_entry": "repay, redeem, withdraw, swap",
        "attack_hint": "泛型函数未验证类型参数与预期一致，可传入不同类型绕过检查",
        "precondition_hint": "函数使用泛型 <T> 但未校验 T 与存储的类型匹配",
        "impact_hint": "用低价值资产换取高价值资产",
    },
    "capability_leak": {
        "typical_entry": "init 函数或任何 Capability 创建点",
        "attack_hint": "利用被 share_object 的 Capability",
        "precondition_hint": "Capability 被错误共享而非转移",
        "impact_hint": "任何人获得管理员权限",
    },
    "resource_leak": {
        "typical_entry": "process, handle, execute",
        "attack_hint": "触发不处理资源的代码路径",
        "precondition_hint": "存在不处理 Coin/Balance 的分支",
        "impact_hint": "资产永久丢失",
    },
}


def get_exploit_hints(vulnerability_type: str) -> dict:
    """获取漏洞类型对应的利用提示"""
    return EXPLOIT_PATTERN_HINTS.get(
        vulnerability_type,
        {
            "typical_entry": "unknown",
            "attack_hint": "需要分析具体代码",
            "precondition_hint": "需要分析具体条件",
            "impact_hint": "需要评估具体影响",
        }
    )
