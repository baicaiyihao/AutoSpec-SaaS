{"id": "A-14", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Code Duplication in Liquidity Distribution Strategies", "severity": "", "issue_tags": [], "description": "Code Duplication in Liquidity Distribution Strategies\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-14", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": [], "description": "The dlmm_router package contains three separate liquidity distribution strategy implementations (spot.move, curve.move, bid_ask.move) with extreme code duplication. Unique differences: only 5-10 lines per strategy.\n\nThe only meaningful differences are:\n• spot.move: Uses uniform weight (1.0) for all bins\n• curve.move: Uses decreasing weight formula (MAX_WEIGHT - distance × decay)\n• bid_ask.move: Uses increasing weight formula (MIN_WEIGHT + distance × growth)\n\nBoth open_position and add_liquidity functions contain extensive logic. It is recommended to modularize their implementation by moving reusable or complex parts into dedicated helper functions to enhance clarity and reduce complexity.", "recommendation": "Replace spot.move, curve.move, and bid_ask.move with the unified strategies.move implementation:\n• Add Strategy enum to represent the three distribution types (Spot, Curve, BidAsk)\n• Implement single open_position function that accepts Strategy parameter\n• Implement single add_liquidity function that accepts Strategy parameter\n• Use pattern matching on Strategy enum to apply strategy-specific weight formulas\n• Extract common logic into helper functions:\n    ◦ calculate_distribution_params: handles weight calculation for all strategies\n    ◦ calculate_active_weights: computes active bin weights based on strategy", "remediation_status": "", "detection_cues": ["add_liquidity", "bid_ask", "bid_ask.move", "calculate_active_weights", "calculate_distribution_params", "curve.move", "dlmm_router", "open_position", "spot.move", "strategies.move"], "suggested_checks": []}
{"id": "L-5", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": "pool::add_reward", "title": "Inconsistent Validation in pool::add_reward", "severity": "", "issue_tags": ["reward"], "description": "Inconsistent Validation in pool::add_reward\n隐藏详细信息\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["add_reward", "pool::add_reward"], "suggested_checks": []}
{"id": "L-5", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": "pool::add_reward", "title": "keywords", "severity": "critical", "issue_tags": ["reward", "time_validation"], "description": "The pool::add_reward function is responsible for adding rewards to the pool, but it exhibits several inconsistencies.\n\nManagers (reward manager role) can bypass critical validations that non-managers must follow.. This could lead to inconsistencies if manager actions deviate from expected standards.\n\nStart time validations differ between pool and reward manager levels, causing uncertainty about the correct requirements.\n\nNeither pool::add_reward nor reward::add_reward validates that the reward amount is greater than zero.", "recommendation": "Apply consistent validation logic across all roles and levels, ensuring universal constraints with clear documentation. Enforce minimum rewards amount at least greater than zero.", "remediation_status": "remediated", "detection_cues": ["add_reward", "github.com", "period_emission_rates", "pool::add_reward", "reward::add_reward"], "suggested_checks": []}
{"id": "A-11", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Unnecessary Mutable Parameter Usage", "severity": "", "issue_tags": [], "description": "Unnecessary Mutable Parameter Usage\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-11", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": "config::emergency_unpause", "title": "keywords", "severity": "advisory", "issue_tags": ["time_validation", "upgrade"], "description": "Three public functions declare parameters as mutable (&mut) but only perform read operations on them. This violates Move's principle of least privilege and can mislead developers about a function's side effects:\n• registry::create_pool(…, config: &mut GlobalConfig,)only calls read-only methods\nand passes config as immutable &GlobalConfig to internal function\n• partner::update_time_range(…, ctx: &mut TxContext)\nonly calls tx_context::sender(ctx) which is a read operation\n• config::emergency_unpause(config: &mut GlobalConfig, …)\nonly reads config.before_version for validation\n\nUsing mut unnecessarily can introduce avoidable borrow-checker constraints in the calling code.", "recommendation": "Change all three parameters from mutable to immutable references.", "remediation_status": "remediated", "detection_cues": ["before_version", "config.before_version", "config::emergency_unpause", "create_pool", "emergency_unpause", "github.com", "partner::update_time_range", "registry::create_pool", "tx_context", "tx_context::sender", "update_time_range"], "suggested_checks": []}
{"id": "A-12", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Gas Waste Due to Missing No-Op Guards", "severity": "", "issue_tags": ["gas"], "description": "Gas Waste Due to Missing No-Op Guards\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-12", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": ["fee", "gas", "reward", "time_validation"], "description": "Several functions lack checks to prevent redundant state updates or unnecessary executions when inputs match existing values or when operation amounts are zero. These no-op operations do not impact protocol logic but still consume gas and increase transaction costs:\n• partner.move:update_ref_fee_rate → no check if new_fee_rate == current ref_fee_rate\n• partner.move:update_time_range → no check if start_time or end_time unchanged\n• reward.move:emergency_pause and emergency_unpause → no check if already in same state\n• reward.move:make_public and make_private → no check if already in target state\n• config.move:set_min_reward_duration and set_manager_reserved_reward_init_slots → no check if value unchanged\n• pool.move:collect_position_fee → no check if fee_a == 0 && fee_b == 0\n• pool.move:collect_position_reward → no check if amount == 0", "recommendation": "Add early-return guards to skip execution when parameters or states are unchanged, or when computed values (e.g., reward amounts or fees) are zero.\n\nOptionally, introduce a min_amount threshold parameter to ensure execution only when economically meaningful (for functions like collect_position_fee).", "remediation_status": "remediated", "detection_cues": ["config.move", "e.g", "emergency_pause", "emergency_unpause", "end_time", "github.com", "make_public", "new_fee_rate", "partner.move", "pool.move", "ref_fee_rate", "reward.move", "start_time", "update_ref_fee_rate", "update_time_range"], "suggested_checks": []}
{"id": "A-13", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Documentation / Comment Mismatches", "severity": "", "issue_tags": [], "description": "Documentation / Comment Mismatches\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-13", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": "Rounding::Down", "title": "keywords", "severity": "advisory", "issue_tags": ["fee", "reward"], "description": "Multiple functions and struct fields have comments that don't match the actual implementation, creating confusion and potential for errors during maintenance or audits:\n• parameters.move:124 comment says filter period < t < decay_period but code uses >=\n• dlmm_math.move:81, 86 (calculate_amount_in) comments say [Rounding::Down] but code uses mul_div_ceil\n• dlmm_math.move:145, 170, 296 (fee functions) comments say \"fee rate in basis points\" but actual unit is where 1_000_000_000 = 100%\n• reward.move documentation missing emergency_reward_pause field entirely", "recommendation": "Update all incorrect comments to match implementation.", "remediation_status": "remediated", "detection_cues": ["Rounding::Down", "calculate_amount_in", "decay_period", "dlmm_math", "dlmm_math.move", "emergency_reward_pause", "github.com", "mul_div_ceil", "parameters.move", "reward.move"], "suggested_checks": []}
{"id": "A-9", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Unnecessary Complexity in is_right_order", "severity": "", "issue_tags": [], "description": "Unnecessary Complexity in is_right_order\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["is_right_order"], "suggested_checks": []}
{"id": "A-9", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": [], "description": "The function is_right_order contains unnecessary complexity. Once it determines that byte_a > byte_b at line 393, it sets check_pass = true and continues looping through all remaining bytes. However, at this point the ordering is already determined and the function can return immediately.", "recommendation": "Simplify the function by returning immediately when the order is determined (remove check_pass entirely).", "remediation_status": "remediated", "detection_cues": ["byte_a", "byte_b", "check_pass", "github.com", "is_right_order"], "suggested_checks": []}
{"id": "L-3", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Incorrect Semantics for unblock(ALL) Operation", "severity": "", "issue_tags": [], "description": "Incorrect Semantics for unblock(ALL) Operation\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "L-3", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": [], "description": "The restriction system treats ALL as an independent role bit rather than a composite of all operation types. When unblock(entity, ALL) is called after specific operations were blocked, those specific blocks persist. The unblock function only removes the ALL bit, leaving individual operation bits intact.\n\nHowever, the is_blocked function correctly checks:\n• If ALL bit is set → return blocked\n• OR if specific operation bit is set → return blocked", "recommendation": "Implement proper ALL operation semantics where ALL represents the union of all operations or consider removing entity entirely in case of unblocking all operations.", "remediation_status": "remediated", "detection_cues": ["github.com", "is_blocked"], "suggested_checks": []}
{"id": "A-1", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Theoretical Collision Risk in new_pool_key", "severity": "", "issue_tags": [], "description": "Theoretical Collision Risk in new_pool_key\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["new_pool_key"], "suggested_checks": []}
{"id": "A-1", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": [], "description": "The function new_pool_key generates pool identifiers by concatenating two type names without encoding their boundary. This theoretically allows different type pairs to produce identical concatenations.\n\nHypothetical short type names (not actual Sui format):\n• Pool 1: TypeA = \"DEF\", TypeB = \"ABC\" → Concatenation = \"DEFABC\"\n• Pool 2: TypeA = \"DEFAB\", TypeB = \"C\" → Concatenation = \"DEFABC\"\nBoth pools would generate the same result, creating a collision.\n\nSui type names have the format: <package_address>::<module>::<type>, which makes such collisions practically impossible. But if type name formatting ever changes, vulnerability could become exploitable.\n\nAlso formal verification cannot mathematically prove collision-resistance without examining Move compiler internals.", "recommendation": "Add explicit length encoding to make collision mathematically impossible regardless of type name format (for at least one type).", "remediation_status": "acknowledged", "detection_cues": ["new_pool_key", "package_address"], "suggested_checks": []}
{"id": "A-8", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Lack of Start Time Validation in create_partner", "severity": "", "issue_tags": ["time_validation"], "description": "Lack of Start Time Validation in create_partner\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["create_partner"], "suggested_checks": []}
{"id": "A-8", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": ["time_validation"], "description": "The function create_partner does not validate that start_time is not in the past, while the test function create_partner_for_test does enforce this check. Partners with past start times become immediately active, which can distort analytics and historical tracking.", "recommendation": "Enforce the same validation as the test function (reject any start_time in the past) or auto-adjust to current time (If the provided start_time is in the past, automatically use the current time instead).", "remediation_status": "remediated", "detection_cues": ["create_partner", "create_partner_for_test", "github.com", "start_time"], "suggested_checks": []}
{"id": "A-5", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Mixed Tracking of Admin and User Withdrawals in reward_harvested", "severity": "", "issue_tags": ["access_control", "reward"], "description": "Mixed Tracking of Admin and User Withdrawals in reward_harvested\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["reward_harvested"], "suggested_checks": []}
{"id": "A-5", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": ["access_control", "reward"], "description": "The function emergency_withdraw_refund_reward withdraws refunded rewards by calling the internal withdraw function, which increments reward.reward_harvested. This mixes two fundamentally different types of withdrawals: user harvests and admin emergency withdrawals.\n\nAlso the documentation explicitly states reward.reward_harvested tracks user harvests, but admin withdrawals are included.", "recommendation": "Add a separate tracking field for admin emergency withdrawals to maintain clear accounting or document existing value contain both types of withdrawals.", "remediation_status": "remediated", "detection_cues": ["emergency_withdraw_refund_reward", "github.com", "reward.reward_harvested", "reward_harvested"], "suggested_checks": []}
{"id": "A-10", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "No Early Return in reward_index", "severity": "", "issue_tags": ["reward"], "description": "No Early Return in reward_index\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["reward_index"], "suggested_checks": []}
{"id": "A-10", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": ["reward"], "description": "The function reward_index in reward module does not return early when it finds the matching reward type. Instead, it continues iterating through all remaining elements in the vector, performing unnecessary comparisons", "recommendation": "Add an early return when a match is found, even though the number of rewards is currently limited to 5.", "remediation_status": "remediated", "detection_cues": ["github.com", "reward_index"], "suggested_checks": []}
{"id": "L-2", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "No Bounds Validation in set_min_reward_duration", "severity": "", "issue_tags": ["reward"], "description": "No Bounds Validation in set_min_reward_duration\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["set_min_reward_duration"], "suggested_checks": []}
{"id": "L-2", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": ["reward", "time_validation"], "description": "The function set_min_reward_duration in  module accepts any u64 value without validation. When min_reward_duration is set to a value near max u64, subsequent calls to add_reward will abort as there is no such end_time to calculate duration ≥ min_reward_duration.\n\nThere is also no upper bound on reward duration in add_reward, allowing managers to create reward periods spanning decades or centuries. This effectively locks reward tokens for impractically long periods, reducing capital efficiency and creating zombie rewards that will never realistically complete their emission schedule.", "recommendation": "Implement validation bounds for both configuration and usage:\n• add minimum and maximum duration constants\n• use them as bounds for min_reward_duration\n• enforce maximum duration in add_reward", "remediation_status": "remediated", "detection_cues": ["add_reward", "end_time", "github.com", "min_reward_duration", "set_min_reward_duration"], "suggested_checks": []}
{"id": "A-7", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Inefficient Data Structure for reward_white_list", "severity": "", "issue_tags": ["reward"], "description": "详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["reward_white_list"], "suggested_checks": []}
{"id": "A-7", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": ["reward"], "description": "The RewardConfig struct uses VecMap<TypeName, bool> for reward_white_list, but the boolean values are meaningless. The code always inserts true and only checks for key presence using contains(), never reading the boolean value itself.\n\nThe boolean value carries no semantic meaning - the key's presence itself indicates whitelist membership.", "recommendation": "Replace VecMap<TypeName, bool> with VecSet<TypeName> throughout the codebase. VecSet is semantically correct for set membership and more efficient.", "remediation_status": "acknowledged", "detection_cues": ["reward_white_list"], "suggested_checks": []}
{"id": "A-6", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Redundant Field Assignment in add_liquidity", "severity": "", "issue_tags": [], "description": "Redundant Field Assignment in add_liquidity\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": ["add_liquidity"], "suggested_checks": []}
{"id": "A-6", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": [], "description": "The add_liquidity function in position module contains redundant field assignments. The function calls new_bin_stat which already initializes BinStat fields with the bin's global growth values, then immediately overwrites these exact same fields with identical values.", "recommendation": "Remove the redundant field assignments.", "remediation_status": "remediated", "detection_cues": ["add_liquidity", "github.com", "new_bin_stat"], "suggested_checks": []}
{"id": "A-4", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Missing Helper Function for Score Composition", "severity": "", "issue_tags": [], "description": "Missing Helper Function for Score Composition\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-4", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": [], "description": "The codebase contains at least 5 instances where scores are manually calculated from group index and offset using the formula group_index * 16 + offset. This duplicates logic across multiple functions without a corresponding helper function, despite having the inverse operation resolve_bin_position that decomposes scores into their components.", "recommendation": "Introduce a helper function (e.g. compose_score) for score calculation. This creates symmetry with resolve_bin_position, improves code clarity, and centralizes the score composition logic in a single location.", "remediation_status": "remediated", "detection_cues": ["compose_score", "e.g", "github.com", "group_index", "resolve_bin_position"], "suggested_checks": []}
{"id": "A-3", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Redundant Loop Condition in prev_score_in_group", "severity": "advisory", "issue_tags": [], "description": "advisory\nremediated\nRedundant Loop Condition in prev_score_in_group\n查看详情\nID", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["prev_score_in_group"], "suggested_checks": []}
{"id": "A-3", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": ["overflow"], "description": "The while loop in prev_score_in_group function uses while (offset >= 0) where offset is type u8. Since unsigned integers can never be negative, this condition is always true.\n\nAlso function contains a 10-line if-else block handling the offset_in_group == 0 case, but most of this complexity is unnecessary. The loop can naturally handle the include case, and only the underflow case requires special handling to prevent offset = 0 - 1 underflow.", "recommendation": "Simplify the function by removing redundant logic: remove redundant loop condition and replace if-else block with edge case processing only:\nif (!include && offset_in_group == 0) {\n    return option_u64::none()\n};", "remediation_status": "remediated", "detection_cues": ["github.com", "offset_in_group", "prev_score_in_group"], "suggested_checks": []}
{"id": "L-1", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Missing Validation and Performance Optimization in add_group_if_absent", "severity": "low", "issue_tags": [], "description": "low\nremediated\nMissing Validation and Performance Optimization in add_group_if_absent\n查看详情\nID", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["add_group_if_absent"], "suggested_checks": []}
{"id": "L-1", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": ["gas", "oracle", "time_validation"], "description": "The function add_group_if_absent accepts group_index without validation and can create bins with IDs outside the valid range. The public wrapper in pool module exposes this to external callers without additional checks.\n\nAdditionally, for each new group, the function creates 16 bins by calling default_bin → get_price_from_id → pow(base, bin_id) sixteen times. This performs 16 expensive exponential calculations.", "recommendation": "Calculate the corresponding score from group_index and validate that it falls within acceptable bounds.\n\nConsider optimizing performance by replacing power function with multiplication: calculate base price for the first bin and for each subsequent bin, multiply the current price by the base value. This incremental multiplication maintains the mathematical relationship between consecutive bins while avoiding repeated exponential calculations. This reduces gas costs for group creation by approximately 60 to 80 percent.", "remediation_status": "remediated", "detection_cues": ["add_group_if_absent", "bin_id", "default_bin", "get_price_from_id", "github.com", "group_index"], "suggested_checks": []}
{"id": "L-4", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Missing Input Validation in bin_id_from_score", "severity": "low", "issue_tags": [], "description": "low\nremediated\nMissing Input Validation in bin_id_from_score\n查看详情\nID", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["bin_id_from_score"], "suggested_checks": []}
{"id": "L-4", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "low", "issue_tags": ["upgrade"], "description": "The public function bin_id_from_score converts a score to a bin ID without validating the input, creating an asymmetry with its inverse function bin_score which enforces strict validation.", "recommendation": "Add input validation matching the constraints enforced by bin_score: ensure that score falls within a valid and expected range before conversion.", "remediation_status": "remediated", "detection_cues": ["bin_id_from_score", "bin_score", "github.com"], "suggested_checks": []}
{"id": "A-2", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "Code Duplication in Liquidity Management", "severity": "", "issue_tags": [], "description": "Code Duplication in Liquidity Management\n查看详情\nID", "recommendation": "", "remediation_status": "", "detection_cues": [], "suggested_checks": []}
{"id": "A-2", "project": "Cetus-DLMM-Audit-Report", "source_file": "Cetus-DLMM-Audit-Report.md", "module_path": null, "function": null, "title": "keywords", "severity": "advisory", "issue_tags": [], "description": "The liquidity management system contains significant code duplication between position opening and liquidity addition operations inside pool module:\n• OpenPositionCert and AddLiquidityCert are ~90% identical (16 shared fields). Only differences: width and next_bin_id fields in OpenPositionCert.\n• repay_open_position and repay_add_liquidity share ~90% identical code. Only difference: 3 lines for width validation in open variant.\n• open_position_on_bin and add_liquidity_on_bin differs only by sequential bin validation and range checks in open variant\n• new_open_position_cert and new_add_liquidity_cert\n• open_position and add_liquidity\n\nCode duplication introduces maintenance risks and should be refactored. However, if the duplicated code is already in production and well tested, the refactoring can be postponed until a major protocol update.", "recommendation": "Apply the composition pattern to eliminate duplication. Use the AddLiquidityCert struct as part of OpenPositionCert, keeping specific fields like width and next_bin_id in the OpenPositionCert.\n\nThen refactor position-related functions to use their liquidity counterparts, ensuring that all validations are performed at the appropriate level.", "remediation_status": "acknowledged", "detection_cues": ["add_liquidity", "add_liquidity_on_bin", "new_add_liquidity_cert", "new_open_position_cert", "next_bin_id", "open_position", "open_position_on_bin", "repay_add_liquidity", "repay_open_position"], "suggested_checks": []}
{"id": "A-8", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Optimization in Tick Math Price Calculation", "severity": "advisory", "issue_tags": ["oracle"], "description": "New\nadvisory\nThe get_tick_at_sqrt_price function in the tick_math module performs multiple bit operations to calculate tick indices, with each step introducing new local variables instead of reusing existing ones. It uses decimal values for bit manipulation constants with poor readability.\nReuse mutable msb_bits and msb_shifted variables to reduce allocations.\nReplace decimal constants with hexadecimal bit masks for better readability (e.g., replace 4294967296 with 0x100_000_000)\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["e.g", "get_tick_at_sqrt_price", "github.com", "msb_bits", "msb_shifted", "tick_math"], "suggested_checks": []}
{"id": "L-3", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Total Volume Overflow Risk in Volume Tracking", "severity": "high", "issue_tags": ["overflow"], "description": "New\nlow\nThe stats module uses u64 type for total_volume tracking, which presents a potential overflow risk for active pools. While the add_total_volume_internal function is not currently used during swaps, its future implementation could lead to transaction reverts due to overflow, effectively blocking swap operations in high-volume pools.\nUse u256 type for volume tracking to significantly increase the maximum trackable volume. Also consider implementing a denominator system (e.g., track volume in larger units) to further increase the maximum value.\nAdd an overflow strategy, for example one of the following:\n• Emit an event and reset volume to zero when overflow is detected\n• Implement periodic resets (e.g., daily/weekly volume tracking)\n• Store historical periods in a separate accumulator\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["add_total_volume_internal", "e.g", "github.com", "total_volume"], "suggested_checks": []}
{"id": "M-8", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": "module::A", "title": "Type Order Validation Bypass in Pool Key Generation", "severity": "critical", "issue_tags": [], "description": "New\nmedium\nThe new_pool_key function in the factory module contains a critical flaw in its type order validation logic. The issue occurs because the function modifies the comparison buffer (bytes_a) during processing but uses the modified length for validation checks, rather than the original length.\nThe function appends bytes_b from the second type name to bytes_a during comparison in the while loop. When the second type name extends the first one (like \"A\" vs \"A0\"), the comparison flag swapped remains false as all common bytes match. The subsequent length validation check becomes meaningless because it compares lengths after bytes_b were already appended to bytes_a. This allows creating pools with the same types using different type orderings, breaking the fundamental protocol invariant that each unique type pair should have a unique pool key and pool.\n// Example\npublic struct A {}    // type_name = \"0x123::module::A\"\npublic struct A0 {}   // type_name = \"0x123::module::A0\"\n// Both calls succeed when one should fail\nlet key1 = new_pool_key<A, A0>(tick_spacing);\nlet key2 = new_pool_key<A0, A>(tick_spacing);\nUse a separate result variable for types concatenation, or perform concatenation after all validation checks are completed, which separates the type ordering validation logic from the key generation logic. This ensures that the original type names remain unmodified during comparison.\nremediated\ngithub.com/LFB…f3c372", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["bytes_a", "bytes_b", "github.com", "module::A", "module::A0", "new_pool_key", "tick_spacing", "type_name"], "suggested_checks": []}
{"id": "M-3", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Missing Validation for tick_spacing in add_fee_tier", "severity": "medium", "issue_tags": ["fee", "oracle"], "description": "New\nmedium\nThe add_fee_tier function in config module does not validate the tick_spacing parameter, allowing callers to set arbitrarily large values.\nA very large tick_spacing significantly reduces tick density across the price range. In concentrated liquidity models like CLMM, this results in extremely coarse or even absent liquidity across wide price intervals, leading to inefficient pricing and degraded trading performance.\nEnforce a reasonable upper bound for tick_spacing in add_fee_tier to prevent accidents and ensure efficient tick layout.\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["add_fee_tier", "github.com", "tick_spacing"], "suggested_checks": []}
{"id": "L-7", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Version Validation in update_package_version", "severity": "low", "issue_tags": ["upgrade"], "description": "New\nlow\nThe update_package_version function in the config module allows setting any value, including older or identical versions. This can lead to unintended downgrades or redundant updates, potentially causing compatibility or versioning issues.\nAdditionally, the lack of a public getter for package_version makes it difficult to verify the current version for external callers or before performing updates.\nModify update_package_version to allow only strictly increasing values (i.e., new_version > current_version) to prevent accidental or malicious downgrades.\nProvide a public read-only function to access the current package_version, enabling safe pre-checks by external callers.\nConsider using constants instead of literals during initialization and checks.\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["current_version", "github.com", "i.e", "new_version", "package_version", "update_package_version"], "suggested_checks": []}
{"id": "L-5", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Overlapping Error Codes", "severity": "low", "issue_tags": [], "description": "New\nlow\nMultiple modules define error codes with overlapping numeric values, leading to potential ambiguity. Error codes are typically defined sequentially, starting from 0 or 1.\nThis can lead to ambiguous error reporting and make debugging or on-chain analysis more difficult, as the origin of the error may be unclear.\nRefactor the codebase so that all used error codes have unique numeric values. A common practice is to centralize error code management in a single module or shared file to prevent duplication across modules.\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["github.com"], "suggested_checks": []}
{"id": "L-1", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Missing checked_package_version Enforcement in Multiple Functions", "severity": "low", "issue_tags": ["fee", "reward", "upgrade"], "description": "New\nlow\nSeveral functions across the factory and pool modules are missing calls to checked_package_version, which is used to ensure compatibility and enforce upgrade safety in systems with upgradeable packages.\nOmitting this check allows these functions to be called even when the package version is outdated or mismatched, potentially leading to unintended behavior, security vulnerabilities, or inconsistent state if the logic is changed in newer versions.\nAffected Functions:\n• factory module\n◦ receive_ref_fee\n• pool module\n◦ mark_position_staked\n◦ mark_position_unstaked\n◦ collect_fullsail_distribution_gauger_fees\n◦ update_fullsail_distribution_growth_global\n◦ init_fullsail_distribution_gauge\n◦ stake_in_fullsail_distribution\n◦ unstake_from_fullsail_distribution\n◦ sync_fullsail_distribution_reward\nInclude a call to checked_package_version at the start of each affected function to ensure they only execute when the package version is verified to be current.\nacknowledged", "recommendation": "", "remediation_status": "acknowledged", "detection_cues": ["checked_package_version", "collect_fullsail_distribution_gauger_fees", "init_fullsail_distribution_gauge", "mark_position_staked", "mark_position_unstaked", "receive_ref_fee", "stake_in_fullsail_distribution", "sync_fullsail_distribution_reward", "unstake_from_fullsail_distribution", "update_fullsail_distribution_growth_global"], "suggested_checks": []}
{"id": "L-4", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Incorrect Old Values Emitted in Update Events", "severity": "low", "issue_tags": ["fee", "upgrade"], "description": "New\nlow\nSeveral configuration and pool update functions emit events that include both the old and new values of updated parameters. However, the old values emitted are incorrect because the new values are written to storage before the event is emitted. As a result, both old and new values in the event payload reflect the new state, misleading off-chain consumers and compromising auditability.\nAffected functions:\n• config module:\n◦ update_package_version\n◦ update_protocol_fee_rate\n◦ update_fee_tier\n◦ update_unstaked_liquidity_fee_rate\n• pool module:\n◦ update_fee_rate\n◦ update_unstaked_liquidity_fee_rate\nAdditionally, some of these functions include an assertion new ≠ old to prevent redundant updates, while others do not.\nStore the current value in a temporary variable before updating storage. Use this saved value as the old field in the emitted event. Alternatively, emit the event before updating the value in storage.\nConsider applying a consistent pattern across all update functions by asserting that new_value ≠ old_value before proceeding with the update.\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["github.com", "new_value", "old_value", "update_fee_rate", "update_fee_tier", "update_package_version", "update_protocol_fee_rate", "update_unstaked_liquidity_fee_rate"], "suggested_checks": []}
{"id": "A-1", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Tick Cleanup in update_by_liquidity When Liquidity Reaches Zero", "severity": "advisory", "issue_tags": [], "description": "1\nNew\nadvisory\nThe update_by_liquidity function in tick module skips updating the tick’s state entirely if (updated_liquidity_gross == 0), under the assumption that an external function will subsequently remove the tick from the list. This approach breaks encapsulation by requiring external logic.\nRelying on external cleanup introduces a risk: if future changes to code paths forget to remove the tick or defer its removal, stale ticks may remain in the list with outdated or incorrect state.\nTo maintain encapsulation and reduce the chance of misuse, update_by_liquidity should itself handle tick cleanup when liquidity drops to zero.\nacknowledged", "recommendation": "", "remediation_status": "acknowledged", "detection_cues": ["update_by_liquidity", "updated_liquidity_gross"], "suggested_checks": []}
{"id": "L-12", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "fetch_ticks Behavior Deviates from Other Fetch Functions", "severity": "low", "issue_tags": [], "description": "New\nlow\nThe fetch_ticks function in the tick module behaves inconsistently compared to other fetch_* functions.\nIt skips the tick at tick_indexes[0] itself, starting from the next tick(include parameter in find_next function is set to false). This differs from other fetch functions, which typically include the starting element, and can lead to unexpected omissions or developer confusion.\nAdditionally, fetch_ticks function does not check the limit in the while loop condition, only inside the loop body. As a result, if the limit is set to zero, the loop still runs and continues fetching until the end of the list, since the break condition if (new_count == limit) is never satisfied. While a limit of zero could be interpreted as \"fetch all\", this behavior is not aligned with the comments or how limits are handled in similar functions.\nConsider modifying fetch_ticks to include the tick at tick_indexes[0] for consistency with other fetch_* functions, which typically include the starting element. To handle sentinel ticks appropriately, you can extract the relevant logic from first_score_for_swap into a shared helper function.\nAlso move the count limit check into the while loop condition to prevent any iterations when limit == 0, aligning with how other fetch_* functions handle limits. Remove the redundant new_count variable and increment count directly to streamline the logic.\nremediated\ngithub.com/LFB…157211", "recommendation": "", "remediation_status": "remediated", "detection_cues": ["fetch_", "fetch_ticks", "find_next", "first_score_for_swap", "github.com", "new_count", "tick_indexes"], "suggested_checks": []}
{"id": "H-1", "project": "fullsail", "source_file": "fullsail.md", "module_path": null, "function": null, "title": "Incorrect Tick Initialization Logic for Upper Tick (invalid)", "severity": "low", "issue_tags": ["fee", "reward"], "description": "1\nNew\nThe update_by_liquidity function in the tick module uses a single is_lower_initialized flag and applies the same initialization logic for both lower and upper ticks. This behavior is likely a consequence of an initial naming issue. As a result, the function does not correctly distinguish the conditions under which global growth values should be applied for each tick boundary.\nSpecifically, for lower ticks, global growth values should be used when current_tick >= tick.index, whereas for upper ticks, they should be used when current_tick < tick.index. Applying the same logic to both cases results in incorrect initialization of growth values for upper ticks.\nThis flaw may lead to inconsistencies in fee accounting, reward distribution, and other state updates dependent on accurate tick growth tracking.\nTo align with the correct tick initialization logic, the is_lower_initialized flag should be renamed to a more general is_tick_initialized, and the logic should be explicitly split using the existing is_upper flag to distinguish between upper and lower ticks:\n• for lower ticks use global values if current_tick >= tick.index, otherwise use zero.\n• for upper ticks use global values if current_tick < tick.index, otherwise use zero.\ninvalid", "recommendation": "", "remediation_status": "", "detection_cues": ["current_tick", "is_lower_initialized", "is_tick_initialized", "is_upper", "tick.index", "update_by_liquidity"], "suggested_checks": []}
{"id": "H-1", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Unbounded Revenue Factor Enables Fund Drainage", "severity": "high", "issue_tags": ["access_control"], "description": "The revenue_factor parameter in interest model has no upper bound validation when\nconfigured by theAdminCapholder, allowing values exceeding 100%. This enables systematic\ntheft of depositor funds through a sophisticated virtual accounting mechanism that gradually\ndrains the shared cash pool without triggering aborts.\nTherevenue_factoris used to calculaterevenue_increasedbased ondebt_increased.\nThis is purely an accounting operation, no actual funds are moved at this stage. As a result,\nvalues greater than 100% won’t cause an immediate abort.\nHowever, the protocol later attempts to extract real funds based on these virtual claims.\nIfbalance_sheet.cashcontains sufficient funds, the protocol may claim revenue (partially\nfrom the users’ deposit pool to cover above 100% revenue). This can lead to serious inconsis-\ntencies in the accounting and balances state, and ultimately cause aborts during legitimate\nuser claims due to insufficient cash in the pool.\nThis is not just a parameter validation issue. It’s a user fund safety vulnerability.", "recommendation": "Assertions should be added to ensure thatrevenue_factorcannot be set higher than 100%\n(or preferably, a more conservative upper bound).", "remediation_status": "remediated", "detection_cues": ["Ifbalance_sheet.cashcontains", "calculaterevenue_increasedbased", "ondebt_increased", "revenue_factor", "thatrevenue_factorcannot"], "suggested_checks": []}
{"id": "M-2", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Market UID Access Through ext Function", "severity": "medium", "issue_tags": ["access_control", "fee", "upgrade"], "description": "The ext function in app.move provides direct mutable access to the Market object’s UID\nwithout any validation or constraints. While it requires AdminCap, this creates a dangerous\nbypass mechanism that allows AdminCap owner to manipulate critical protocol state outside\nof established safety controls.\nThe Market UID stores critical protocol configuration as dynamic fields, including the\nfollowing:\n\n- BorrowFeeVaultKey → Collected borrow fees storage\n- WhitelistKey → Individual address permissions\n- AllowAllKey → Global allow mode\n- RejectAllKey → Global reject mode\n- BorrowFeeKey → Borrow fee rates per asset\n- BorrowFeeRecipientKey → Fee recipient address\n- SupplyLimitKey → Maximum supply limits per asset\n- BorrowLimitKey → Maximum borrow limits per asset\n- IsolatedAssetKey → Asset isolation status\n    With mutable UID access, an attacker can perform any dynamic field operation (add,\nremove, modify) to manipulate protocol configuration. The most obvious attack vectors\ninclude enabling unlimited borrowing to drain protocol reserves, bypassing all whitelist re-\nstrictions, and removing or corrupting critical configuration fields, rendering the protocol\ninoperable. And these are just a few examples. Requiring an AdminCap reduces risk, but\nbypassing the protocol’s safety mechanisms and restrictions still poses a serious threat.", "recommendation": "Remove the ext function entirely as it represents a fundamental security anti-pattern.\nIf extensibility is truly required, all current uses of the ext function should be carefully\nreviewed and replaced with specific, validated administrative functions that preserve protocol\nsafety guarantees.\nAt the very least, the ext function must include strict validation and constraints to allow\nonly a narrowly defined set of safe actions.", "remediation_status": "remediated", "detection_cues": ["app.move"], "suggested_checks": []}
{"id": "M-6", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "dynamic_field::borrow", "title": "Borrow Fee Recipient is Required but Ignored", "severity": "medium", "issue_tags": ["access_control", "fee"], "description": "Borrow fee recipient configuration is non-functional, but mandatory for borrowing function-\nality.\nThe borrow_internal function fetches the configured borrow_fee_recipient address using\ndynamic_field::borrow. This field is added only via update_borrow_fee_recipient call.\nBut borrow_internal completely ignores recipient when distributing borrow fees. Instead\nof sending fees to the intended recipient, all fees are stored in the protocol’s internal vault.\nThe protocol provides update_borrow_fee_recipient function for admins to configure\nfee recipients, and it must be called to add required configuration dynamic field. But this\nconfiguration has no effect on actual fee distribution.\nWhile not a direct security vulnerability, this represents a functional defect that breaks\nan intended protocol feature and could lead to incorrect financial assumptions.", "recommendation": "Implement actual fee transfer to recipient or remove unused recipient system entirely.", "remediation_status": "remediated", "detection_cues": ["borrow_fee_recipient", "borrow_internal", "dynamic_field", "dynamic_field::borrow", "update_borrow_fee_recipient"], "suggested_checks": []}
{"id": "M-4", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Division by Zero Risk in Liquidation Amount Cal-", "severity": "medium", "issue_tags": ["access_control"], "description": "The max_liquidation_amounts function contains a division by zero vulnerability in the\ndenominator calculation at line 88. The function calculates:\ndenominator = borrow_weight × (1 - liq_penalty) - liq_factor\nIf the expression borrow_weight × (1 - liq_penalty) is less than or equal to liq_factor,\nthe denominator becomes zero or negative, causing the function to abort.\nThis scenario is possible with the current validation limits for administrative configura-\ntion, where liq_penalty � 20%, liq_factor � 95%, and borrow_weight is unconstrained. When\ninterest models and risk models are configured independently without cross-validation, spe-\ncific parameter combinations can result in zero or negative denominators, causing aborts.\nThis can completely disable liquidations for specific parameter combinations, leading to\nprotocol insolvency and bad debt accumulation.", "recommendation": "Implement parameter validation to prevent dangerous combinations that can disable liqui-\ndations and threaten protocol solvency.\nAdd cross-parameter validation in all interest and risk models configuration functions to\nensure the liquidation denominator always maintains at least some minimum safety margin\nabove zero (e.g. 5%).", "remediation_status": "acknowledged", "detection_cues": ["borrow_weight", "e.g", "liq_factor", "liq_penalty", "max_liquidation_amounts"], "suggested_checks": []}
{"id": "M-5", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Interest Rate Kink Points Lack Bounds Valida-", "severity": "medium", "issue_tags": ["access_control", "overflow", "time_validation"], "description": "The interest rate model uses kink points (mid_kink,high_kink) to determine utilization\nrate thresholds for different interest rate segments. Current validation during administrative\nconfiguration is incomplete, missing bounds checks that can cause division by zero errors\nand complete interest calculation failure.\nThecalc_interestfunction aborts if\n\n- mid_kink= 0→line 170\n- high_kink=mid_kink→line 182\n- high_kink≥100%→line 193\n\nThis cause complete interest calculation failure, which prevents all lending operations (includ-\ning repayment of borrowed funds) as they callupdate_interest_rates→calc_interest.\nThe function also lacks upper bound validation for the rate parameters at kink points\n(base_rate_per_sec,borrow_rate_on_mid_kink,borrow_rate_on_high_kink, andmax_borrow_rate).\nWhile their relative ordering is validated, extreme absolute values could cause economic dis-\nruption.\nLarge rate values combined with time calculations in borrow index updates may cause\noverflow conditions, particularly in the formula old_borrow_index * interest_rate *\ntime_deltaduring interest accrual.", "recommendation": "Add comprehensive validation increate_interest_model_change:\n\n- high_kink<scale\n- mid_kink<high_kink\n- mid_kink> 0\n\nImplement reasonable upper bounds for rate parameters likemax_borrow_rate≤MAX_REASONABLE_RATE\nto prevent economically extreme configurations alongside the existing kink point validation.\nAdditionally, enforce thatutil_rate≤1 in thecalc_interestfunction to maintain\ncorrect interest calculation.", "remediation_status": "remediated", "detection_cues": ["andmax_borrow_rate", "base_rate_per_sec", "borrow_rate_on_high_kink", "borrow_rate_on_mid_kink", "calc_interest", "callupdate_interest_rates", "high_kink", "increate_interest_model_change", "interest_rate", "likemax_borrow_rate", "mid_kink", "old_borrow_index", "thatutil_rate", "thecalc_interestfunction", "time_deltaduring"], "suggested_checks": []}
{"id": "M-3", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Multiple Primary Rules Break Oracle System", "severity": "medium", "issue_tags": ["access_control", "fee", "oracle"], "description": "The oracle system’sdetermine_pricefunction strictly requires exactly one primary price\nfeed but lacks validation to prevent administrators from configuring multiple primary rules\nfor the same coin type.\nadd_primary_price_update_rule_v2allows unlimited rules. When two or more primary\nrules are accidentally configured, every price update transaction fails withONLY_SUPPORT_ONE_PRIMARY,\nmaking the oracle completely unusable until admin intervention.\nThis creates a single point of failure where a simple configuration mistake can break the\nentire oracle system for affected assets.", "recommendation": "Add primary rule limit validation to allow only one primary rule as it is expected by\ndetermine_price.\nUse named constants for required primary feeds and secondary consensus threshold.", "remediation_status": "remediated", "detection_cues": ["determine_price", "sdetermine_pricefunction"], "suggested_checks": []}
{"id": "M-1", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Pyth Oracle Fails with Positive Exponents", "severity": "medium", "issue_tags": ["fee", "oracle", "upgrade"], "description": "The Pyth oracle integration contains a bug that causes transaction aborts when processing\nprice feeds with positive exponents. The get_pyth_price function incorrectly assumes all\nPyth exponents are negative, using i64::get_magnitude_if_negative which aborts if the\nexponent is positive. This makes entire asset categories unusable in the oracle system.\nActual Pyth exponent semantics:\n\n- Negative expo (-8): Price has 8 decimal places (common)\n- Positive expo (+2): Price is scaled up by 10² (possible for low-value assets)\n\nThe rule.move decimal conversion logic (lines 42-47) assumes all exponents represent decimal\nplaces, incorrectly handling positive exponents during 9-decimal normalization.", "recommendation": "Fix exponent handling in pyth_adaptor and decimal conversion in rule.\nAdditionally, add reasonable decimal limits (e.g. 18 instead of U8_MAX (255))", "remediation_status": "acknowledged", "detection_cues": ["e.g", "get_magnitude_if_negative", "get_pyth_price", "pyth_adaptor", "rule.move"], "suggested_checks": []}
{"id": "L-4", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Borrow Weight Lacks Upper Limit", "severity": "low", "issue_tags": [], "description": "The borrow_weight parameter in interest models has no upper bound validation, allow-\ning extreme values that make borrowing mathematically impossible or create unstable risk\ncalculations. This parameter is used for risk-weighted debt calculations and affects both\nborrowing capacity and liquidation mathematics.\nWhile there is no abort during configuration, extreme values like 100000% can make\nborrowing mathematically impossible for specific assets.", "recommendation": "Add reasonable upper bound validation in create_interest_model_change.", "remediation_status": "remediated", "detection_cues": ["borrow_weight", "create_interest_model_change"], "suggested_checks": []}
{"id": "L-9", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Math Library mul_div Implementation Can Be", "severity": "low", "issue_tags": ["overflow", "upgrade"], "description": "The mul_div implementations inu64,u128, andu256math modules contain inefficiencies\nand a potential division by zero vulnerability. These optimizations can improve performance\nand eliminate unnecessary complexity while fixing a safety issue.\nu64::mul_divcurrently delegates tou128::mul_divwith type casting. For u64val-\nues, direct multiplication tou128cannot overflow, making the complex overflow handling\nunnecessary.\nu128::mul_divalso can cast tou256avoiding overflow. But instead it useschecked_mul\nandis_safe_mulhelpers, adding unnecessary function call overhead and code complexity.\nis_safe_mulfunction inu128andu256causes division by zero when x = 0, even though\nmathematically 0 * y = 0 never overflows.", "recommendation": "Foru64::mul_div: Replace with direct multiplication usingu128casting. Sinceu64*u\nalways fits inu128, no overflow checking needed. Just assertc != 0and result fits inu64.\nForu128::mul_div: Useu256approach similar tou64. Cast tou256, multiply, divide,\ncheck result fits inu128.\nAdd early return forx == 0 || y == 0 cases inis_safe_mul for u256before divi-\nsion check to eliminate division by zero. Remove unused versions of checked_muland\nis_safe_mulfunctions.", "remediation_status": "acknowledged", "detection_cues": ["andis_safe_mulhelpers", "checked_muland", "inis_safe_mul", "is_safe_mulfunction", "is_safe_mulfunctions", "mul_div", "mul_divalso", "mul_divcurrently", "mul_divwith", "useschecked_mul"], "suggested_checks": []}
{"id": "L-1", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Legacy V1 Rules Completely Ignored and Mislead-", "severity": "low", "issue_tags": ["access_control", "oracle", "upgrade"], "description": "The oracle system implements two parallel rule management systems (V1 and V2) that\nappear to work together but V1 rules are completely ignored during validation, creating a\nsilent security bypass where administrators can configure rules that will never be enforced.\nThe legacy V1 system provides add_rule and remove_rule functions to manage policy.rules.\nHowever, the V2 system has transitioned to using dynamic fields for configuration.\nThe function get_price_update_policy, which is used during confirm_request validation,\nonly reads from the V2 dynamic field and completely ignores legacy V1 policy.rules.\nThe same applies to the wrapper functions add_primary_price_update_rule, remove_pri-\nmary_price_update_rule, add_secondary_price_update_rule, and remove_secondary_price_up-\ndate_rule, which are all built on top of the deprecated legacy functions add_rule and re-\nmove_rule.\nThis results in a misleading and broken admin interface. Administrators may believe they\nare configuring rules via add_rule / remove_rule, but these changes have no effect on actual\nbehavior.", "recommendation": "Replace all legacy V1 functions with aborts to prevent any misleading or non-functional\nusage.\nIntegrate dynamic field initialization directly into the new function. This eliminates the need\nfor calling init_rules_df_if_not_exist() separately, ensuring atomic and complete initial-\nization of objects.\nIn long term remove V1 system and init_rules_df_if_not_exist function entirely.", "remediation_status": "remediated", "detection_cues": ["add_primary_price_update_rule", "add_rule", "add_secondary_price_update_rule", "confirm_request", "date_rule", "get_price_update_policy", "init_rules_df_if_not_ex", "init_rules_df_if_not_exist", "mary_price_update_rule", "move_rule", "policy.rules", "remove_pri", "remove_rule", "remove_secondary_price_up"], "suggested_checks": []}
{"id": "L-6", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Multiple AuthorizedWitnessList Creation Enables", "severity": "low", "issue_tags": ["access_control", "time_validation"], "description": "The borrow referral system contains two identical functions (initandcreate_witness_list,\ncallable via public functioncreate_referral_witness_list) that createAuthorizedWitnessList\nobjects, violating the singleton principle.\nThecreate_borrow_referralaccepts anyAuthorizedWitnessListobject as param-\neter. An attacker with admin access could create multiple witness lists, self-authorize\ntheir witness in a rogue list, and bypass the intended authorization system when creating\nBorrowReferralobjects.\nReferral system appears unused in main codebase, reducing immediate impact", "recommendation": "Remove duplicatecreate_witness_listfunction or make it[test_only]if it is intended\nfor tests.\nAlternatively, enforce singleton usage by specifying the exact active list to be used by\nthe protocol, and adding runtime checks to ensure the provided list matches the expected\none.", "remediation_status": "acknowledged", "detection_cues": ["duplicatecreate_witness_listfunction", "functioncreate_referral_witness_list", "initandcreate_witness_list", "test_only"], "suggested_checks": []}
{"id": "L-7", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Incomplete Dynamic Field Cleanup in destroy_bor-", "severity": "low", "issue_tags": ["fee"], "description": "Thedestroy_borrow_referralfunction only removes theReferralFeeKeydynamic field\nbut fails to clean up theBorrowedKeydynamic field and any custom configuration fields\nadded viaBorrowReferralCfgKey. This creates a resource leak where dynamic field data\nbecomes permanently inaccessible after the parent object is deleted.", "recommendation": "Implement complete cleanup of all associated dynamic fields.", "remediation_status": "remediated", "detection_cues": ["beforedestroy_borrow_referral", "destroy_bor", "remove_referral_cfgmust", "row_referral", "viaadd_referral_cfg"], "suggested_checks": []}
{"id": "L-5", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "callversion::assert_current_version", "title": "Missing Version Validation in Administrative Func-", "severity": "low", "issue_tags": ["access_control", "upgrade"], "description": "All administrative functions in the app module that requireAdminCapdo not validate the pro-\ntocol version before executing. While user-facing functions consistently callversion::assert_current_version(version)\nto ensure compatibility, administrative functions bypass this validation entirely.\nPotentially, Admin operations on outdated protocol versions could corrupt market state.", "recommendation": "Ensure administrative operations maintain the same version safety as user operations, pre-\nventing state corruption during protocol upgrades:\n\n- Modify all admin functions to acceptversion: &Versionparameter\n- Add validationversion::assert_current_version(version);at the beginning of\n    each admin function.", "remediation_status": "acknowledged", "detection_cues": ["assert_current_version", "callversion::assert_current_version", "validationversion::assert_current_version"], "suggested_checks": []}
{"id": "L-3", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "wit_table::add", "title": "Missing Parameter Validation in Limiter Configu-", "severity": "low", "issue_tags": [], "description": "The add_limiter, create_limiter_params_change, and create_limiter_limit_change func-\ntions lack critical input validation, allowing invalid configurations that can cause division by\nzero errors, infinite loops, or non-functional rate limiting.\nKey validation gaps are:\n\n- build_segmentsperformsoutflow_cycle_duration/outflow_segment_duration\n    without checking ifoutflow_segment_duration== 0\n- No validation thatoutflow_limit outflow_cycle_durationandoutflow_segment_duration\n    are non-zero\n- Missing check thatoutflow_cycle_duration>=outflow_segment_duration\n- No validation thatoutflow_cycle_duration %outflow_segment_duration== 0\n    for proper segment alignment\nDivision by zero causes immediate transaction failure during limiter creation. Zero seg-\nment duration causes division by zero in add_outflow and count_current_outflow. Overall,\ninvalid limiters can prevent normal withdraw/borrow operations.", "recommendation": "Add comprehensive parameter validation to all limiter functions:\n\n- outflow_limit> 0\n- outflow_cycle_duration> 0\n- outflow_segment_duration> 0\n- outflow_cycle_duration%outflow_segment_duration== 0\n    Consider renaming add_limiter to create_limiter since wit_table::add prevents dupli-\ncates, making it a creation operation rather than addition.", "remediation_status": "remediated", "detection_cues": ["add_limiter", "add_outflow", "build_segmentsperformsoutflow_cycle_duration", "count_current_outflow", "create_limiter", "create_limiter_limit_change", "create_limiter_params_change", "ifoutflow_segment_duration", "outflow_cycle_duration", "outflow_cycle_durationandoutflow_segment_duration", "outflow_limit", "outflow_segment_duration", "thatoutflow_cycle_duration", "thatoutflow_limit", "wit_table::add"], "suggested_checks": []}
{"id": "L-2", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Inconsistent Delay Validation", "severity": "low", "issue_tags": ["access_control", "time_validation"], "description": "The admin delay extension functions have inconsistent validation, allowing malicious or com-\npromised admins to permanently freeze protocol governance. While extend_interest_model_change_de-\nlay correctly limits increases to 1 epoch per call, extend_risk_model_change_delay and\nextend_limiter_change_delay have no validation whatsoever, allowing infinite delay values.\nMalicious admin can set risk_model_change_delay = u64::MAX, making future risk\nmodel changes impossible to execute.\nThe current assertion extend_interest_model_change_delay restricts the parameter to\n<= 1, which means only 1 is effectively allowed. As a result, the parameter and check can\nbe considered redundant, since the value is always incremented by 1 regardless.\nAnd even the protected function allows unlimited cumulative delays over time through\nrepeated calls.", "recommendation": "Add the same validation that exists for interest model delays to both risk model and limiter\ndelay functions. This ensures all delay extensions follow the same controlled incremental\napproach.\nConsider removing the delay parameter and its associated assertion, and simply increment\nthe value by 1 instead.\nImplement reasonable upper bounds for total accumulated delays (e.g. 100 limit) to\nprevent indefinite governance lockout while maintaining security through time delays.\nIf infinite delays are intentionally allowed for protocol parameters freezing, create separate\ndedicated functions with clear naming like ”freeze_something” rather than using extension\nfunctions, and add comprehensive documentation explaining the intended behavior.", "remediation_status": "remediated", "detection_cues": ["e.g", "extend_interest_model_change_de", "extend_interest_model_change_delay", "extend_limiter_change_delay", "extend_risk_model_change_delay", "freeze_something", "risk_model_change_delay"], "suggested_checks": []}
{"id": "L-10", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Missing Flash Loan Fee Limit", "severity": "low", "issue_tags": ["access_control", "fee"], "description": "Theset_flash_loan_feefunction lacks upper bound validation, allowing admins to set\nextreme fees that effectively disable flash loans while still appearing functional. Unlike\nupdate_borrow_feewhich properly validatesfee_numerator<=fee_denominator, flash\nloan fees have no bounds checking despite documentation indicating a 0 - 10000 range.", "recommendation": "Apply consistent validation to set_flash_loan_fee to enforce the documented 0-10000 (0-\n100%) range.\nConsider reducing the maximum limits for borrow and/or loan fees.", "remediation_status": "remediated", "detection_cues": ["fee_denominator", "set_flash_loan_fee", "update_borrow_feewhich", "validatesfee_numerator"], "suggested_checks": []}
{"id": "L-8", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "version::assert_current_version", "title": "Force Unlock Function Bypasses Version Control", "severity": "low", "issue_tags": ["upgrade"], "description": "The force_unlock_unhealthy function lacks the version control validation that is present in\nall other user functions.", "recommendation": "Insert version::assert_current_version(version) at the beginning of the function to ensure\nit only operates on the correct protocol version. This requires version: &Version as the\nparameter in the function signature.", "remediation_status": "remediated", "detection_cues": ["assert_current_version", "force_unlock", "force_unlock_unhealthy", "version::assert_current_version"], "suggested_checks": []}
{"id": "L-11", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Decimal Operations Lack Overflow Validation Caus-", "severity": "low", "issue_tags": ["overflow", "upgrade"], "description": "The decimal module performs high-precision calculations onu64values by converting them\ntou256with 18-decimal precision. However, arithmetic operations (add,mul,div,pow) lack\noverflow validation, allowing calculations to succeed even when results exceed the validu64\nrange.\nThe overflow is only detected later duringfloorconversion back tou64, causing transaction\nabort with unclear error context (no info which specific calculation caused the failure).\nThe existing saturating_floor function silently caps results tou64max value, creating incor-\nrect financial calculations without error indication. This would corrupt protocol accounting\nand create unfair user outcomes.", "recommendation": "Add assertions to ensure arithmetic operations results remain within validu64range:\nresult.value<= (u64::max_value asu256) *WAD\nConsider addingmul_div function forDecimalif needed (the protocol currently uses obsolete\nFixedPoint32for complex financial calculations, notDecimal).\nAdditionally improvepowfunction by pre-calculatingpow(from(2), 32) as constant.", "remediation_status": "acknowledged", "detection_cues": ["addingmul_div", "max_value", "result.value", "saturating_floor"], "suggested_checks": []}
{"id": "L-12", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "APM Configuration and Coverage Gaps", "severity": "low", "issue_tags": ["oracle"], "description": "The set_apm_threshold function accepts anyu8value (0-255%) without validation. Setting\nthreshold to 0% would trigger APM on any price increase, effectively blocking all borrowing\noperations.\nAdditionally, APM checks only occur during borrow operations via check_is_collat-\neral_price_fluctuate, leaving withdrawal and other price-sensitive operations unprotected\nagainst manipulation.\nFor instance, max_withdraw_amount also depends on available_borrow_amount_in_usd\n(if there is any debt), which is price-sensitive. So if the price is manipulated, users could\npotentially withdraw more than they deposited", "recommendation": "Add validation for the APM threshold to enforce a minimum allowable limit.\nConsider calling APM checks during withdrawal operations.", "remediation_status": "remediated", "detection_cues": ["available_borrow_amount_in_usd", "check_is_collat", "eral_price_fluctuate", "max_withdraw_amount", "set_apm_threshold"], "suggested_checks": []}
{"id": "L-13", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "APM Data Initialization and Staleness", "severity": "low", "issue_tags": ["access_control", "oracle"], "description": "APM protection is disabled for new assets and after periods of inactivity.\nWhen assets are first listed, APM initializes with empty price history (price: 0,last_update:\n0). The first borrowing operation can use any manipulated price since there’s no historical\ndata for comparison.\nAfter 24+ hours without borrowing activity, all price history becomes stale. Theis_price_fluctuate\nfunction finds no valid data and returns false, disabling APM protection.\nBoth scenarios create predictable vulnerability windows where attackers can manipulate\nprices without APM interference.", "recommendation": "Initialize APM history with the current price instead of zeros. Allow the admin to provide\nthe current price when callingset_apm_thresholdor introduce a dedicated admin function\nto populate the APM price history using the current, legitimate price from the oracle (only\nif history is empty or stale). For newly listed assets, borrowing should only be enabled after\nthe admin initializes the price history to ensure proper APM protection is in place.\nAdditionally, allow the admin to refresh the APM price history during quiet periods.\nThis helps maintain protection by preventing asset history from becoming stale.", "remediation_status": "remediated", "detection_cues": ["callingset_apm_thresholdor", "last_update"], "suggested_checks": []}
{"id": "L-14", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "appliesdecimal::floor", "title": "Precision Loss and Configuration Vulnerabilities", "severity": "low", "issue_tags": ["access_control", "oracle"], "description": "Theget_pricefunction in custom oracle rules for afSUI and haSUI appliesdecimal::floor()\nimmediately after calculating the final price, then performs integer arithmetic for decimal\nformatting. This results in underpricing whenprice_value_with_formatted_decimalsis\ncalculated by multiplying with the decimals.\nAdmin functions lack input validation:\n\n- update_exchange_rate_constraintaccepts any min/max values without checking if\n    min � max or enforcing economic reality (staked assets should be �100% of base asset\n    value)\n- update_oracle_config accepts confidence tolerance of 0%, which would reject all\n    Pyth prices since confidence is never exactly zero\n\nOverall, the afSUI and haSUI implementations use identicaloracle_configandpyth_adaptor\nlogic, with only some differences in their rule logic.", "recommendation": "Perform all price decimal formatting using decimal arithmetic instead of integer operations\nand apply floor only as the final step.\nInupdate_exchange_rate_constraintvalidatemin_exchange_rate_bps<=max_exchange_rate_bps\nand enforce minimum bounds �100%.\nAdd lower bound validation for confidence tolerance (>0) inupdate_oracle_config.\nConsolidate shared logic into common libraries.", "remediation_status": "remediated", "detection_cues": ["appliesdecimal::floor", "identicaloracle_configandpyth_adaptor", "inupdate_oracle_config", "max_exchange_rate_bps", "update_exchange_rate_constraintaccepts", "update_oracle_config", "whenprice_value_with_formatted_decimalsis"], "suggested_checks": []}
{"id": "L-15", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Flash Loan Consumes Entire User Payment With-", "severity": "low", "issue_tags": ["fee"], "description": "The repay_flash_loan function in reserve module takes the entire user coin payment and\ntreats any overpayment as protocol revenue, unlike other repayment functions that return\nexcess funds to users. When users provide more tokens than required (loan_amount + fee),\nthe excess is permanently kept by the protocol instead of being refunded (with no way to\nrecover funds for user).", "recommendation": "Modify repay_flash_loan to split the exact required amount and return excess to the user,\nconsistent with the repay function pattern.\nAlternatively, enforce exact payment by requiring repaid_amount == loan_amount +\nfee to prevent overpayment entirely.", "remediation_status": "remediated", "detection_cues": ["loan_amount", "repaid_amount", "repay_flash_loan"], "suggested_checks": []}
{"id": "A-11", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Error Code Duplication", "severity": "advisory", "issue_tags": [], "description": "The x and math libraries use error codes starting from 0 which can conflict with other\nmodules.\nThe error module contains duplicate flash loan error codes: flash_loan_repay_not_enough_er-\nror and flash_loan_not_paid_enough (never used)\nThere is also unused DIVIDE_BY_ZERO error in math module.", "recommendation": "Remove unused error codes and update x library error codes to start from a unique non-zero\nvalue like it is done for EInvalidPublisher instead of using values from 0 to 3.", "remediation_status": "remediated", "detection_cues": ["flash_loan_not_paid_enough", "flash_loan_repay_not_enough_er"], "suggested_checks": []}
{"id": "A-1", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Validation Gaps in confirm_request", "severity": "advisory", "issue_tags": ["fee", "oracle", "time_validation"], "description": "The oracle system’sconfirm_requestfunction lacks proper validation for empty rule con-\nfigurations and empty price feed vectors. When no rules are configured for a coin type,\nthe system allows empty price update requests to pass validation, only to crash later in\ndetermine_pricewith confusing error messages.\nTheconfirm_requestfunction only validates that the number of receipts matches the\nnumber of configured rules, but doesn’t validate:\n\n- Minimum price feed requirements\n- Empty rule configuration scenarios\n- Primary feed existence", "recommendation": "Add comprehensive validation toconfirm_requestwith specific error codes indicate exact\nproblems. This will ensure all invalid requests fail at validation time, not during price\ndetermination.", "remediation_status": "acknowledged", "detection_cues": ["confirm_request", "determine_pricewith", "sconfirm_requestfunction", "toconfirm_requestwith"], "suggested_checks": []}
{"id": "A-8", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Price Feed Matching Overflow Risk and Hard-", "severity": "advisory", "issue_tags": ["access_control", "fee", "oracle", "overflow", "time_validation"], "description": "The price_feed_match function contains a potential overflow vulnerability and uses hard-\ncoded values for price difference calculations. While overflow is unlikely with current price\nranges, the multiplication value1 * scale could theoretically overflow u64 limits with extreme\nprice values.\nAdditionally, the tolerance parameters are hardcoded, preventing runtime configuration\nadjustments:\n\n- scale = 1000 (precision multiplier)\n- reasonable_diff_percent = 1 (1% tolerance)\n- reasonable_diff = 10 (calculated: 1 * 1000 / 100)", "recommendation": "Replace diff calculation with overflow-safe mul_div function and add named constants for\ntolerance parameters.\nConsider administrative configuration functions for tolerance.", "remediation_status": "acknowledged", "detection_cues": ["mul_div", "price_feed_match", "reasonable_diff", "reasonable_diff_percent"], "suggested_checks": []}
{"id": "A-3", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Code Duplication Across Oracle Modules", "severity": "advisory", "issue_tags": ["oracle", "upgrade"], "description": "The oracle system contains extensive code duplication across multiple rule modules and\nregistry systems. Nearly identical logic is repeated across Pyth, Supra, and Switchboard im-\nplementations, creating maintenance burdens, inconsistent behavior, and potential security\nvulnerabilities when fixes are applied to some modules but not others. Some of duplication\nareas are:\n\n- pyth_rule functions set_price_as_primary and set_price_as_secondary are 99% iden-\n    tical (only differ in final call)\n- Identical decimal conversion logic across Pyth, Supra, and Switchboard\n- switchboard_registry in switchboard_rule and switchboard_on_demand_rule are 100%\n    identical.", "recommendation": "Extract common logic in helper functions/module. For example, the switchboard_on_de-\nmand_rule already demonstrates the correct pattern with its get_switchboard_price helper\nfunction that eliminates primary/secondary duplication.", "remediation_status": "acknowledged", "detection_cues": ["get_switchboard_price", "mand_rule", "pyth_rule", "set_price_as_primary", "set_price_as_secondary", "switchboard_on_de", "switchboard_on_demand_rule", "switchboard_registry", "switchboard_rule"], "suggested_checks": []}
{"id": "A-12", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Unused EMA Prices Field in XOracle", "severity": "advisory", "issue_tags": ["oracle"], "description": "The XOracle struct contains an emapricesf ieldthatiscompletelyunusedthroughouttheentireoraclesystem.\nEMA prices are common in oracle systems for reducing volatility impact, and this field\nsuggests EMA functionality that doesn’t exist.", "recommendation": "Remove the unused field unless EMA functionality is planned for immediate implementation.\nThe current oracle system works without it.\nOr document the intended purpose of this field.", "remediation_status": "acknowledged", "detection_cues": [], "suggested_checks": []}
{"id": "A-5", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "math::fixed_point32_em", "title": "Deprecated Standard Library APIs Usage", "severity": "advisory", "issue_tags": ["gas"], "description": "The codebase extensively uses deprecated Sui standard library APIs, which introduces po-\ntential risks for future compatibility and maintainability.\nFor example:\n\n- The fixed_point32_empower module relies on the deprecated std::fixed_point32 mod-\n    ule and re-implements some missing functionality. However, the entire module is\n    marked as deprecated.\n- The deprecated sui::math module is still being used in the current math libraries.\n- The codebase defines custom constants such as U64_MAX, U128_MAX, and U256_MAX\n    instead of using the built-in functions u64::max_value, u128::max_value, and u256::max_value.\n\nNewer APIs often include additional safety checks and optimizations. Accumulation of\noutdated patterns reduces code quality and developer productivity.", "recommendation": "Replace std::fixed_point32 usage with std::uq32_32, which provides all required functions\nwith better performance and additional safety checks. Consider migrating math::fixed_point32_em-\npower to use a newer type, or replacing it entirely with std::uq32_32.\nReplace sui::math functions (e.g. pow, min) with individual type modules u64, u128 and\nu256.\nReplace custom constant definitions with built-in equivalents.\nAlso consider migration to edition = ”2024.beta”. Move 2024 offers performance im-\nprovements, enhanced safety features, modern language syntax, and better tooling support\nthat could reduce gas costs and improve code maintainability.", "remediation_status": "acknowledged", "detection_cues": ["e.g", "math::fixed_point32_em", "max_value", "std::fixed_point32", "std::uq32_32", "sui::math"], "suggested_checks": []}
{"id": "A-4", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Public Entry Functions Create Dual Restrictions", "severity": "advisory", "issue_tags": ["upgrade"], "description": "The protocol contains a lot of public entry functions that impose both upgradability and\ncomposability restrictions simultaneously. The public entry pattern combines the worst\nlimitations of both modifiers: permanent API lock-in from public and parameter/return\ntype constraints from entry:\n\n- public makes function signatures immutable across upgrades, preventing security en-\n    hancements or parameter additions\n- entry restricts input arguments and requires return types to have drop ability, limiting\n    protocol integration", "recommendation": "Split public entry functions by purpose and:\n\n- Use entry only for upgradable transaction endpoints that don’t need external module\n    access\n- Use public only for composable APIs that other protocols can integrate with\n- Avoid public entry combination unless both restrictions are genuinely required", "remediation_status": "acknowledged", "detection_cues": [], "suggested_checks": []}
{"id": "A-2", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Deprecated Reward System", "severity": "advisory", "issue_tags": ["access_control", "reward", "upgrade"], "description": "Theset_incentive_reward_factorfunction accepts parameters and performs storage op-\nerations for a reward system that is explicitly marked as deprecated and unused. The core\nreward calculation code is commented out with ”@deprecated: this feature is no longer\nused”, yet the configuration function remains active, misleading administrators into believ-\ning they’re configuring functional rewards.\nOverall, the entire supporting infrastructure remains active, including reward factor con-\nfiguration, access key management, and user redemption functions that always return zero\nrewards.", "recommendation": "Replaceset_incentive_reward_factorfunction body with abort and a clear error message\nindicating the reward system is deprecated.\nConsider also makingadd_reward_key,remove_reward_key, andredeem_rewards_point\nfunctions deprecated with abort statements.\nIn the long-term, schedule complete removal of the reward subsystem in the next major\nprotocol upgrade.", "remediation_status": "remediated", "detection_cues": ["add_reward_key", "andredeem_rewards_point", "makingadd_reward_key", "remove_reward_key", "set_incentive_reward_factornow"], "suggested_checks": []}
{"id": "A-13", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "math::pow", "title": "Hardcoded Configuration Values", "severity": "advisory", "issue_tags": ["oracle", "upgrade"], "description": "The codebase contains multiple hardcoded configuration values embedded directly in func-\ntions instead of using named constants. These magic numbers reduce code maintainability,\nmake configuration changes difficult, and create inconsistencies across similar functionality.\nSome examples are:\n\n- Pyth uses hardcoded 30 seconds, while Switchboard and Supra use 60 seconds for price\n    staleness validation\n- Oracle modules use hardcoded values like 10 seconds for future price tolerance\n- 100%-112% exchange rate defaults for afSUI and haSUI custom oracle rules and ha-\n    sui_exchange_rate_scale = 1_000_000\n- Hardcoded 10000 flash loan scale factor in reserve calculations\n- math::pow(10, 9) hardcoded in borrow_dynamics and obligation for initial borrow\n    index values\n- decimal uses hardcoded 100 and 10_000 for percent and bps conversions\n- Hardcoded APM values like 3600 and 24 are used in multiple places\n- Seconds in year calculation inside get_current_borrow_apr", "recommendation": "Replace hardcoded values with descriptive constants at module level.", "remediation_status": "acknowledged", "detection_cues": ["borrow_dynamics", "get_current_borrow_apr", "math::pow", "sui_exchange_rate_scale"], "suggested_checks": []}
{"id": "A-6", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": "Themarket::handle_repay", "title": "Missing Interest Accrual Validation in Market Re-", "severity": "advisory", "issue_tags": ["time_validation"], "description": "Themarket::handle_repay function relies on accrue_all_interests being called immediately\nbefore it but lacks validation to ensure this critical prerequisite is met.\nThe function contains explicit comments and a TODO indicating this dependency, yet\nno runtime check exists to prevent incorrect usage that could lead to inaccurate debt calcu-\nlations.", "recommendation": "Modify handle_repay to include a timestamp parameter and validate that interest has been\naccrued for the asset type by checking last_updated_by_type == now at the function start.", "remediation_status": "remediated", "detection_cues": ["Themarket::handle_repay", "accrue_all_interests", "handle_repay", "last_updated_by_type"], "suggested_checks": []}
{"id": "A-10", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Code Duplication in Obligation Creation", "severity": "advisory", "issue_tags": ["upgrade"], "description": "The open_obligation_entry function duplicates core logic of open_obligation. Both func-\ntions perform identical version checks, obligation creation, and event emission, creating main-\ntenance overhead.", "recommendation": "Create a private create_obligation_internal function containing the shared logic (version\ncheck, obligation creation, event emission) and have both public functions call it with differ-\nent post-processing (immediate sharing vs hot potato return).", "remediation_status": "remediated", "detection_cues": ["create_obligation_internal", "open_obligation", "open_obligation_entry"], "suggested_checks": []}
{"id": "A-9", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Potential Gas DoS Risk from Unbounded Asset", "severity": "advisory", "issue_tags": ["gas"], "description": "Multiple critical protocol functions iterate through all protocol assets or user position assets,\ncreating potential DoS vectors if asset counts grow significantly. Global market functions like\naccrue_all_interestsloop through all protocol assets ( 20 currently), while per-obligation\nfunctions loop through user assets (typically 1-5). If either count grows substantially, gas\nconsumption could exceed transaction limits and disable affected operations.\nGlobal asset loops inaccrue_all_interestsandupdate_interest_rates could disable\nthe entire protocol if gas limits are exceeded, while per-obligation loops in value calculation\nfunctions could lock out users with many positions.\nCurrent risk is manageable but requires proactive monitoring as the protocol grows to prevent\nfuture DoS scenarios.", "recommendation": "Evaluate processable limits for asset counts and enforce them when adding new assets to the\nsystem or a user’s obligation.\nIf the protocol scales beyond these limits in the future, consider implementing more advanced\nand optimized solutions, including grouping, pagination, or batching.\nFor protocol assets, you may use the hot potato pattern to process all assets within a PTB\nacross multiple transactions, if needed.\nOnly implement sophisticated approaches if they’re actually needed, as they will add com-\nplexity to the system.", "remediation_status": "acknowledged", "detection_cues": ["accrue_all_interestsloop", "inaccrue_all_interestsandupdate_interest_rates"], "suggested_checks": []}
{"id": "A-7", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Flash Loan Fee Calculation Lacks Validation", "severity": "advisory", "issue_tags": ["fee", "overflow"], "description": "Theborrow_flash_loan_internalfunction misses validation for fee discount parameters\nthat could cause underflow. While the function is currently called with hardcoded safe\nparameters (0, 1) providing no discount, the lack of validation creates risk for future modi-\nfications or integrations.\nThe base fee calculationamount * fee_ratecould theoretically overflow, though this is\nextremely unlikely given realistic flash loan amounts and fee rates.", "recommendation": "Add discount validationfee_discount_numerator <= fee_discount_denominatorand\nfee_discount_denominator� 0.\nUsemul_divfor base fee calculation to prevent theoretical overflow.", "remediation_status": "remediated", "detection_cues": ["fee_discount_denominator", "fee_discount_denominatorand", "fee_ratecould", "validationfee_discount_numerator"], "suggested_checks": []}
{"id": "A-14", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Generic Error Codes Reduce Clarity", "severity": "advisory", "issue_tags": ["overflow", "time_validation"], "description": "Multiple functions throughout the protocol use generic error codes or rely on runtime panics\ninstead of providing specific, informative error messages. Sometimes relying on panic is\nacceptable when panic is impossible during normal execution. However, the protocol overuses\npanic, even in situations that are both possible and common. This makes debugging difficult\nand provides poor user experience when transactions fail.\nSome examples are:\n\n- Scale parameters validation relies on runtime panics during rational number construc-\n    tion rather than explicit validation\n- Lack of amount validation and failures with unclear balance split errors (like inborrow_flash_loan_internal)\n- Dynamic field access without existence checks, or borrowing fromac_tableandwit_table\n- Relying on underflow during math operation instead of explicit checks\n- Genericinvalid_params_errorused instead of specific validation errors", "recommendation": "Implement comprehensive input validation with specific error codes.", "remediation_status": "acknowledged", "detection_cues": ["fromac_tableandwit_table", "inborrow_flash_loan_internal"], "suggested_checks": []}
{"id": "A-15", "project": "scallop-audit-2025-12-02", "source_file": "scallop-audit-2025-12-02.md", "module_path": null, "function": null, "title": "Zero Amount Operations Execute Successfully", "severity": "advisory", "issue_tags": ["gas", "upgrade"], "description": "Several user-facing functions accept zero amounts or perform operations that have no effect,\nwasting gas and potentially confusing users about transaction outcomes. Functions execute\nsuccessfully but perform no meaningful state changes.\nSome examples are:\n\n- deposit_collateral accepts zero-value coins and processes them without validation\n- mint accepts zero deposit amounts and performs calculations unnecessarily\n- withdraw_collateral accepts zero amounts (though limited by max calculation)\n- switch_to_whitelist_mode/add_whitelist_address/remove_whitelist_address doesn’t\n    check current state, potentially doing nothing", "recommendation": "Add comprehensive input validation and state checks to prevent no-op operations.", "remediation_status": "remediated", "detection_cues": ["add_whitelist_address", "deposit_collateral", "remove_whitelist_address", "switch_to_whitelist_mode", "withdraw_collateral"], "suggested_checks": []}
{"id": "CETUS-HACK-001", "project": "Cetus-Protocol-Hack-2025", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": "addLiquidity/removeLiquidity/swap", "title": "CLMM Tick Account Arithmetic Overflow", "severity": "critical", "issue_tags": ["overflow", "clmm", "tick", "liquidity"], "description": "Cetus Protocol $260M hack. Arithmetic overflow in tick account system miscalculated liquidity withdrawal values. Attacker used spoof tokens with no economic value to manipulate price calculations and drain real tokens with minimal investment.", "recommendation": "1. Use u128 for intermediate liquidity calculations. 2. Validate all token inputs regardless of perceived value. 3. Add explicit overflow checks in tick calculations. 4. Implement minimum liquidity requirements.", "remediation_status": "", "detection_cues": ["addLiquidity", "removeLiquidity", "tick", "liquidity", "swap", "clmm", "concentrated"], "suggested_checks": ["requires((amount as u128) * (liquidity as u128) <= MAX_U128)", "ensures(tick_value >= MIN_TICK && tick_value <= MAX_TICK)"]}
{"id": "NEMO-HACK-001", "project": "Nemo-Protocol-Hack-2025", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Yield Protocol Exploit", "severity": "high", "issue_tags": ["yield", "exploit"], "description": "Nemo yield protocol exploited for $2.4M USDC. Funds bridged to Ethereum via Arbitrum. TVL dropped from $6M to $1.53M.", "recommendation": "Implement proper access controls and validate yield calculations.", "remediation_status": "", "detection_cues": ["yield", "usdc", "bridge"], "suggested_checks": []}
{"id": "MOVE-VM-001", "project": "Move-VM-Vuln-2023", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Infinite Recursion DoS", "severity": "critical", "issue_tags": ["dos", "recursion", "vm"], "description": "Move VM flaw allowed infinite recursive function calls causing stack overflows. Could cause complete blockchain collapse or force hard fork on Sui/Aptos.", "recommendation": "Implement recursion depth limits in VM.", "remediation_status": "fixed", "detection_cues": ["recursion", "recursive", "call"], "suggested_checks": []}
{"id": "MOVE-MEMPOOL-001", "project": "Move-Mempool-Vuln-2024", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Memory Pool DoS", "severity": "high", "issue_tags": ["dos", "mempool", "transaction"], "description": "Inadequate transaction eviction mechanism in memory pool could reject up to 90% of valid transactions. Fixed in Aptos v1.19.1.", "recommendation": "Implement proper transaction eviction policies.", "remediation_status": "fixed", "detection_cues": ["mempool", "transaction", "eviction"], "suggested_checks": []}
{"id": "SLOWMIST-001", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Bitwise Operation Overflow", "severity": "high", "issue_tags": ["overflow", "bitwise"], "description": "Bitwise operations lack overflow checks unlike arithmetic operations. Custom overflow detection may have flawed thresholds causing value truncation.", "recommendation": "Add explicit overflow checks for all bitwise operations. Validate threshold values in custom detection functions.", "remediation_status": "", "detection_cues": ["<<", ">>", "&", "|", "^", "bitwise", "shift"], "suggested_checks": ["requires(value <= MAX_SAFE_VALUE)"]}
{"id": "SLOWMIST-002", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Arithmetic Precision Loss", "severity": "medium", "issue_tags": ["precision", "division", "arithmetic"], "description": "Move lacks floating-point types. Division operations cause precision loss. Fractional values are truncated.", "recommendation": "Use fixed-point math libraries. Multiply before divide. Consider using larger integer types for intermediate calculations.", "remediation_status": "", "detection_cues": ["/", "divide", "ratio", "rate", "percentage"], "suggested_checks": ["ensures(result * denominator <= numerator)"]}
{"id": "SLOWMIST-003", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Transaction Ordering MEV", "severity": "medium", "issue_tags": ["mev", "frontrunning", "ordering"], "description": "Validators can reorder transactions for profit. Function outcomes that depend on execution order are vulnerable to MEV attacks.", "recommendation": "Implement commit-reveal schemes. Use deadline parameters. Add slippage protection.", "remediation_status": "", "detection_cues": ["swap", "trade", "exchange", "price"], "suggested_checks": ["requires(deadline >= current_time)", "requires(amount_out >= min_amount_out)"]}
{"id": "SLOWMIST-004", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Access Control Bypass", "severity": "critical", "issue_tags": ["access_control", "permission", "authorization"], "description": "Internal functions accidentally exposed externally. Missing permission checks allow unauthorized state modifications and asset loss.", "recommendation": "Review all public function visibility. Require capability objects for privileged operations. Use friend modules for internal access.", "remediation_status": "", "detection_cues": ["public fun", "admin", "owner", "set_", "update_", "withdraw", "mint"], "suggested_checks": ["requires(tx_context::sender(ctx) == admin)", "requires(exists<AdminCap>)"]}
{"id": "SLOWMIST-005", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Object Permission Mismanagement", "severity": "high", "issue_tags": ["object", "permission", "shared", "sui"], "description": "Private objects incorrectly converted to shared objects enable unauthorized access. All objects require clear classification and permission verification.", "recommendation": "Clearly classify objects as address-owned, immutable, shared, or wrapped. Verify permissions before state changes.", "remediation_status": "", "detection_cues": ["share_object", "transfer::share", "public_share", "shared"], "suggested_checks": []}
{"id": "SLOWMIST-006", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Token Consumption Errors", "severity": "high", "issue_tags": ["token", "coin", "balance", "resource"], "description": "Sui's token nesting and splitting creates risks. Mishandled transfers, amounts, or object bindings can cause token loss.", "recommendation": "Track all Coin/Balance flows. Ensure proper consumption in all code paths. Use coin::value() to verify amounts.", "remediation_status": "", "detection_cues": ["Coin", "Balance", "coin::split", "coin::join", "into_balance", "from_balance"], "suggested_checks": ["ensures(coin::value(&result) == expected_amount)"]}
{"id": "SLOWMIST-007", "project": "SlowMist-Audit-Primer", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Flashloan Price Manipulation", "severity": "critical", "issue_tags": ["flashloan", "oracle", "price", "manipulation"], "description": "Hot Potato pattern enables borrowing large sums within single transactions. Attackers manipulate prices via protocol algorithm exploitation and oracle dependency.", "recommendation": "Use TWAP oracles. Add price deviation checks. Implement borrowing limits. Validate oracle freshness.", "remediation_status": "", "detection_cues": ["flash", "loan", "borrow", "oracle", "price", "Receipt", "HotPotato"], "suggested_checks": ["requires(price_deviation <= MAX_DEVIATION)", "requires(oracle_timestamp >= current_time - MAX_STALENESS)"]}
{"id": "CTF-001", "project": "lets-ctf", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Generic Type Vulnerability", "severity": "high", "issue_tags": ["generic", "type", "forge"], "description": "Improper generic type constraints allow forging credentials. Attackers can create unauthorized voting tokens by exploiting type system.", "recommendation": "Always validate generic type parameters. Use witness pattern for type authentication. Add phantom type constraints.", "remediation_status": "", "detection_cues": ["<T>", "generic", "phantom", "witness"], "suggested_checks": []}
{"id": "CTF-002", "project": "lets-ctf", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Resource Management Vulnerability", "severity": "high", "issue_tags": ["resource", "leak", "move"], "description": "Improper handling of Move resources leads to resource leak or double-spend. Resources must be properly consumed or transferred in all code paths.", "recommendation": "Ensure all resources are consumed/transferred. Check conditional branches for resource handling. Use drop ability carefully.", "remediation_status": "", "detection_cues": ["Coin", "Balance", "Receipt", "Ticket", "NFT"], "suggested_checks": []}
{"id": "CTF-003", "project": "lets-ctf", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "TxContext Validation Bypass", "severity": "critical", "issue_tags": ["access_control", "txcontext", "sender"], "description": "TxContext validation bypass allows authorization attacks. Sender identity must be properly validated.", "recommendation": "Always validate tx_context::sender(). Use capability objects for authorization. Don't trust user-provided context.", "remediation_status": "", "detection_cues": ["tx_context", "sender", "ctx", "TxContext"], "suggested_checks": ["requires(tx_context::sender(ctx) == authorized_address)"]}
{"id": "CTF-004", "project": "lets-ctf", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "State Transition Inconsistency", "severity": "medium", "issue_tags": ["state", "logic", "transition"], "description": "Inconsistent state transitions create exploitable state machine flaws. Business logic exploits arise from incorrect state management.", "recommendation": "Test all state transition paths. Use enum for state representation. Add state transition guards.", "remediation_status": "", "detection_cues": ["state", "status", "phase", "step"], "suggested_checks": []}
{"id": "CTF-005", "project": "lets-ctf", "source_file": "sui_move_security_research_2024.md", "module_path": null, "function": null, "title": "Cross-Contract Interaction Risk", "severity": "high", "issue_tags": ["cross_contract", "callback", "interaction"], "description": "Insecure contract interactions enable callback manipulation and reentrancy-like issues. All cross-contract calls must be validated.", "recommendation": "Validate all cross-contract call results. Implement checks-effects-interactions pattern. Be cautious with callbacks.", "remediation_status": "", "detection_cues": ["call", "invoke", "callback", "external"], "suggested_checks": []}
{"id": "CETUS-MB-001", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "clmmpool/sources/pool.move", "function": "cross_by_swap", "title": "Function Parameter Order Error", "severity": "critical", "issue_tags": ["parameter", "swap", "logic"], "description": "The parameters of the cross_by_swap function are passed in the wrong order, which can cause the swap result to be wrong.", "recommendation": "Modify to the correct order of parameters.", "remediation_status": "fixed", "detection_cues": ["cross_by_swap", "parameter", "swap"], "suggested_checks": []}
{"id": "CETUS-MB-002", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "integrate/sources/pool.move", "function": "collect_fee_and_rewards", "title": "Recursive Function Causing Infinite Loop", "severity": "major", "issue_tags": ["recursion", "infinite_loop", "gas"], "description": "The function collect_fee_and_rewards calls itself again, resulting in repeated calls to collect_fee. The transaction can never be executed successfully, resulting in gas loss.", "recommendation": "Replace collect_fee_and_rewards in the function with collect_rewards.", "remediation_status": "fixed", "detection_cues": ["collect_fee_and_rewards", "collect_fee", "recursive"], "suggested_checks": []}
{"id": "CETUS-MB-003", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "move-stl/sources/random.move", "function": "seed/seed_rand", "title": "Random Design Flaws - Zero Seed", "severity": "major", "issue_tags": ["random", "seed", "infinite_loop"], "description": "When the parameter seed of the function seed and seed_rand is 0, all random numbers will be 0. Currently used in skip_list, if misused with seed 0, it will lead to an infinite loop.", "recommendation": "The restriction parameter cannot be 0 when initializing the seed and generating random numbers.", "remediation_status": "fixed", "detection_cues": ["seed", "random", "skip_list"], "suggested_checks": ["requires(seed != 0)"]}
{"id": "CETUS-MB-004", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "clmmpool/sources/pool.move", "function": "repay_flash_swap/update_fee_rate", "title": "Pool Operations Without Status Check", "severity": "medium", "issue_tags": ["pool", "status", "pause"], "description": "Some public functions for modifying the pool do not determine whether the current pool is suspended. If the pool is in an emergency and the administrator suspends the pool, some data can still be modified.", "recommendation": "Add assert to verify the state in the pool before operations.", "remediation_status": "fixed", "detection_cues": ["repay_flash_swap", "update_fee_rate", "pause", "pool"], "suggested_checks": ["requires(!pool.is_paused)"]}
{"id": "CETUS-MB-005", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "clmmpool/sources/pool.move", "function": "collect_reward/calculate_and_update_rewards", "title": "Inaccurate Reward and Point Calculation", "severity": "medium", "issue_tags": ["reward", "calculation", "accuracy"], "description": "When executing collect_reward, calculate_and_update_rewards, calculate_and_update_points, rewards are not recalculated except in some special cases. This can lead to inaccurate reward and point calculations.", "recommendation": "Call the settle functions to recalculate the rewards and points for all the branches.", "remediation_status": "fixed", "detection_cues": ["collect_reward", "calculate_and_update_rewards", "calculate_and_update_points"], "suggested_checks": []}
{"id": "CETUS-MB-006", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "clmmpool/sources/tick.move", "function": "borrow_mut_tick_for_swap", "title": "Unused Public Function Security Risk", "severity": "minor", "issue_tags": ["unused", "public", "visibility"], "description": "The method borrow_mut_tick_for_swap exists but is not used anywhere in the entire contract. It is also public, which poses a security risk.", "recommendation": "Remove unused function or modify to private visibility.", "remediation_status": "fixed", "detection_cues": ["borrow_mut_tick_for_swap", "public fun"], "suggested_checks": []}
{"id": "CETUS-MB-007", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "move-stl/sources/list.move", "function": "push_back/insert", "title": "List Structure Design Flaws - Duplicate Key", "severity": "minor", "issue_tags": ["list", "dynamic_field", "duplicate"], "description": "The list data structure uses dynamic_field in Sui to store nodes. dynamic_field cannot have multiple key-value pairs with the same key. When the same key is inserted, an error will be reported.", "recommendation": "Determine whether key exists before push_back and insert operations.", "remediation_status": "fixed", "detection_cues": ["list", "push_back", "insert", "dynamic_field"], "suggested_checks": []}
{"id": "CETUS-MB-008", "project": "Cetus-CLMM-MoveBit", "source_file": "cetus_sui_movebit.pdf", "module_path": "clmmpool/sources/partner.move", "function": "create_partner", "title": "Time Parameter Validation Missing", "severity": "minor", "issue_tags": ["time", "validation", "parameter"], "description": "The start_time created and updated by create_partner may be smaller than the current time, and should be greater than or equal to the current time.", "recommendation": "Refactor the time check asserts to validate start_time >= current_time.", "remediation_status": "fixed", "detection_cues": ["start_time", "create_partner", "time"], "suggested_checks": ["requires(start_time >= tx_context::epoch(ctx))"]}
{"id": "CETUS-OS-001", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "pool.move", "function": "add_liquidity_internal", "title": "Position Confusion in Add Liquidity - Cross-Pool Position Reuse", "severity": "high", "issue_tags": ["clmm", "position", "cross_pool", "liquidity"], "description": "add_liquidity_internal does not check if the provided Position<CoinA, CoinB> belongs to the same Pool<CoinA, CoinB> as the one passed as an argument. Therefore, it is possible to pass a position from a pool created for the same pair of coins but with a different tick_spacing. An attacker can open a position in pool0 with tick_spacing=50, then use that same position to add liquidity to pool1 with tick_spacing=20, potentially manipulating liquidity accounting across pools.", "recommendation": "Ensure that add_liquidity_internal validates that the Position<CoinA, CoinB> passed as an argument was created for the Pool<CoinA, CoinB> provided to the function. Add pool_id field to Position struct and verify position.pool_id == object::id(pool) before processing.", "remediation_status": "resolved", "detection_cues": ["add_liquidity", "Position<", "Pool<", "tick_spacing", "position", "liquidity"], "suggested_checks": ["requires(position.pool_id == object::id(pool))", "ensures(position belongs to correct pool)"]}
{"id": "CETUS-OS-002", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "rewarder.move", "function": "update_emission", "title": "Balance Validation Bypass via Zero Emission Per Day", "severity": "medium", "issue_tags": ["rewarder", "validation_bypass", "balance_check"], "description": "update_emission calculates emission_per_day with emission_per_second. Passing emission_per_second <= (1 << 64)/DAYS_IN_SECONDS results in emission_per_day being equal to zero. Therefore, it is possible to bypass the assert statement that checks rewarder_balance >= emission_per_day even if the balance is zero. This leads to emission_per_second being used to calculate rewards for CoinType with zero balance, which eventually causes ENotEnough error when users try to claim.", "recommendation": "Tighten balance validation to prevent bypassing the assert statement when emission_per_day equals zero. Add check: assert!(emission_per_second == 0 || emission_per_day > 0, EInvalidEmission)", "remediation_status": "resolved", "detection_cues": ["update_emission", "emission_per_second", "emission_per_day", "DAYS_IN_SECONDS", "rewarder_balance", "ENotEnough"], "suggested_checks": ["requires(emission_per_second == 0 || calculated_daily > 0)", "requires(vault_balance >= minimum_daily_emission)"]}
{"id": "CETUS-OS-003", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "tick.move", "function": "fetch_ticks", "title": "Incorrect Tick Cast Function - Negative Index Handling", "severity": "informational", "issue_tags": ["tick", "type_casting", "signed_integer"], "description": "fetch_ticks is currently utilizing i32::from to convert u32 into I32. However, i32::from does not allow for values greater than U32_MAX, and therefore, cannot generate negative values from the conversion. This prevents proper handling of negative tick indexes which are common in CLMM pools.", "recommendation": "Utilize i32::from_u32 instead of i32::from to properly handle negative tick indexes in the two's complement representation.", "remediation_status": "resolved", "detection_cues": ["fetch_ticks", "i32::from", "tick_score", "from_u32", "negative tick"], "suggested_checks": ["requires(tick_index >= MIN_TICK && tick_index <= MAX_TICK)"]}
{"id": "CETUS-OS-004", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "pool.move", "function": "flash_swap_with_partner", "title": "Missing Pause Check in Flash Swap With Partner", "severity": "informational", "issue_tags": ["flash_swap", "pause", "access_control"], "description": "The assert!(!pool.is_pause, EPoolIsPaused) check was added to flash_swap. A similar check should be added to flash_swap_with_partner to ensure consistent pool pause enforcement across all swap variants.", "recommendation": "Add assert!(!pool.is_pause, EPoolIsPaused) line at the beginning of flash_swap_with_partner as it was executed for flash_swap.", "remediation_status": "acknowledged", "detection_cues": ["flash_swap_with_partner", "flash_swap", "is_pause", "EPoolIsPaused"], "suggested_checks": ["requires(!pool.is_pause)"]}
{"id": "CETUS-OS-005", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "rewarder.move", "function": "deposit_reward", "title": "Arbitrary Coin Type Deposit - Locked Funds Risk", "severity": "informational", "issue_tags": ["rewarder", "coin_type", "locked_funds"], "description": "deposit_reward allows any type of coin to be deposited in RewarderGlobalVault. However, it is impossible for the coins to exit the vault unassisted, as they have been locked within, and the vault may be filled with coins of any arbitrary type that cannot be properly distributed.", "recommendation": "Either restrict deposit_reward to only accept registered reward token types, or provide emergent_withdraw admin function to permit withdrawal of stuck funds.", "remediation_status": "acknowledged", "detection_cues": ["deposit_reward", "RewarderGlobalVault", "Balance<", "bag::contains"], "suggested_checks": ["requires(is_registered_reward_type<CoinType>(manager))"]}
{"id": "CETUS-OS-006", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "clmm_math.move", "function": "compute_swap_step", "title": "Potential Arithmetic Overflow in U256 to U64 Cast", "severity": "informational", "issue_tags": ["overflow", "type_casting", "swap"], "description": "In compute_swap_step, get_delta_down_from_output and get_delta_up_from_input return values of type u256, which are then cast to u64. If they exceed MAX_U64, arithmetic errors may occur, potentially causing unexpected swap behavior or transaction failures.", "recommendation": "Check if the return values exceed MAX_U64 before casting, and handle the overflow case appropriately with proper error handling.", "remediation_status": "acknowledged", "detection_cues": ["compute_swap_step", "get_delta_down_from_output", "get_delta_up_from_input", "u256", "as u64", "MAX_U64"], "suggested_checks": ["requires(delta_amount <= MAX_U64)", "ensures(result fits in u64)"]}
{"id": "CETUS-OS-007", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "pool.move", "function": "swap", "title": "Zero Amount Swap Allows Price Manipulation", "severity": "informational", "issue_tags": ["swap", "zero_amount", "price_manipulation"], "description": "Performing a swap operation that sets either amount_in or amount_out to zero can lead to the swap operation being executed in the pool with zero liquidity, allowing the current_sqrt_price to be set to a semi-arbitrary value. This can be exploited to manipulate price before a victim's swap.", "recommendation": "Abort the execution if either amount_in or amount_out is zero. Add validation: assert!(amount > 0, EZeroAmount)", "remediation_status": "resolved", "detection_cues": ["swap", "amount_in", "amount_out", "current_sqrt_price", "zero liquidity"], "suggested_checks": ["requires(amount_in > 0 || amount_out > 0)", "ensures(actual_amount_swapped > 0)"]}
{"id": "CETUS-OS-008", "project": "Cetus-OtterSec", "source_file": "cetus_sui_ottersec.pdf", "module_path": "various", "function": "getter functions", "title": "Missing Version Checks in Getter Functions", "severity": "informational", "issue_tags": ["version", "upgrade", "getter"], "description": "checked_package_version is employed to ensure that the latest contract version is being invoked. However, this protection mechanism is not utilized by all functions. In the case of getter functions that may return objects, it would be prudent to call checked_package_version for added safety during contract upgrades.", "recommendation": "Add a checked_package_version function call to getter functions that return mutable references or objects.", "remediation_status": "acknowledged", "detection_cues": ["checked_package_version", "getter", "public fun", "return"], "suggested_checks": ["requires(version == current_package_version)"]}
{"id": "CETUS-ZL-001", "project": "Cetus-Zellic", "source_file": "cetus_zellic.pdf", "module_path": "partner.move", "function": "receive_ref_fee", "title": "Missing Friend Modifier on Fee Receiver", "severity": "informational", "issue_tags": ["access_control", "friend", "fee"], "description": "During swap or flash-loan operations, authorized partners can use the flash_swap_with_partner or flash_loan_with_partner functions to collect fees. The pool module invokes the receive_ref_fee function to transfer fees to the partner. However, the receive_ref_fee function lacks a friend modifier, allowing anyone to call it and deposit arbitrary amounts into partner fee balances.", "recommendation": "Add a friend modifier to the receive_ref_fee function to restrict access to only the pool module.", "remediation_status": "acknowledged", "detection_cues": ["receive_ref_fee", "public fun", "partner", "Balance<", "fee"], "suggested_checks": ["requires(caller is friend module)"]}
{"id": "CETUS-ZL-002", "project": "Cetus-Zellic", "source_file": "cetus_zellic.pdf", "module_path": "integrate/pool.move", "function": "create_pool_with_liquidity_*", "title": "Redundant Deprecated Functions Still Accessible", "severity": "informational", "issue_tags": ["deprecated", "redundant", "maintenance"], "description": "The create_pool_with_liquidity function in the factory module appears to be deprecated. Yet the following functions in integrate/pool.move still depend on it: create_pool_with_liquidity_with_all, create_pool_with_liquidity_only_a, create_pool_with_liquidity_only_b. These unnecessary functions could cause confusion when interacting with the pool module.", "recommendation": "Remove the redundant functions or mark them as deprecated with clear documentation.", "remediation_status": "acknowledged", "detection_cues": ["create_pool_with_liquidity", "deprecated", "integrate/pool.move"], "suggested_checks": []}
{"id": "CETUS-ZL-003", "project": "Cetus-Zellic", "source_file": "cetus_zellic.pdf", "module_path": "position.move", "function": "init", "title": "TypeName Display Escape Characters Issue", "severity": "informational", "issue_tags": ["display", "nft", "typename"], "description": "When creating a position NFT, a display object is also created. The code uses property syntax to access coin_type_[a/b]. The coin_type_[a/b] fields are defined as a TypeName rather than as a string. When querying objects with the showDisplay option, TypeName values appear with escape characters, causing poor user experience.", "recommendation": "Use the string type for coin_type_a and coin_type_b in the Position struct and display values.", "remediation_status": "acknowledged", "detection_cues": ["Position", "display", "coin_type_a", "coin_type_b", "TypeName"], "suggested_checks": []}
{"id": "SUI-VULN-OVERFLOW-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Integer Multiplication Overflow", "severity": "critical", "issue_tags": ["overflow", "arithmetic", "multiplication"], "description": "When multiplying two u64 values, the result may exceed u64 MAX (18446744073709551615), causing silent wraparound or abort. Common in: share calculations (amount * total_shares / total_supply), fee calculations (amount * fee_rate), price calculations (amount * price). Attack vector: Attacker provides large input values to trigger overflow, potentially receiving more tokens than entitled or paying less fees.", "recommendation": "Cast operands to u128 before multiplication: let result = ((a as u128) * (b as u128)) as u64. Use checked_mul libraries. Validate intermediate results don't exceed bounds.", "remediation_status": "", "detection_cues": ["*", "amount * ", "shares *", "price *", "rate *", "u64", "multiplication"], "suggested_checks": ["requires((a as u128) * (b as u128) <= MAX_U64)", "ensures(result == (a as u128) * (b as u128) / divisor)"]}
{"id": "SUI-VULN-OVERFLOW-002", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Addition Overflow in Accumulator Updates", "severity": "high", "issue_tags": ["overflow", "arithmetic", "addition", "accumulator"], "description": "Cumulative values like total_supply, total_shares, fee_growth, reward_growth can overflow when continuously incremented. In CLMM protocols, fee_growth_global values use u128 but can still overflow over long periods. Attack: Repeatedly perform operations to push accumulator near MAX, then exploit the wraparound.", "recommendation": "Use saturating addition or check for overflow before updating: assert!(accumulator <= MAX - delta, EOverflow). Consider periodic resets with proper accounting.", "remediation_status": "", "detection_cues": ["total_", "growth_", "accumulated", "+ =", "+="], "suggested_checks": ["requires(current + delta <= MAX_VALUE)", "ensures(new_value >= old_value)"]}
{"id": "SUI-VULN-PRECISION-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Division Precision Loss - Rounding Exploitation", "severity": "high", "issue_tags": ["precision", "arithmetic", "division", "rounding"], "description": "Move lacks floating-point types, so division truncates. Attackers can exploit rounding direction: deposit small amounts where shares = amount * total_shares / total_supply rounds down to 0, effectively donating tokens. Or withdraw where amount = shares * total_supply / total_shares rounds up. First depositor attack: deposit 1 wei, donate large amount, subsequent depositors get 0 shares.", "recommendation": "Multiply before divide. Use rounding functions appropriate for context (round_up for protocol's benefit). Implement minimum deposit/share requirements. For vaults, use virtual shares offset.", "remediation_status": "", "detection_cues": ["/", "/ total", "precision", "shares", "amount / ", "division"], "suggested_checks": ["requires(amount >= MIN_DEPOSIT)", "requires(shares >= MIN_SHARES)", "ensures(depositor receives fair shares)"]}
{"id": "SUI-VULN-ACCESS-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Missing Capability Check - Unauthorized Admin Access", "severity": "critical", "issue_tags": ["access_control", "capability", "admin", "authorization"], "description": "Functions that should require AdminCap or similar capability objects are declared public without the capability parameter. Attack: Anyone can call privileged functions like withdraw_all, set_fee_rate, pause, upgrade. Pattern: public fun admin_function(obj: &mut Object) should be public fun admin_function(obj: &mut Object, _: &AdminCap)", "recommendation": "Add capability parameter to all admin functions. Use pattern: public fun admin_action<T>(_: &AdminCap, ...). Consider multi-sig for critical operations.", "remediation_status": "", "detection_cues": ["withdraw", "set_", "update_", "pause", "unpause", "emergency", "admin", "owner", "public fun"], "suggested_checks": ["requires(caller has AdminCap)", "requires(tx_context::sender(ctx) == owner)"]}
{"id": "SUI-VULN-ACCESS-002", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "TxContext Sender Validation Bypass", "severity": "high", "issue_tags": ["access_control", "sender", "identity", "authorization"], "description": "Using tx_context::sender(ctx) for authorization without proper validation. In Sui, sender can be spoofed in certain PTB (Programmable Transaction Block) scenarios. Attack: Construct PTB that manipulates perceived sender. Pattern: Relying solely on sender == stored_owner without additional checks.", "recommendation": "Use capability objects instead of sender checks where possible. If sender check needed, combine with object ownership verification. Use owned objects for user-specific data.", "remediation_status": "", "detection_cues": ["tx_context::sender", "ctx", "sender ==", "owner", "assert!"], "suggested_checks": ["requires(object::owner(obj) == tx_context::sender(ctx))", "requires(has_capability(sender))"]}
{"id": "SUI-VULN-RESOURCE-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Resource Leak - Unhandled Return Path", "severity": "critical", "issue_tags": ["resource", "leak", "coin", "linear_type"], "description": "Move's linear type system requires all resources to be explicitly consumed. If a function returns early without handling a resource (Coin, Balance, etc.), the transaction aborts. But design flaws can cause resources to be stuck in contract. Attack: Trigger error path that leaves resources in limbo. Pattern: if (condition) { return } // coin leaked!", "recommendation": "Ensure all code paths handle resources. Use pattern: if (condition) { transfer::public_transfer(coin, sender); return }. Audit all early returns.", "remediation_status": "", "detection_cues": ["Coin<", "Balance<", "return", "if (", "abort", "assert!"], "suggested_checks": ["ensures(all resources transferred or destroyed)", "ensures(no resource leak on any path)"]}
{"id": "SUI-VULN-RESOURCE-002", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Double Spend via Object Reference Manipulation", "severity": "critical", "issue_tags": ["resource", "double_spend", "object", "reference"], "description": "In Sui's object model, improper handling of object references can lead to double-spend-like issues. Pattern: Store object ID, delete object, recreate with same properties. Or: Use shared object in multiple concurrent transactions before state update. Attack: Race condition on shared object state.", "recommendation": "Use owned objects for user funds. Implement proper locking mechanisms for shared objects. Use receipts/hot-potato pattern for atomic operations.", "remediation_status": "", "detection_cues": ["object::id", "shared_object", "public_share_object", "borrow_mut", "concurrent"], "suggested_checks": ["requires(object exists and is valid)", "ensures(object state updated atomically)"]}
{"id": "SUI-VULN-FLASHLOAN-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Flash Loan Price Manipulation", "severity": "critical", "issue_tags": ["flash_loan", "price_manipulation", "oracle", "defi"], "description": "Flash loans enable borrowing large amounts within single transaction. Attack pattern: 1) Flash borrow large amount, 2) Manipulate on-chain price oracle (swap to move price), 3) Exploit protocol using manipulated price (liquidate, arbitrage), 4) Reverse swap, 5) Repay flash loan with profit. Sui's Hot Potato pattern enables this.", "recommendation": "Use time-weighted average price (TWAP) oracles. Implement price deviation checks. Add cooldown periods between price-sensitive operations. Use multiple oracle sources.", "remediation_status": "", "detection_cues": ["flash_loan", "FlashReceipt", "hot_potato", "oracle", "price", "get_price", "swap"], "suggested_checks": ["requires(price within acceptable deviation)", "requires(oracle freshness < MAX_STALENESS)"]}
{"id": "SUI-VULN-FLASHLOAN-002", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Flash Loan Fee Bypass", "severity": "high", "issue_tags": ["flash_loan", "fee", "bypass", "repayment"], "description": "Flash loan implementations must enforce fee payment on repayment. Attack: Repay exact borrowed amount without fee, or manipulate fee calculation. Pattern: repay_flash_loan checks amount >= borrowed but not amount >= borrowed + fee. Or fee calculated incorrectly.", "recommendation": "Strictly enforce: assert!(repaid_amount >= borrowed_amount + fee, EInsufficientRepayment). Calculate fee before lending. Store fee in receipt struct.", "remediation_status": "", "detection_cues": ["repay", "flash", "fee", "borrowed", "Receipt", ">="], "suggested_checks": ["requires(repaid >= borrowed + fee)", "ensures(protocol receives fee)"]}
{"id": "SUI-VULN-CLMM-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "CLMM Tick Manipulation - Liquidity Accounting Error", "severity": "critical", "issue_tags": ["clmm", "tick", "liquidity", "accounting"], "description": "Concentrated Liquidity Market Makers track liquidity at discrete tick boundaries. Errors in tick crossing logic can cause liquidity miscounting. Attack (Cetus $260M hack pattern): Manipulate tick account overflow to receive more liquidity credit than deposited. Pattern: liquidity_net overflow, incorrect tick initialization, missing boundary checks.", "recommendation": "Use u128 for liquidity calculations. Validate tick boundaries exhaustively. Audit tick crossing in both directions. Implement invariant checks: sum of all position liquidity == pool liquidity when price in range.", "remediation_status": "", "detection_cues": ["tick", "liquidity", "cross", "add_liquidity", "remove_liquidity", "tick_lower", "tick_upper", "liquidity_net"], "suggested_checks": ["requires(tick_lower < tick_upper)", "requires(tick aligned to tick_spacing)", "ensures(liquidity accounting balanced)"]}
{"id": "SUI-VULN-CLMM-002", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "CLMM Position Cross-Pool Confusion", "severity": "high", "issue_tags": ["clmm", "position", "pool", "validation"], "description": "Position NFTs must be bound to specific pools. If validation is missing, attacker can use position from Pool A in Pool B (same token pair, different tick_spacing). This corrupts liquidity accounting across pools. Attack: Open position in low-liquidity pool, use in high-liquidity pool to extract funds.", "recommendation": "Store pool_id in Position struct. Validate position.pool_id == object::id(pool) in all position operations. Use type parameters to bind position to specific pool if possible.", "remediation_status": "", "detection_cues": ["Position<", "Pool<", "pool_id", "add_liquidity", "remove_liquidity", "tick_spacing"], "suggested_checks": ["requires(position.pool_id == object::id(pool))", "ensures(position bound to correct pool)"]}
{"id": "SUI-VULN-SLIPPAGE-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Missing Slippage Protection in Swap", "severity": "high", "issue_tags": ["slippage", "swap", "mev", "sandwich"], "description": "Swap functions without minimum output amount parameter expose users to sandwich attacks. Attack pattern: 1) Attacker sees pending swap in mempool, 2) Front-run with large swap moving price against user, 3) User's swap executes at worse price, 4) Attacker back-runs to capture profit. Pattern: swap(amount_in) without min_amount_out parameter.", "recommendation": "Add min_amount_out parameter: public fun swap(..., min_amount_out: u64). Assert: assert!(actual_out >= min_amount_out, ESlippage). Consider price limit parameter for CLMM swaps.", "remediation_status": "", "detection_cues": ["swap", "amount_in", "amount_out", "min_", "slippage"], "suggested_checks": ["requires(min_amount_out > 0)", "ensures(actual_output >= min_amount_out)"]}
{"id": "SUI-VULN-REENTRANCY-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Callback Manipulation via External Module Calls", "severity": "high", "issue_tags": ["reentrancy", "callback", "cross_module", "state"], "description": "While Move doesn't have traditional reentrancy, similar issues arise with cross-module calls and callbacks. If state is read, external call made, then state updated, the external call could manipulate intermediate state. Pattern similar to check-effect-interaction. Attack: External module called between check and update modifies shared state.", "recommendation": "Follow check-effects-interactions pattern. Update state before external calls. Use receipts to enforce atomic completion. Avoid reading shared state after external calls.", "remediation_status": "", "detection_cues": ["public fun", "external::", "callback", "shared", "borrow_mut"], "suggested_checks": ["requires(state updated before external call)", "ensures(operation atomic)"]}
{"id": "SUI-VULN-GENERIC-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Generic Type Parameter Confusion", "severity": "high", "issue_tags": ["generic", "type_parameter", "type_safety"], "description": "Functions with generic type parameters can be called with unexpected types. Attack: If function expects Coin<USDC> but accepts generic Coin<T>, attacker can pass worthless Coin<FAKE>. Pattern: Voting with forged credentials by exploiting generic type acceptance.", "recommendation": "Use specific types where possible. If generics needed, validate type at runtime with type_name checks. Use witness pattern for type authentication.", "remediation_status": "", "detection_cues": ["<T>", "<CoinType>", "generic", "type_name", "Coin<"], "suggested_checks": ["requires(type_name::get<T>() == expected_type)", "ensures(correct type used)"]}
{"id": "SUI-VULN-UPGRADE-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Package Upgrade Version Mismatch", "severity": "medium", "issue_tags": ["upgrade", "version", "migration", "compatibility"], "description": "After package upgrade, old function implementations may be called if version checks missing. Attack: Call deprecated function that has different (vulnerable) logic. Pattern: Missing checked_package_version at function start. Init functions only run on first deployment, not upgrades.", "recommendation": "Add version check to all public functions: checked_package_version(config). Implement proper migration logic. Use versioned structs.", "remediation_status": "", "detection_cues": ["checked_package_version", "version", "upgrade", "init", "CURRENT_VERSION"], "suggested_checks": ["requires(package_version == CURRENT_VERSION)", "ensures(using latest implementation)"]}
{"id": "SUI-VULN-DOS-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Denial of Service via Unbounded Loop", "severity": "high", "issue_tags": ["dos", "loop", "gas", "unbounded"], "description": "Functions with unbounded loops can exceed gas limits, causing transaction failure. Attack: Grow vector/table to size where iteration exceeds gas. Infinite recursion. Pattern: while loop on user-controlled data structure size.", "recommendation": "Implement pagination with limit parameter. Use bounded data structures. Avoid recursive calls. Add gas checks in loops.", "remediation_status": "", "detection_cues": ["while", "loop", "vector::length", "for", "recursive"], "suggested_checks": ["requires(iteration_count <= MAX_ITERATIONS)", "ensures(bounded gas consumption)"]}
{"id": "SUI-VULN-RANDOM-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Weak Randomness Source", "severity": "critical", "issue_tags": ["randomness", "predictable", "gambling", "nft"], "description": "Using predictable values for randomness (block timestamp, transaction hash, sender address) allows attackers to predict or manipulate outcomes. Attack: For NFT mints, attacker predicts rare outcomes. For games, attacker only plays winning rounds. Pattern: let random = timestamp % range.", "recommendation": "Use Sui's native randomness (sui::random module when available). Use commit-reveal scheme. Use VRF from trusted oracle. Never use solely on-chain data for randomness.", "remediation_status": "", "detection_cues": ["random", "seed", "timestamp", "block", "hash", "%", "mod"], "suggested_checks": ["requires(randomness from secure source)", "ensures(outcome unpredictable)"]}
{"id": "SUI-VULN-ORACLE-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Stale Oracle Price Data", "severity": "high", "issue_tags": ["oracle", "price", "stale", "timestamp"], "description": "Using oracle prices without checking freshness allows exploitation with outdated data. Attack: Oracle stops updating, attacker exploits stale price that differs significantly from market. Pattern: get_price(oracle) without timestamp validation.", "recommendation": "Check oracle timestamp: assert!(clock::timestamp_ms(clock) - oracle.last_update < MAX_STALENESS). Use multiple oracles. Implement circuit breakers for large price deviations.", "remediation_status": "", "detection_cues": ["oracle", "price", "get_price", "timestamp", "last_update", "stale"], "suggested_checks": ["requires(price_timestamp > current_time - MAX_STALENESS)", "requires(price within deviation bounds)"]}
{"id": "SUI-VULN-OBJECT-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Improper Object Visibility - Private Object Made Shared", "severity": "high", "issue_tags": ["object", "visibility", "shared", "owned", "access_control"], "description": "Sui objects can be owned (single owner), shared (anyone can access), or immutable. Making sensitive objects shared when they should be owned exposes them to manipulation. Attack: Shared admin config allows anyone to modify settings. Pattern: transfer::share_object on sensitive data.", "recommendation": "Use owned objects for user-specific data. Use shared objects only when concurrent access needed. Implement proper access control on shared objects. Consider immutable for constants.", "remediation_status": "", "detection_cues": ["share_object", "public_share_object", "shared", "transfer::"], "suggested_checks": ["requires(object visibility appropriate for use case)", "ensures(sensitive data not publicly shared)"]}
{"id": "SUI-VULN-TIME-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Timestamp Manipulation in Time-Locked Operations", "severity": "medium", "issue_tags": ["timestamp", "time", "lock", "vesting"], "description": "Sui clock can have slight variations. Time-sensitive operations (vesting, auctions, locks) may be exploitable at boundaries. Attack: Exploit transaction ordering around unlock time. Pattern: if (timestamp >= unlock_time) without buffer.", "recommendation": "Use block-based timing where possible. Add buffer periods for critical transitions. Consider validator timestamp variations. Use >= and <= consistently.", "remediation_status": "", "detection_cues": ["clock", "timestamp", "time", "unlock", "vesting", "auction", "deadline"], "suggested_checks": ["requires(current_time within acceptable range)", "ensures(time check consistent)"]}
{"id": "SUI-VULN-INIT-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Unprotected Initialization Function", "severity": "critical", "issue_tags": ["initialization", "admin", "one_time_witness"], "description": "Init functions should only run once at deployment. If initialization logic in separate public function without one-time protection, attacker can re-initialize. Pattern: public fun initialize() without one-time witness check.", "recommendation": "Use init(witness: WITNESS, ctx: &mut TxContext) pattern with one-time witness. Store initialized flag in singleton object. Check flag before initialization logic.", "remediation_status": "", "detection_cues": ["init", "initialize", "setup", "one_time_witness", "OTW"], "suggested_checks": ["requires(not already initialized)", "ensures(initialization only once)"]}
{"id": "SUI-VULN-FEE-001", "project": "Sui-Move-Vulnerability-Taxonomy", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Fee Calculation Manipulation", "severity": "medium", "issue_tags": ["fee", "calculation", "manipulation", "protocol"], "description": "Fee calculations can be manipulated through: rounding exploitation, fee rate changes between check and execution, fee denominator manipulation. Attack: Split large transaction into many small ones where fees round down to 0. Pattern: fee = amount * rate / DENOMINATOR where small amounts yield 0 fee.", "recommendation": "Implement minimum fee. Round fees up (in protocol's favor). Use basis points with sufficient precision. Validate fee parameters have reasonable bounds.", "remediation_status": "", "detection_cues": ["fee", "rate", "DENOMINATOR", "BASIS_POINTS", "calculate_fee"], "suggested_checks": ["requires(fee >= MIN_FEE)", "requires(fee_rate <= MAX_FEE_RATE)", "ensures(protocol receives expected fee)"]}
{"id": "SUI-CHAIN-001", "project": "Sui-Move-Exploitation-Chains", "source_file": "taxonomy", "module_path": null, "function": null, "title": "First Depositor Attack Chain - Vault Share Inflation", "severity": "critical", "issue_tags": ["vault", "shares", "first_depositor", "inflation", "defi"], "description": "EXPLOITATION CHAIN: 1) Attacker is first to deposit to empty vault, deposits minimal amount (1 wei), receives 1 share. 2) Attacker directly transfers large amount of underlying tokens to vault (donation). 3) Vault now has shares=1, assets=large_amount. 4) Victim deposits amount, receives shares = amount * 1 / large_amount = 0 due to rounding. 5) Attacker withdraws their 1 share, receiving all assets including victim's deposit. DETECTION: Check if total_shares == 0 before deposit, verify share calculation doesn't round to 0.", "recommendation": "Implement virtual shares offset: shares = amount * (total_shares + OFFSET) / (total_assets + OFFSET). Or require minimum initial deposit. Or mint dead shares to zero address on first deposit.", "remediation_status": "", "detection_cues": ["vault", "deposit", "shares", "total_supply", "total_assets", "first"], "suggested_checks": ["requires(calculated_shares > 0)", "requires(total_shares >= MIN_SHARES after deposit)", "ensures(depositor receives proportional shares)"]}
{"id": "SUI-CHAIN-002", "project": "Sui-Move-Exploitation-Chains", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Sandwich Attack Chain - MEV Exploitation", "severity": "high", "issue_tags": ["mev", "sandwich", "frontrun", "backrun", "swap"], "description": "EXPLOITATION CHAIN: 1) Attacker monitors mempool for large pending swap (User wants to swap A->B). 2) Attacker front-runs: swaps A->B, moving price against user. 3) User's swap executes at worse price (receives less B than expected). 4) Attacker back-runs: swaps B->A at the now-favorable price. 5) Net result: Attacker profits from price difference, user loses. DETECTION: Large swaps without slippage protection, predictable swap patterns.", "recommendation": "Require min_amount_out parameter. Implement private mempool submission. Use batch auctions. Consider Flashbots-style protection.", "remediation_status": "", "detection_cues": ["swap", "amount_out", "min_amount", "price", "slippage"], "suggested_checks": ["requires(min_amount_out specified)", "requires(actual_out >= min_amount_out)", "ensures(user protected from price manipulation)"]}
{"id": "SUI-CHAIN-003", "project": "Sui-Move-Exploitation-Chains", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Oracle Manipulation Attack Chain", "severity": "critical", "issue_tags": ["oracle", "manipulation", "flash_loan", "liquidation", "defi"], "description": "EXPLOITATION CHAIN: 1) Attacker takes flash loan of large amount. 2) Uses borrowed funds to manipulate on-chain oracle (e.g., Uniswap spot price via large swap). 3) Triggers protocol action using manipulated price: a) Liquidate healthy positions at artificial price, b) Borrow more than collateral worth, c) Mint tokens at wrong rate. 4) Reverses oracle manipulation trade. 5) Repays flash loan with profit. DETECTION: Single-block price movements, spot price reliance, no TWAP.", "recommendation": "Use TWAP (Time-Weighted Average Price). Implement price deviation circuit breakers. Use multiple oracle sources. Add manipulation-resistant delay.", "remediation_status": "", "detection_cues": ["oracle", "get_price", "spot_price", "liquidate", "collateral", "borrow"], "suggested_checks": ["requires(price from TWAP oracle)", "requires(price deviation < MAX_DEVIATION)", "ensures(price manipulation resistant)"]}
{"id": "SUI-CHAIN-004", "project": "Sui-Move-Exploitation-Chains", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Governance Attack Chain - Flash Loan Voting", "severity": "high", "issue_tags": ["governance", "voting", "flash_loan", "quorum"], "description": "EXPLOITATION CHAIN: 1) Attacker creates malicious proposal (e.g., drain treasury). 2) Flash borrows large amount of governance tokens. 3) Votes on proposal with borrowed tokens, exceeding quorum. 4) Proposal passes and executes in same transaction (if no timelock). 5) Returns borrowed tokens. DETECTION: Voting power from recently acquired tokens, same-block propose+vote+execute.", "recommendation": "Implement vote escrow (veToken) requiring lock period. Snapshot voting power at proposal creation. Add mandatory timelock between vote and execution. Require token holding duration for voting eligibility.", "remediation_status": "", "detection_cues": ["vote", "proposal", "governance", "quorum", "execute", "token"], "suggested_checks": ["requires(voting_power_snapshot at proposal_time)", "requires(timelock before execution)", "ensures(flash loan voting impossible)"]}
{"id": "SUI-CHAIN-005", "project": "Sui-Move-Exploitation-Chains", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Reentrancy-Like Pattern via Hot Potato", "severity": "high", "issue_tags": ["reentrancy", "hot_potato", "callback", "state"], "description": "EXPLOITATION CHAIN: While Move prevents classic reentrancy, hot potato pattern creates similar risks. 1) User calls function A which creates hot potato receipt. 2) Before completing function A (returning receipt), user's PTB calls function B. 3) Function B reads state that function A was about to update. 4) User completes function A, but function B executed with stale state. DETECTION: State reads between hot potato creation and consumption.", "recommendation": "Update all relevant state before creating hot potato. Don't read state that may be modified by pending operations. Use atomic state transitions.", "remediation_status": "", "detection_cues": ["Receipt", "hot_potato", "drop", "repay", "flash"], "suggested_checks": ["requires(state updated before receipt creation)", "ensures(state consistent throughout operation)"]}
{"id": "SUI-PATTERN-DEFI-001", "project": "Sui-Move-DeFi-Patterns", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Lending Protocol - Collateral Factor Manipulation", "severity": "critical", "issue_tags": ["lending", "collateral", "liquidation", "borrow"], "description": "VULNERABILITY: Lending protocols use collateral factors to determine borrowing capacity. Issues: 1) Collateral factor too high allows over-borrowing, 2) No buffer for price volatility, 3) Liquidation threshold equals borrow threshold (no liquidation incentive). ATTACK: Borrow max, slight price move triggers instant bad debt. PATTERN: borrow_amount = collateral_value * collateral_factor without safety margin.", "recommendation": "Implement conservative collateral factors (< 80%). Add liquidation buffer (liquidation_threshold < collateral_factor). Use health factor with safety margin. Implement gradual liquidation.", "remediation_status": "", "detection_cues": ["collateral", "borrow", "liquidate", "health_factor", "collateral_factor", "threshold"], "suggested_checks": ["requires(borrow_value < collateral_value * factor)", "requires(health_factor > 1.0)", "ensures(protocol has liquidation buffer)"]}
{"id": "SUI-PATTERN-DEFI-002", "project": "Sui-Move-DeFi-Patterns", "source_file": "taxonomy", "module_path": null, "function": null, "title": "AMM Pool - Imbalanced Liquidity Withdrawal", "severity": "high", "issue_tags": ["amm", "liquidity", "withdrawal", "imbalanced"], "description": "VULNERABILITY: Single-sided or imbalanced liquidity operations can be exploited. ATTACK: 1) Manipulate pool ratio via swap, 2) Add liquidity at manipulated ratio, 3) Restore pool ratio, 4) Remove liquidity at favorable ratio. Or: Withdraw single asset from imbalanced pool, receive more due to pricing. PATTERN: remove_liquidity_single_asset without proper pricing.", "recommendation": "Use virtual reserves or TWAP for liquidity operations. Implement withdrawal fees for imbalanced operations. Add slippage protection for single-sided operations.", "remediation_status": "", "detection_cues": ["remove_liquidity", "add_liquidity", "single_asset", "imbalanced", "pool"], "suggested_checks": ["requires(withdrawal amount calculated fairly)", "ensures(LP receives proportional assets)"]}
{"id": "SUI-PATTERN-NFT-001", "project": "Sui-Move-NFT-Patterns", "source_file": "taxonomy", "module_path": null, "function": null, "title": "NFT Minting - Predictable Rarity Assignment", "severity": "high", "issue_tags": ["nft", "minting", "randomness", "rarity"], "description": "VULNERABILITY: NFT rarity determined by predictable on-chain data allows gaming the system. ATTACK: 1) Calculate which transaction parameters yield rare NFT, 2) Submit transaction only when conditions match, 3) Obtain rare NFTs at common prices. PATTERN: let rarity = (timestamp + token_id) % 100; if rarity < 5 { LEGENDARY }.", "recommendation": "Use commit-reveal for minting. Implement VRF-based randomness. Reveal rarity after mint completes. Consider fair launch mechanisms.", "remediation_status": "", "detection_cues": ["mint", "nft", "rarity", "random", "timestamp", "token_id"], "suggested_checks": ["requires(rarity from unpredictable source)", "ensures(fair distribution of rarities)"]}
{"id": "SUI-PATTERN-STAKING-001", "project": "Sui-Move-Staking-Patterns", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Staking Reward Distribution - Dilution Attack", "severity": "high", "issue_tags": ["staking", "reward", "dilution", "timing"], "description": "VULNERABILITY: Reward distribution based on stake at distribution time, not time-weighted stake. ATTACK: 1) Wait until just before reward distribution, 2) Stake large amount, 3) Claim disproportionate rewards, 4) Unstake immediately. PATTERN: reward = user_stake / total_stake * total_rewards without time weighting.", "recommendation": "Implement time-weighted staking (ve-token model). Use checkpoint-based reward accounting. Add unstaking cooldown period. Calculate rewards continuously, not at discrete points.", "remediation_status": "", "detection_cues": ["stake", "reward", "distribute", "claim", "total_stake"], "suggested_checks": ["requires(stake duration considered)", "ensures(rewards proportional to time-weighted stake)"]}
{"id": "SUI-DETECT-001", "project": "Sui-Move-Detection-Methods", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Detection: Unchecked Arithmetic Operations", "severity": "informational", "issue_tags": ["detection", "arithmetic", "static_analysis"], "description": "DETECTION METHOD for arithmetic vulnerabilities: 1) Scan for multiplication operators (*) with u64 operands, 2) Check if either operand is user-controlled, 3) Verify if result is validated or cast to larger type, 4) Flag: amount * price, shares * rate, value * multiplier without overflow checks. TOOLS: Static analysis, formal verification with overflow assertions.", "recommendation": "Automated check: For each multiplication, verify (a as u128) * (b as u128) pattern or explicit bounds check exists within 5 lines.", "remediation_status": "", "detection_cues": ["* ", "u64", "u128", "as u128", "overflow"], "suggested_checks": ["requires((a as u128) * (b as u128) <= MAX_U64)"]}
{"id": "SUI-DETECT-002", "project": "Sui-Move-Detection-Methods", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Detection: Missing Access Control", "severity": "informational", "issue_tags": ["detection", "access_control", "static_analysis"], "description": "DETECTION METHOD for access control issues: 1) Find all public functions, 2) Identify sensitive operations (withdraw, transfer, set_, update_, admin_, emergency_), 3) Check if function has capability parameter (&AdminCap, &OwnerCap), 4) Check if function validates tx_context::sender, 5) Flag functions with sensitive names but no access control. TOOLS: AST analysis, capability tracking.", "recommendation": "Automated check: Functions matching /withdraw|admin|set_|update_|emergency/ must have &*Cap parameter or sender validation.", "remediation_status": "", "detection_cues": ["public fun", "AdminCap", "OwnerCap", "tx_context::sender", "withdraw", "admin"], "suggested_checks": ["requires(capability or sender check present)"]}
{"id": "SUI-DETECT-003", "project": "Sui-Move-Detection-Methods", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Detection: Resource Leak Paths", "severity": "informational", "issue_tags": ["detection", "resource", "leak", "static_analysis"], "description": "DETECTION METHOD for resource leaks: 1) Track all resource (Coin, Balance, Object) creation/acquisition in function, 2) Trace all code paths (including early returns, assertions), 3) Verify each path either: transfers, destroys, or returns the resource, 4) Flag paths where resource scope ends without consumption. TOOLS: Control flow analysis, resource tracking.", "recommendation": "Automated check: For each resource in scope, all exit paths must include transfer, destroy, or return of that resource.", "remediation_status": "", "detection_cues": ["Coin<", "Balance<", "return", "abort", "assert!"], "suggested_checks": ["ensures(all resources consumed on all paths)"]}
{"id": "SUI-DETECT-004", "project": "Sui-Move-Detection-Methods", "source_file": "taxonomy", "module_path": null, "function": null, "title": "Detection: Slippage Protection Absence", "severity": "informational", "issue_tags": ["detection", "slippage", "swap", "static_analysis"], "description": "DETECTION METHOD for missing slippage protection: 1) Find swap/exchange functions, 2) Check parameters for min_amount_out, max_amount_in, price_limit, 3) If missing, check function body for output validation, 4) Flag swap functions without user-specified output bounds. TOOLS: Parameter analysis, assertion scanning.", "recommendation": "Automated check: Functions named *swap* must have parameter matching /min_.*out|max_.*in|.*limit/ or assert on output amount.", "remediation_status": "", "detection_cues": ["swap", "exchange", "trade", "amount_out", "min_", "max_"], "suggested_checks": ["requires(min_amount_out parameter or equivalent check)"]}
{"id": "SUI-VULN-BITSHIFT-001", "project": "Cetus-Hack-Analysis", "source_file": "halborn-dedaub-analysis", "module_path": "clmm_math.move", "function": "checked_shlw", "title": "Flawed Overflow Check in Bit-Shift Operations - checked_shlw Mask Error", "severity": "critical", "issue_tags": ["overflow", "bitshift", "clmm", "math"], "description": "The checked_shlw function contains a critical flaw where the mask calculation 0xffffffffffffffff << 192 doesn't produce the intended result. Developers intended to check if n >= (1 << 192), but the actual mask was too large by factor of 2^64-1. Most values greater than 2^192 pass through undetected, and subsequent left shift by 64 bits causes silent overflow. Move's left shift operator does NOT abort on overflow unlike addition/multiplication.", "recommendation": "Fix mask value from 0xffffffffffffffff << 192 to 1 << 192. Always verify that 'checked' operations actually perform proper bounds checking. For bit-shift operations, implement explicit overflow guards since Move doesn't automatically abort.", "remediation_status": "", "detection_cues": ["checked_shlw", "checked_shl", "<< 192", "<< 64", "mask", "0xffffffffffffffff", "bit shift", "left shift", "shl"], "suggested_checks": ["requires(n < (1 << 192));", "ensures((result >> 64) == 0 || n >= (1 << 192));", "// Bit-shift overflow check: Move does NOT abort on left-shift overflow"]}
{"id": "SUI-VULN-BITSHIFT-002", "project": "Cetus-Hack-Analysis", "source_file": "halborn-dedaub-analysis", "module_path": "clmm_math.move", "function": "get_delta_a", "title": "CLMM Liquidity Calculation Overflow via Unchecked Bit-Shift", "severity": "critical", "issue_tags": ["overflow", "clmm", "liquidity", "defi"], "description": "The get_delta_a function in CLMM protocols can suffer silent overflow when calculating token amounts. Attacker supplies liquidity value ~2^113 with price difference ~2^79, multiplication produces ~2^192 exceeding safe range. Due to flawed checked_shlw, left-shifting by 64 bits causes truncation, wrapping result to near-zero. Attacker deposits 1 token but receives billions in liquidity credit.", "recommendation": "Audit all CLMM math libraries thoroughly. Validate that liquidity and price calculations cannot exceed safe ranges. Use u256 for intermediate calculations. Ensure overflow checks actually work for the full input range.", "remediation_status": "", "detection_cues": ["get_delta_a", "get_delta_b", "liquidity", "sqrt_price", "tick", "clmm", "concentrated liquidity", "amount_by_liquidity"], "suggested_checks": ["requires((liquidity as u256) * (price_diff as u256) <= MAX_SAFE_VALUE);", "ensures(result > 0 || liquidity == 0);", "// CLMM math requires extensive overflow protection"]}
{"id": "SUI-VULN-TRUNCATE-001", "project": "Cetus-Hack-Analysis", "source_file": "verichains-analysis", "module_path": null, "function": "get_amount_by_liquidity", "title": "Type Truncation from u256 to u64 Losing High Bits", "severity": "critical", "issue_tags": ["overflow", "truncation", "type_cast"], "description": "When multiplying two u128 values, the result should be u256. However, if the function casts the u256 result to u64, high 128-bit data is truncated. Attacker exploits this to mint liquidity that originally required large amounts of tokens with only very small inputs. This is a mathematical calculation error at application logic level, not a Move language flaw.", "recommendation": "Never downcast u256 to u64 without explicit bounds checking. Use assert!(result <= MAX_U64) before casting. For financial calculations, keep intermediate results in highest precision type.", "remediation_status": "", "detection_cues": ["as u64", "as u128", "(u256)", "type cast", "truncate", "get_amount_by_liquidity", "high bits"], "suggested_checks": ["requires((a as u256) * (b as u256) <= MAX_U64);", "ensures(result == ((a as u256) * (b as u256)) as u64);", "// Type truncation: verify bounds before downcasting"]}
{"id": "SUI-VULN-OBJECT-001", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "Excessive Struct Abilities Creating Exploit Vectors", "severity": "high", "issue_tags": ["object", "abilities", "capability"], "description": "Assigning unnecessary abilities to structs creates exploit vectors. Event structures should only have 'copy' and 'drop'. Flashloan receipts should have NO abilities to enforce repayment (Hot Potato pattern). AdminCap and other capabilities should not have 'drop' to prevent accidental destruction.", "recommendation": "Assign minimal necessary abilities to each type. Events: copy+drop only. Receipts: no abilities. Capabilities: key+store (no drop). Assets: key+store.", "remediation_status": "", "detection_cues": ["has copy, drop, store, key", "Receipt<", "struct.*has.*drop", "AdminCap.*drop", "abilities"], "suggested_checks": ["// Verify Receipt types have no abilities (Hot Potato)", "// Verify AdminCap does not have 'drop' ability", "// Verify event structs only have copy+drop"]}
{"id": "SUI-VULN-OBJECT-002", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "Unvalidated Generic Type Parameters Allowing Token Substitution", "severity": "critical", "issue_tags": ["generic", "type_safety", "token"], "description": "When functions use generic type parameters without validation, attackers can substitute low-value or worthless tokens for high-value ones. If signature verification omits type checking, any type of Coin can be used. This was exploited in the Cetus hack using spoof tokens like BULLA.", "recommendation": "Include type information in all signature verifications for generic parameters. Use type_name::get<T>() to verify token types match expected values. Validate token economic properties (liquidity, price oracle).", "remediation_status": "", "detection_cues": ["<T>", "<CoinType>", "type_name", "generic", "Coin<T>", "Pool<", "any type"], "suggested_checks": ["requires(type_name::get<T>() == expected_type);", "// Validate generic type parameters against whitelist", "// Check token has real economic value before accepting"]}
{"id": "SUI-VULN-OBJECT-003", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "Improper Object Sharing - Capabilities Shared Instead of Transferred", "severity": "high", "issue_tags": ["object", "sharing", "capability", "access_control"], "description": "Sharing sensitive capabilities like AdminCap via share_object() instead of public_transfer() grants unauthorized modification rights to anyone. Shared objects can be accessed by any transaction, while owned objects can only be accessed by the owner.", "recommendation": "Transfer sensitive capabilities directly using transfer::public_transfer() or transfer::transfer(). Only use share_object() for objects that genuinely need multi-party access.", "remediation_status": "", "detection_cues": ["share_object", "public_share_object", "AdminCap", "OwnerCap", "capability"], "suggested_checks": ["// Verify capabilities are transferred, not shared", "// Ensure AdminCap uses transfer::transfer() not share_object()"]}
{"id": "SUI-VULN-OBJECT-004", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "Inconsistent Multi-Object Parameter Validation", "severity": "medium", "issue_tags": ["object", "validation", "cross_object"], "description": "When functions accept multiple related shared objects, they must explicitly verify the relationship between them. Without validation, attackers can pass unrelated objects, causing cross-contamination attacks or state corruption.", "recommendation": "Always validate consistency between dependent objects in multi-object operations. Check that position.pool_id matches pool.id. Verify related object relationships explicitly.", "remediation_status": "", "detection_cues": ["pool: &mut Pool", "position: &mut Position", "pool_id", "multiple shared objects", "object relationship"], "suggested_checks": ["requires(position.pool_id == object::id(pool));", "// Validate multi-object relationships explicitly"]}
{"id": "SUI-VULN-OBJECT-005", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "Unfrozen Mutable Metadata Enabling User Deception", "severity": "medium", "issue_tags": ["metadata", "coin", "trust"], "description": "Leaving Coin metadata mutable allows administrators to deceive users by altering token name, symbol, or decimals after users have acquired the token. This can be used for rug pulls or market manipulation.", "recommendation": "Freeze immutable data using public_freeze_object() after initial configuration. Document any metadata that remains mutable and the governance process for changes.", "remediation_status": "", "detection_cues": ["CoinMetadata", "metadata", "public_freeze_object", "freeze", "TreasuryCap"], "suggested_checks": ["// Verify CoinMetadata is frozen after init", "// Check TreasuryCap access is properly restricted"]}
{"id": "SUI-VULN-UPGRADE-002", "project": "MoveBit-Security-Guide", "source_file": "sui-objects-security", "module_path": null, "function": null, "title": "External Package Dependency Not Auto-Updated", "severity": "medium", "issue_tags": ["upgrade", "dependency", "version"], "description": "When an external package is upgraded, dependent contracts do not automatically update their dependency references. The init function only runs on first deployment and won't re-execute after upgrades. This can leave contracts using outdated or incompatible dependency versions.", "recommendation": "Implement explicit version compatibility checks. Use checked_package_version() pattern. Design upgrade migration logic to handle dependency updates.", "remediation_status": "", "detection_cues": ["init", "upgrade", "package_version", "dependency", "external module"], "suggested_checks": ["requires(checked_package_version(current_version));", "// Verify package version compatibility after upgrades"]}
{"id": "SUI-VULN-MEV-001", "project": "SlowMist-Audit-Primer", "source_file": "slowmist-sui-move", "module_path": null, "function": null, "title": "Transaction Ordering Exploitation (MEV/Race Conditions)", "severity": "high", "issue_tags": ["mev", "ordering", "race_condition", "sandwich"], "description": "Validators can reorder transactions for profit (MEV). Functions whose outcomes depend on execution order are vulnerable to sandwich attacks, front-running, and back-running. Price-sensitive operations without slippage protection are especially vulnerable.", "recommendation": "Add slippage protection with min_amount_out parameters. Use commit-reveal schemes for sensitive operations. Implement deadline parameters to limit transaction validity.", "remediation_status": "", "detection_cues": ["swap", "trade", "min_amount_out", "deadline", "front-run", "sandwich", "mev"], "suggested_checks": ["requires(deadline >= clock::timestamp_ms(clock));", "ensures(amount_out >= min_amount_out);", "// MEV protection: validate slippage and deadline"]}
{"id": "MOVE-VM-001", "project": "Move-VM-Security", "source_file": "zellic-billion-dollar-bug", "module_path": "move-binary-format", "function": "Bytecode::get_successors", "title": "Move Bytecode Verifier CFG Construction Bug - Billion Dollar Bug", "severity": "critical", "issue_tags": ["bytecode", "verifier", "cfg", "vm"], "description": "Critical bug in Move bytecode verifier's Control Flow Graph construction. The get_successors function had an early return preventing successor identification for the last opcode in functions with 65,534 instructions. When final instruction was a jump, CFG returned no successors, creating invisible code paths that bypass: (1) Locals Safety Verifier - drop objects without drop ability, (2) Reference Safety Verifier - multiple mutable references to same object, (3) Paranoid Type Checks. Affects all Move-based chains: Sui, Aptos, Starcoin.", "recommendation": "Fixed by removing early return condition. For auditors: verify bytecode verifier edge cases, especially with large functions near u16 limits.", "remediation_status": "fixed", "detection_cues": ["get_successors", "CFG", "bytecode verifier", "control flow", "65534 instructions"], "suggested_checks": ["// Verify bytecode verifier handles all control flow paths", "// Test with boundary functions near u16::MAX instructions"]}
{"id": "MOVE-VM-002", "project": "Move-VM-Security", "source_file": "numen-aptos-vm", "module_path": "stack_usage_verifier.rs", "function": "verify_bytecode", "title": "Move VM Stack Usage Verifier Integer Overflow", "severity": "critical", "issue_tags": ["overflow", "vm", "dos", "verifier"], "description": "Integer overflow vulnerability in Move VM's stack_usage_verifier.rs that validates bytecode instructions before MoveVM execution. Overflow causes undefined behavior and crashes, leading to DoS attacks. If exploited, can cause complete network shutdown requiring hard fork for Aptos/Sui networks.", "recommendation": "Use checked arithmetic in all verifier integer operations. Implement bounds checking before operations.", "remediation_status": "fixed", "detection_cues": ["stack_usage_verifier", "bytecode verification", "integer overflow", "vm crash"], "suggested_checks": ["// VM-level: verify stack usage calculations don't overflow"]}
{"id": "SUI-VULN-VALIDATOR-001", "project": "Sui-Network-Security", "source_file": "immunefi-sui-shutdown", "module_path": "narwhal/primary", "function": "GetCertificates", "title": "Sui Validator OOM DoS via Unbounded Certificate Queries", "severity": "high", "issue_tags": ["dos", "validator", "oom", "narwhal"], "description": "Vulnerability in Narwhal mempool's GetCertificates handler allowing attackers to crash validators via OOM. No limit on response digests or timeout handling. A 37MB payload with 1.2M digests could crash 64GB RAM validators (certificates up to 41KB each). Enables temporary total network shutdown.", "recommendation": "Removed GetCertificates and GetPayloadAvailability handlers. For similar handlers: implement query limits, timeouts, and pagination.", "remediation_status": "fixed", "detection_cues": ["GetCertificates", "GetPayloadAvailability", "narwhal", "digest", "validator", "OOM"], "suggested_checks": ["// Ensure all network handlers have: (1) query limits, (2) timeouts, (3) memory bounds"]}
{"id": "SUI-VULN-NEMO-001", "project": "Nemo-Protocol", "source_file": "nemo-exploit-2025", "module_path": null, "function": null, "title": "Nemo Protocol Oracle Price Manipulation Attack", "severity": "critical", "issue_tags": ["oracle", "price_manipulation", "defi", "lending"], "description": "Nemo Protocol yield platform exploited for $2.4M USDC via price oracle manipulation. Attacker manipulated oracle to siphon funds from lending protocol. Funds bridged from Sui to Arbitrum to Ethereum (to avoid USDC freeze). TVL dropped from $6M to $1.53M.", "recommendation": "Use time-weighted average prices (TWAP). Implement price deviation checks. Use multiple oracle sources. Add circuit breakers for abnormal price movements.", "remediation_status": "", "detection_cues": ["oracle", "price", "manipulation", "lending", "yield", "TWAP"], "suggested_checks": ["requires(abs(current_price - twap_price) < MAX_DEVIATION);", "requires(price_sources >= MIN_ORACLE_SOURCES);", "// Verify oracle freshness and deviation bounds"]}
{"id": "SUI-VULN-UID-001", "project": "Sui-Object-Security", "source_file": "zellic-sui-primer", "module_path": null, "function": null, "title": "UID Swapping - Object Type Confusion via Destruct/Reconstruct", "severity": "medium", "issue_tags": ["object", "uid", "type_confusion"], "description": "Contracts can change object types on-chain by destructing and reconstructing objects with swapped UIDs. While on-chain programs unlikely vulnerable, off-chain applications making assumptions about object types can be confused. Objects can appear to change identity.", "recommendation": "Off-chain applications should not assume object types are immutable. Verify object types at each interaction, not just at creation.", "remediation_status": "fixed", "detection_cues": ["UID", "object::delete", "destruct", "reconstruct", "type change"], "suggested_checks": ["// Off-chain: verify object type at each interaction"]}
{"id": "SUI-VULN-HIDE-001", "project": "Sui-Object-Security", "source_file": "zellic-sui-primer", "module_path": null, "function": null, "title": "Object Hiding - Non-Store Objects Wrapped and Hidden", "severity": "medium", "issue_tags": ["object", "wrapping", "state"], "description": "Contracts controlling object creation can wrap non-store objects inside other objects, making them inaccessible until unwrapped. Objects can 'go in and out of existence', confusing external systems tracking state. Can hide assets from view.", "recommendation": "External systems should track wrapping/unwrapping events. Don't assume object visibility equals existence.", "remediation_status": "fixed", "detection_cues": ["wrap", "unwrap", "non-store", "hidden object", "object visibility"], "suggested_checks": ["// Track wrap/unwrap events for state consistency"]}
{"id": "SUI-VULN-ABILITY-001", "project": "Sui-Ability-Security", "source_file": "mirage-audits", "module_path": null, "function": null, "title": "Accidental Drop on Hot Potato - Flash Loan Security Bypass", "severity": "critical", "issue_tags": ["ability", "drop", "hot_potato", "flash_loan"], "description": "Adding 'drop' ability to hot potato enforcement mechanisms (flash loan receipts) destroys entire security model. Struct with 'has drop' can be silently discarded, bypassing required consumption logic. No compiler warning - silently allows vulnerable code to compile. This is the most dangerous ability-related mistake.", "recommendation": "Hot potatoes requiring mandatory consumption must have ZERO abilities. Use #[expected_failure] tests to verify receipts cannot be dropped.", "remediation_status": "", "detection_cues": ["has drop", "Receipt", "FlashLoan", "hot potato", "enforcement"], "suggested_checks": ["// Test: #[expected_failure] public fun test_cannot_drop_receipt()", "// Verify enforcement structs have no abilities"]}
{"id": "SUI-VULN-ABILITY-002", "project": "Sui-Ability-Security", "source_file": "mirage-audits", "module_path": null, "function": null, "title": "Phantom Type Bypass - Token Substitution via Missing Phantom", "severity": "high", "issue_tags": ["ability", "phantom", "generic", "type_safety"], "description": "Missing phantom type parameters on generic receipts enable type substitution attacks. PaymentReceipt without 'phantom CoinType' allows attackers to pay with worthless tokens while claiming valuable items. Type binding bypassed at compile time.", "recommendation": "Use 'PaymentReceipt<phantom CoinType>' to bind receipts to specific token types at compile time.", "remediation_status": "", "detection_cues": ["phantom", "generic receipt", "PaymentReceipt", "type substitution", "<CoinType>"], "suggested_checks": ["// Ensure payment receipts use phantom type parameters", "requires(type_of<PaymentType>() == expected_type);"]}
{"id": "SUI-VULN-ABILITY-003", "project": "Sui-Ability-Security", "source_file": "mirage-audits", "module_path": null, "function": null, "title": "Dangerous Copy+Drop Combination - Infinite Token Duplication", "severity": "critical", "issue_tags": ["ability", "copy", "drop", "token", "duplication"], "description": "Combining 'copy' and 'drop' on asset-representing structs enables: (1) Infinite token duplication via copy, (2) Token destruction at will via drop, (3) Effective token creation from thin air. Completely breaks asset security model.", "recommendation": "Assets should have ONLY 'key' and 'store'. NEVER 'copy' or 'drop'. Golden rule: if it represents value, no copy/drop.", "remediation_status": "", "detection_cues": ["has copy, drop", "has copy", "asset", "token", "Coin"], "suggested_checks": ["// Verify asset structs have only key+store, never copy/drop"]}
{"id": "MOVE-VULN-GENERIC-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Lack of Generic Type Checking - Type Substitution", "severity": "high", "issue_tags": ["generic", "type_checking", "validation"], "description": "Functions accepting generic types fail to validate type matches expected/whitelisted values. cancel_order accepting BaseCoinType without verifying it matches stored base_type. Enables asset theft via wrong type substitution.", "recommendation": "Add type-checking assertion: assert!(order.base_type == type_info::type_of<BaseCoinType>(), ERR_WRONG_TYPE);", "remediation_status": "", "detection_cues": ["<T>", "<CoinType>", "generic", "type_info::type_of", "type validation"], "suggested_checks": ["requires(stored_type == type_info::type_of<T>());", "// Validate generic types against expected values"]}
{"id": "MOVE-VULN-UNBOUNDED-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Unbounded Execution - DoS via Gas Exhaustion", "severity": "high", "issue_tags": ["dos", "gas", "unbounded", "loop"], "description": "Loops iterating over shared user-controlled collections enable DoS attacks through gas exhaustion. get_order_by_id iterating through all orders without bounds. While/for loops over vectors without iteration limits callable by multiple users.", "recommendation": "Limit iterations per transaction. Restructure data to avoid full-vector scans. Use pagination or indexed lookups.", "remediation_status": "", "detection_cues": ["while", "for", "vector", "loop", "iteration", "all orders", "unbounded"], "suggested_checks": ["requires(iteration_count <= MAX_ITERATIONS);", "// Ensure loops have bounded execution"]}
{"id": "MOVE-VULN-ACCESS-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Improper Access Control - Missing Signer Verification", "severity": "critical", "issue_tags": ["access_control", "signer", "authorization"], "description": "Functions accepting &signer parameters fail to assert signer owns targeted resource. cancel_order transfers assets without checking order.user_address == address_of(user). Signer parameters used without address_of(signer) verification.", "recommendation": "Add signer verification: assert!(resource.owner == signer::address_of(user), E_NOT_OWNER);", "remediation_status": "", "detection_cues": ["&signer", "signer", "address_of", "user_address", "owner"], "suggested_checks": ["requires(resource.owner == signer::address_of(account));", "// Verify signer owns resource before modification"]}
{"id": "MOVE-VULN-PRECISION-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Arithmetic Precision Errors - Division Before Multiplication", "severity": "high", "issue_tags": ["precision", "arithmetic", "rounding", "fee"], "description": "Division before multiplication causes rounding-down errors, underrepresenting calculated values. Protocol fees calculated as (size * FEE_BPS / 10000) round to zero for small amounts. Intermediate values drop below 1.", "recommendation": "Reorder operations to multiply first. Require minimum transaction sizes or non-zero fee results. Use higher precision intermediates.", "remediation_status": "", "detection_cues": ["/ 10000", "/ denominator", "fee", "precision", "rounding"], "suggested_checks": ["ensures(fee > 0 || amount < MIN_FEE_AMOUNT);", "// Verify precision: multiply before divide"]}
{"id": "MOVE-VULN-REGISTER-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Lack of Account Registration Check for Coin", "severity": "medium", "issue_tags": ["coin", "registration", "abort"], "description": "Code attempts to deposit coins into unregistered accounts, causing transaction aborts. coin::deposit or coin::withdraw called without prior coin::register or is_account_registered checks.", "recommendation": "Call coin::register<CoinType>(account) before deposits. Check is_account_registered first. Safe to call register multiple times.", "remediation_status": "", "detection_cues": ["coin::deposit", "coin::withdraw", "coin::register", "is_account_registered"], "suggested_checks": ["requires(coin::is_account_registered<CoinType>(recipient));", "// Ensure recipient is registered for coin type"]}
{"id": "MOVE-VULN-RESOURCE-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Improper Resource Management - Module Account Storage", "severity": "medium", "issue_tags": ["resource", "storage", "ownership", "centralization"], "description": "Storing user resources on module accounts violates Move ownership principles, concentrating risk. Resources stored in module-controlled tables/vectors instead of user accounts. Orders stored in global OrderStore vector rather than per-user resources.", "recommendation": "Restructure to place resources in user accounts following Move best practices. Decentralize storage.", "remediation_status": "", "detection_cues": ["global", "OrderStore", "module account", "table", "centralized storage"], "suggested_checks": ["// Prefer user-account storage over global module storage"]}
{"id": "MOVE-VULN-STDLIB-001", "project": "Zellic-Top10-Move", "source_file": "zellic-top10-aptos", "module_path": null, "function": null, "title": "Use of Incorrect Standard Function - Option/Table Misuse", "severity": "medium", "issue_tags": ["stdlib", "option", "table", "abort"], "description": "Similar stdlib functions serve different purposes; using wrong variants causes runtime aborts. option::extract() followed by option::borrow() on extracted Option fails. Table operations using add vs upsert incorrectly.", "recommendation": "Extract once and reuse value. Ensure function selection matches operation intent. Review stdlib documentation carefully.", "remediation_status": "", "detection_cues": ["option::extract", "option::borrow", "table::add", "table::upsert", "stdlib"], "suggested_checks": ["// Verify correct stdlib function usage for intended operation"]}
{"id": "MOVE-VULN-FREEZE-001", "project": "Move-Security", "source_file": "zellic-move-pt1", "module_path": null, "function": null, "title": "Resource Storage Mismatch - Coin Wrapper Bypass Freeze", "severity": "high", "issue_tags": ["coin", "freeze", "wrapper", "bypass", "regulatory"], "description": "Coins wrapped in custom structures bypass framework controls. Users storing coins in non-standard wrappers circumvent: freeze operations, burn mechanisms, regulatory controls. NotCoinStore wrapper prevents coin::freeze_coin_store() from functioning.", "recommendation": "Design protocols to handle wrapped coins. Consider additional freeze mechanisms for custom wrappers. Document wrapper limitations.", "remediation_status": "", "detection_cues": ["wrapper", "CoinStore", "freeze", "custom struct", "coin storage"], "suggested_checks": ["// Consider wrapped coin scenarios in freeze/burn logic"]}
{"id": "CTF-VULN-RANDOM-001", "project": "MetaTrust-CTF-2023", "source_file": "metatrust-ctf-writeup", "module_path": null, "function": null, "title": "Weak Randomness - LCG with Small Seed Space", "severity": "high", "issue_tags": ["randomness", "lcg", "predictable", "ctf"], "description": "Randomness generated using custom LCG (Linear Congruential Generator) with u8 seed (256 possible values). Outcomes predictable via brute-force with 1/256 success rate. Not using VRF (Verifiable Random Function). Games requiring consecutive correct guesses exploitable.", "recommendation": "Use VRF for randomness. Never use small seed spaces. Don't rely on timestamp or counters for entropy.", "remediation_status": "", "detection_cues": ["random", "LCG", "seed", "timestamp", "counter", "predictable"], "suggested_checks": ["// Ensure randomness source is VRF-based, not predictable"]}
{"id": "CTF-VULN-FRIEND-001", "project": "MetaTrust-CTF-2023", "source_file": "metatrust-ctf-writeup", "module_path": null, "function": null, "title": "Friend Mechanism Bypass - Unchecked User Input for Context", "severity": "high", "issue_tags": ["friend", "access_control", "input_validation", "ctf"], "description": "Friend-restricted function accepts user-provided ctxSender without validation. get_flag callable only via prestige function due to friend mechanism, but ctxSender value 0x31337690420 accepted from user input without checks.", "recommendation": "Never trust user-provided context values. Validate all inputs even when protected by friend mechanism.", "remediation_status": "", "detection_cues": ["friend", "ctxSender", "context", "user input", "prestige"], "suggested_checks": ["requires(ctx_sender == tx_context::sender(ctx));", "// Validate context values are not user-controllable"]}
{"id": "SUI-VULN-HAMSTERWHEEL-001", "project": "Sui-Network-Security", "source_file": "certik-hamsterwheel", "module_path": "verification", "function": "AbstractState::join", "title": "HamsterWheel Attack - Verification Deadloop Causing Network Shutdown", "severity": "critical", "issue_tags": ["dos", "deadloop", "verification", "network"], "description": "Novel attack vector discovered by CertiK Skyfall. A ~100 byte payload can trigger infinite loop in validator verification process. Unlike traditional crash attacks, nodes are trapped in ceaseless operation without processing transactions. Persists even after validator reboot. State merge logic incorrectly determined merge result before executing AbstractValue::join, causing dead loops during analysis.", "recommendation": "Fixed by executing AbstractValue::join first, then setting change flag based on comparing final result with original value. For similar verifiers: ensure state merge results match actual updates.", "remediation_status": "fixed", "detection_cues": ["AbstractState::join", "verification", "deadloop", "infinite loop", "state merge"], "suggested_checks": ["// Verify state merge logic doesn't create infinite loops", "// Test verification with adversarial inputs"]}
{"id": "SUI-VULN-TYPUS-001", "project": "Typus-Finance", "source_file": "typus-oracle-exploit", "module_path": "oracle", "function": "update_v2", "title": "Typus Finance Oracle Exploit - Missing Authorization Assert", "severity": "critical", "issue_tags": ["oracle", "access_control", "authorization", "custom_oracle"], "description": "Missing assert check in oracle update_v2 function allowed any address to update oracle prices. Attacker manipulated token values and performed swaps at incorrect prices, draining $3.44M. Custom oracle module (deployed Nov 2024) was not included in May 2025 MoveBit audit scope. Funds bridged to Ethereum via CCTP.", "recommendation": "Use proven oracle solutions like Chainlink. Ensure ALL modules are in audit scope. Implement multiple authorization checks. Add assert statements for access control in oracle update functions.", "remediation_status": "acknowledged", "detection_cues": ["oracle", "update", "price", "assert", "authorization", "custom oracle"], "suggested_checks": ["requires(tx_context::sender(ctx) == oracle.admin);", "// Verify oracle update functions have proper authorization"]}
{"id": "CTF-VULN-PRNG-001", "project": "MoveCTF-2022", "source_file": "movectf-writeup", "module_path": null, "function": "random", "title": "Predictable Pseudorandom Number Generator via TxContext", "severity": "high", "issue_tags": ["randomness", "prng", "predictable", "ctf", "txcontext"], "description": "Random values generated using TxContext are predictable to miners/validators. The seed function uses ids_created field which increments predictably. Attacker can precompute TxContext states using SDK, brute-force gas amounts to control randomness outcomes. Games requiring consecutive correct guesses become exploitable.", "recommendation": "Use VRF (Verifiable Random Function) for randomness. Never derive randomness from TxContext, timestamps, or predictable on-chain data. Consider commit-reveal schemes.", "remediation_status": "", "detection_cues": ["random", "TxContext", "ids_created", "seed", "predictable", "gas"], "suggested_checks": ["// Never use TxContext for randomness", "// Ensure VRF-based randomness for games/lotteries"]}
{"id": "CTF-VULN-FLASHLOAN-001", "project": "MoveCTF-2022", "source_file": "movectf-writeup", "module_path": null, "function": null, "title": "Flash Loan Balance Manipulation - Temporary Zero Balance Exploit", "severity": "high", "issue_tags": ["flash_loan", "balance", "ctf", "temporary_state"], "description": "Classic flash loan vulnerability: borrow all funds from lender, call flag/sensitive function while balance is zero (passing zero-balance checks), then repay loan in same transaction. Exploits functions that check balance state without considering temporary flash loan manipulation.", "recommendation": "Don't rely solely on balance checks for authorization. Use reentrancy guards. Consider flash loan scenarios in security model. Check for active flash loans before sensitive operations.", "remediation_status": "", "detection_cues": ["flash_loan", "balance", "borrow", "repay", "zero balance"], "suggested_checks": ["requires(!has_active_flash_loan());", "// Consider flash loan manipulation in balance checks"]}
{"id": "CTF-VULN-CIPHER-001", "project": "MoveCTF-2022", "source_file": "movectf-writeup", "module_path": null, "function": null, "title": "Weak Custom Cryptographic Implementation", "severity": "medium", "issue_tags": ["cryptography", "cipher", "ctf", "custom_crypto"], "description": "Custom cipher implementations can be broken via algebraic analysis or SMT solvers (Z3). Move Lock challenge broken by calculating key and plaintext separately through algorithm analysis rather than brute force. Custom crypto is almost always weaker than standard implementations.", "recommendation": "Never implement custom cryptography. Use well-audited cryptographic libraries and standard algorithms.", "remediation_status": "", "detection_cues": ["cipher", "encrypt", "decrypt", "custom crypto", "xor"], "suggested_checks": ["// Avoid custom cryptographic implementations"]}
{"id": "MOVE-SCAN-001", "project": "MoveScanner-Research", "source_file": "movescanner-arxiv", "module_path": null, "function": null, "title": "Resource Leak - Resources Not Properly Moved or Destroyed", "severity": "high", "issue_tags": ["resource", "leak", "linear_type", "research"], "description": "Resources created but not properly moved or destroyed across all execution paths. MoveScanner detected 20,778 vulnerabilities across 37,302 contracts on Aptos and Sui. Even with Move's linear type system, resource leaks occur when developers fail to handle all code paths (especially error paths and early returns).", "recommendation": "Ensure all resources are properly moved or destroyed on ALL execution paths including error branches. Use formal verification to prove resource safety.", "remediation_status": "", "detection_cues": ["resource", "create", "destroy", "move", "early return", "abort"], "suggested_checks": ["ensures(all_resources_consumed_or_transferred());", "// Verify resource handling on all paths including errors"]}
{"id": "MOVE-SCAN-002", "project": "MoveScanner-Research", "source_file": "movescanner-arxiv", "module_path": null, "function": null, "title": "Unchecked Return Values from Function Calls", "severity": "medium", "issue_tags": ["return_value", "unchecked", "error_handling", "research"], "description": "Function calls with unhandled Boolean or non-empty returns can lead to silent failures. If a function returns success/failure status that is ignored, the calling code may proceed with invalid state. Common in cross-module calls.", "recommendation": "Always handle return values from function calls. Use assert! or explicit checks for Boolean returns. Don't discard non-empty return values.", "remediation_status": "", "detection_cues": ["return", "bool", "ignore", "discard", "unchecked"], "suggested_checks": ["// Check all function return values are handled", "let success = call_function(); assert!(success);"]}
{"id": "MOVE-SCAN-003", "project": "MoveScanner-Research", "source_file": "movescanner-arxiv", "module_path": null, "function": null, "title": "Cross-Module State Corruption via Public Functions", "severity": "high", "issue_tags": ["cross_module", "state", "public", "global_storage", "research"], "description": "Public functions modifying other modules' global state without proper access control. Cross-component interactions from modular architecture lead to permission boundary violations. Research identified 12 new security threat types from cross-module interactions.", "recommendation": "Implement strict access control for cross-module state modifications. Use capability pattern for authorization. Minimize public function surface area.", "remediation_status": "", "detection_cues": ["public fun", "borrow_global_mut", "move_to", "cross-module", "global state"], "suggested_checks": ["// Verify cross-module state access has proper authorization"]}
{"id": "MOVE-SCAN-004", "project": "MoveScanner-Research", "source_file": "movescanner-arxiv", "module_path": null, "function": null, "title": "Capability Leak - Privileges Exposed to Untrusted Recipients", "severity": "critical", "issue_tags": ["capability", "leak", "privilege", "transfer", "research"], "description": "Privilege resources (capabilities) transferred to untrusted recipients or exposed in public functions. Once leaked, capabilities cannot be revoked. Enables unauthorized access to admin functions.", "recommendation": "Never transfer capabilities to arbitrary addresses. Verify recipient trustworthiness. Consider capability rotation/revocation mechanisms. Don't expose capabilities via public functions.", "remediation_status": "", "detection_cues": ["Cap", "transfer", "public", "capability", "admin", "privilege"], "suggested_checks": ["// Verify capabilities are not leaked to untrusted parties", "// Check capability transfers have proper authorization"]}
{"id": "MOVECTF-2024-ZK-001", "project": "MoveCTF-2024", "source_file": "movectf-2024-writeup", "module_path": null, "function": null, "title": "ZK Proof Format Mismatch Due to Library Version", "severity": "medium", "issue_tags": ["zk", "proof", "version", "format", "ctf"], "description": "ZK proof submission failed due to ark_circom library version update wrapping public_input_bytes with additional layer, causing validation failures. Version mismatches between client libraries and on-chain verifiers can cause proof rejection.", "recommendation": "Pin library versions. Test ZK proof submission end-to-end. Document exact library versions required for proof generation.", "remediation_status": "", "detection_cues": ["zk", "proof", "ark_circom", "public_input", "verify"], "suggested_checks": ["// Verify ZK library versions match expected format"]}
{"id": "MOVECTF-2024-CURVE-001", "project": "MoveCTF-2024", "source_file": "movectf-2024-writeup", "module_path": null, "function": null, "title": "Twisted Edwards Curve Parameter Exploitation", "severity": "medium", "issue_tags": ["cryptography", "elliptic_curve", "parameters", "ctf"], "description": "Challenge exploited knowledge of twisted Edwards curve equation (168700*x²+delta² = 1+168696*x²*delta²) parameters including base point and generator to find constraint solutions. Cryptographic constraints can be solved by researching underlying mathematical structures.", "recommendation": "When using elliptic curves, use standard well-audited implementations. Don't rely on curve parameters being secret.", "remediation_status": "", "detection_cues": ["curve", "edwards", "parameter", "generator", "base point"], "suggested_checks": ["// Use standard elliptic curve implementations"]}
{"id": "LETS-CTF-GENERIC-001", "project": "LetsMoveCtf", "source_file": "letsmove-ctf", "module_path": null, "function": null, "title": "Phantom Type Parameter Bypass for Type Safety", "severity": "high", "issue_tags": ["generic", "phantom", "type_safety", "ctf"], "description": "Vulnerabilities in Sui Move generics, particularly <phantom T> implementations. Without proper phantom type constraints, attackers can substitute types to bypass intended restrictions. Common in payment/receipt systems where token type should be fixed.", "recommendation": "Use phantom type parameters correctly. Validate type constraints at runtime when accepting generic types. Consider type_name checks.", "remediation_status": "", "detection_cues": ["phantom", "<T>", "generic", "type parameter"], "suggested_checks": ["requires(type_name::get<T>() == expected);", "// Use phantom for type binding, validate at runtime"]}
{"id": "LETS-CTF-PTB-001", "project": "LetsMoveCtf", "source_file": "letsmove-ctf", "module_path": null, "function": null, "title": "Programmable Transaction Block Chaining Vulnerabilities", "severity": "high", "issue_tags": ["ptb", "transaction", "chaining", "ctf"], "description": "Programmable Transaction Blocks (PTB) in Sui allow chaining multiple operations in single transaction. Can be exploited to chain vulnerabilities: e.g., flash loan + price manipulation + withdrawal in one atomic transaction. Defense must consider multi-step attack scenarios.", "recommendation": "Design protocols considering PTB attack scenarios. Add checks between transaction steps. Consider flash loan protection for all sensitive operations.", "remediation_status": "", "detection_cues": ["PTB", "programmable transaction", "chain", "atomic"], "suggested_checks": ["// Consider PTB attack scenarios in security model"]}
{"id": "SUI-INCIDENT-2025-001", "project": "Sui-Incidents-2025", "source_file": "incident-summary", "module_path": null, "function": null, "title": "Sui 2025 Security Incidents Summary - $225M+ Total Losses", "severity": "critical", "issue_tags": ["incident", "summary", "2025"], "description": "Three major Sui DeFi exploits in 2025: (1) Cetus Protocol May 2025 - $223M - checked_shlw overflow in CLMM math library, (2) Nemo Protocol Sep 2025 - $2.4M - oracle price manipulation, (3) Typus Finance Oct 2025 - $3.44M - missing authorization in custom oracle. Common themes: oracle vulnerabilities, unaudited code, math library flaws.", "recommendation": "Comprehensive audits covering ALL modules. Use proven oracle solutions. Multiple security reviews for math libraries. Implement circuit breakers and pause mechanisms.", "remediation_status": "", "detection_cues": ["oracle", "overflow", "math", "authorization"], "suggested_checks": ["// Comprehensive security checklist for Sui DeFi protocols"]}
{"id": "SUI-VULN-OTW-001", "project": "Sui-OTW-Security", "source_file": "sui-docs", "module_path": null, "function": "init", "title": "One-Time Witness Bypass - Additional Capability Creation After Init", "severity": "high", "issue_tags": ["otw", "init", "capability", "singleton"], "description": "The init function with OTW doesn't prevent adding new functions that create additional capabilities later. If module allows creating new admin caps outside init, OTW guarantee is bypassed. OTW only ensures init runs once, not that capability creation is restricted forever.", "recommendation": "Verify no other functions can create privileged capabilities. Use sui::types::is_one_time_witness(&witness) for runtime verification. Design capability creation to be strictly limited to init.", "remediation_status": "", "detection_cues": ["init", "OTW", "one-time witness", "AdminCap", "create_cap", "new_cap"], "suggested_checks": ["// Verify no functions besides init can create capabilities", "// Check OTW is consumed, not just passed"]}
{"id": "SUI-VULN-OTW-002", "project": "Sui-OTW-Security", "source_file": "sui-docs", "module_path": null, "function": null, "title": "OTW Type Definition Errors - Wrong Abilities or Fields", "severity": "medium", "issue_tags": ["otw", "abilities", "type_definition"], "description": "OTW type must have: only 'drop' ability, no other abilities, no fields (or single bool field), name matches module name in uppercase. Adding unnecessary abilities to witness type causes vulnerabilities. Incorrect OTW definition may not be detected as OTW by framework.", "recommendation": "Follow OTW rules exactly: struct MODULE_NAME has drop {}. Verify with sui::types::is_one_time_witness() at runtime.", "remediation_status": "", "detection_cues": ["has drop", "witness", "OTW", "MODULE_NAME", "uppercase"], "suggested_checks": ["assert!(types::is_one_time_witness(&witness), E_NOT_OTW);"]}
{"id": "SUI-VULN-SHARED-001", "project": "Sui-Shared-Object", "source_file": "movebit-objects", "module_path": null, "function": null, "title": "Shared Object Relationship Validation Missing", "severity": "high", "issue_tags": ["shared_object", "validation", "relationship", "cross_object"], "description": "When using multiple shared objects with dependencies between them, relationship validation is often missing. Example: whitelist not validated against launchpad allows users from other launchpads' whitelists to participate. Data inconsistency and attack vectors emerge from unvalidated object relationships.", "recommendation": "Always validate relationships between dependent shared objects. Check object IDs match expected values. Add assertions for cross-object consistency.", "remediation_status": "", "detection_cues": ["shared object", "whitelist", "launchpad", "relationship", "validation"], "suggested_checks": ["requires(whitelist.launchpad_id == object::id(launchpad));", "// Validate all shared object relationships"]}
{"id": "SUI-VULN-ENTRY-001", "project": "Sui-Entry-Function", "source_file": "slowmist-audit", "module_path": null, "function": null, "title": "Internal Functions Accidentally Exposed as Public Entry", "severity": "critical", "issue_tags": ["entry", "public", "access_control", "internal"], "description": "Functions that should be internal-only (e.g., direct deposit amount updates) accidentally exposed as public entry. Bypasses permission control leading to asset loss. In Sui, need to carefully review all public/entry functions for unintended external access.", "recommendation": "Review all function visibility. Mark internal functions as private or public(friend). Audit all public entry functions for privileged operations.", "remediation_status": "", "detection_cues": ["public entry", "entry fun", "public fun", "internal", "update_balance", "set_"], "suggested_checks": ["// Ensure privileged functions are not publicly accessible", "// Verify entry functions require proper authorization"]}
{"id": "SUI-VULN-UPGRADE-003", "project": "Sui-Package-Upgrade", "source_file": "sui-docs", "module_path": null, "function": null, "title": "Old Package Version Still Callable After Upgrade", "severity": "medium", "issue_tags": ["upgrade", "version", "immutable", "old_version"], "description": "Packages are immutable - old versions cannot be deleted and remain callable even after upgrade. Old versions may access objects used by new versions, breaking invariants new version maintains. Can introduce bugs when old version is unaware of new version's constraints.", "recommendation": "Design upgrade-safe invariants. Consider version checks in critical functions. Use make_immutable() to prevent upgrades if not needed. Document version compatibility requirements.", "remediation_status": "", "detection_cues": ["upgrade", "version", "immutable", "old version", "package"], "suggested_checks": ["requires(package_version >= MIN_SUPPORTED_VERSION);", "// Consider old version interactions in upgrade design"]}
{"id": "SUI-VULN-UPGRADE-004", "project": "Sui-Package-Upgrade", "source_file": "sui-docs", "module_path": null, "function": null, "title": "Single-Key UpgradeCap Risk - Centralization Vulnerability", "severity": "medium", "issue_tags": ["upgrade", "cap", "centralization", "governance"], "description": "Protecting upgrades with single private key poses risks: owner might make self-interested changes, upgrades might happen without community consultation, key might be lost. UpgradeCap ownership is critical security consideration.", "recommendation": "Use custom upgrade policies with multi-sig or governance. Consider make_immutable() for critical packages. Implement timelocks for upgrades. Document upgrade governance process.", "remediation_status": "", "detection_cues": ["UpgradeCap", "upgrade", "single key", "owner", "governance"], "suggested_checks": ["// Verify upgrade governance mechanism", "// Consider multi-sig for UpgradeCap"]}
{"id": "SUI-VULN-BRIDGE-001", "project": "Sui-Cross-Chain", "source_file": "movebit-bridge", "module_path": "vault", "function": "transferERC20", "title": "Cross-Chain Bridge USDT Incompatibility - Fund Freezing", "severity": "critical", "issue_tags": ["bridge", "cross_chain", "usdt", "erc20", "return_value"], "description": "Cross-chain bridge incompatible with non-standard ERC20 tokens like USDT that don't return boolean. vault.transferERC20() calls token.transfer() expecting boolean return, but USDT returns void. Withdrawal fails, causing permanent fund freezing. Discovered by MoveBit.", "recommendation": "Use OpenZeppelin's safeTransfer() for cross-chain fund withdrawals. Test with non-standard tokens (USDT, BNB). Handle void return values properly.", "remediation_status": "fixed", "detection_cues": ["transfer", "ERC20", "USDT", "bridge", "cross-chain", "boolean", "return value"], "suggested_checks": ["// Use safeTransfer for ERC20 operations", "// Test with non-standard tokens like USDT"]}
{"id": "SUI-VULN-LSD-001", "project": "Sui-Liquid-Staking", "source_file": "movebit-lsd", "module_path": null, "function": null, "title": "LST Exchange Rate Manipulation via Delayed Updates", "severity": "high", "issue_tags": ["lsd", "staking", "exchange_rate", "arbitrage"], "description": "Liquid staking exchange rate updates requiring near-real-time performance. Delays enable arbitrage exploits or unfair reward distribution. Users can exploit rate lag to stake/unstake at favorable rates.", "recommendation": "Implement real-time or epoch-based exchange rate updates. Add rate change limits. Consider MEV protection for rate-sensitive operations.", "remediation_status": "", "detection_cues": ["exchange_rate", "LST", "liquid staking", "rate", "update"], "suggested_checks": ["// Verify exchange rate freshness", "// Check for rate manipulation vectors"]}
{"id": "SUI-VULN-LSD-002", "project": "Sui-Liquid-Staking", "source_file": "movebit-lsd", "module_path": null, "function": null, "title": "LST Token Issuance Desync with Staking Activities", "severity": "high", "issue_tags": ["lsd", "staking", "token", "issuance", "desync"], "description": "LST token issuance/burning not properly synchronized with actual staking/unstaking activities. Can lead to token supply not matching underlying staked assets. Users might receive incorrect LST amounts or face withdrawal issues.", "recommendation": "Ensure atomic issuance/burning with staking operations. Implement invariant checks for LST supply vs staked assets. Add reconciliation mechanisms.", "remediation_status": "", "detection_cues": ["LST", "mint", "burn", "stake", "unstake", "supply"], "suggested_checks": ["ensures(lst_supply == total_staked_assets / exchange_rate);", "// Verify LST operations are atomic with staking"]}
{"id": "SUI-VULN-VALIDATOR-002", "project": "Sui-Staking", "source_file": "movebit-lsd", "module_path": null, "function": null, "title": "Validator Node Removal Without Fund Recovery Support", "severity": "medium", "issue_tags": ["staking", "validator", "removal", "recovery"], "description": "When issues are detected with staked validator node (e.g., removal from network), protocol may lack support for withdrawing funds and reselecting validator. Users' staked funds could be locked in problematic validator.", "recommendation": "Implement fund recovery mechanism for validator issues. Support validator reselection. Add emergency withdrawal paths. Monitor validator status.", "remediation_status": "", "detection_cues": ["validator", "removal", "recovery", "restake", "emergency"], "suggested_checks": ["// Verify validator issue handling mechanism", "// Check emergency withdrawal support"]}
{"id": "SUI-VULN-KIOSK-001", "project": "Sui-NFT-Kiosk", "source_file": "sui-kiosk", "module_path": null, "function": null, "title": "Missing kiosk_lock_rule Breaks Collection Tradability", "severity": "medium", "issue_tags": ["nft", "kiosk", "lock_rule", "tradability"], "description": "Without kiosk_lock_rule defined, users or marketplaces can remove items from kiosk, breaking trading across collection. Unlike other chains, Sui enforces royalties at protocol level, but incorrect kiosk setup can still cause issues.", "recommendation": "Always define kiosk_lock_rule for permanent tradability. Test NFT transfer flows across marketplaces. Verify TransferPolicy rules are correctly set.", "remediation_status": "", "detection_cues": ["kiosk", "lock_rule", "NFT", "transfer", "marketplace"], "suggested_checks": ["// Verify kiosk_lock_rule is defined for NFT collections"]}
{"id": "SUI-VULN-CLOCK-001", "project": "Sui-Clock", "source_file": "sui-docs", "module_path": null, "function": null, "title": "Clock Object Security - Immutable By Design", "severity": "info", "issue_tags": ["clock", "timestamp", "immutable", "security_feature"], "description": "Unlike Ethereum where miners can manipulate timestamps, Sui's Clock object (0x6) is immutable to user transactions - only updatable by system consensus. Transactions attempting mutable Clock access will fail. This is a security FEATURE, not vulnerability. Developers should use Clock for time-sensitive logic.", "recommendation": "Always use sui::clock for time-sensitive operations. Pass Clock as immutable reference. Don't create custom time sources.", "remediation_status": "", "detection_cues": ["clock", "timestamp", "0x6", "time"], "suggested_checks": ["// Use sui::clock::timestamp_ms(clock) for time", "// Never attempt mutable Clock access"]}
{"id": "AUDIT-CHECKLIST-001", "project": "Sui-Audit-Checklist", "source_file": "slowmist-movebit", "module_path": null, "function": null, "title": "Sui Move Security Audit Checklist - Key Focus Areas", "severity": "info", "issue_tags": ["audit", "checklist", "best_practice"], "description": "Key audit areas for Sui Move contracts: (1) Function visibility - ensure internal functions not publicly exposed, (2) Object access rights - review all shared object conversions, (3) Privileged functions - verify capability requirements, (4) Cross-module interactions - check state modification permissions, (5) Upgrade logic - review data migration safety, (6) OTW usage - verify one-time witness patterns, (7) Resource handling - ensure proper creation/destruction on all paths.", "recommendation": "Follow comprehensive audit checklist. Engage professional auditors. Test all edge cases. Document security assumptions.", "remediation_status": "", "detection_cues": ["audit", "checklist", "security review"], "suggested_checks": ["// Comprehensive security audit checklist for Sui Move"]}
{"id": "HUNT-VAULT-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "First Depositor / Vault Inflation Attack - Share Price Manipulation", "severity": "critical", "issue_tags": ["vault", "first_depositor", "inflation", "share", "rounding", "hunting"], "description": "Empty vaults vulnerable to share price manipulation. Attack: (1) Attacker deposits 1 wei, gets 1 share, (2) Attacker donates large amount directly to vault, (3) Victim deposits, receives 0 shares due to rounding, (4) Attacker withdraws all. Applies to any share-based system including Sui Move vaults. Check: Does vault use shares/assets ratio? Is there virtual offset protection?", "recommendation": "Use virtual shares/offset (OpenZeppelin approach). Track internal balance instead of balanceOf. Require minimum initial deposit. Add minimum shares check for deposits.", "remediation_status": "", "detection_cues": ["shares", "total_supply", "deposit", "mint", "balance", "vault", "empty"], "suggested_checks": ["requires(total_shares > 0 || deposit >= MIN_INITIAL_DEPOSIT);", "ensures(shares_received >= min_shares_out);", "// Virtual offset: include 1 virtual share and 1 virtual asset"]}
{"id": "HUNT-DONATION-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Donation Attack - Direct Token Transfer to Manipulate Exchange Rate", "severity": "high", "issue_tags": ["donation", "exchange_rate", "balance", "manipulation", "hunting"], "description": "Attacker sends tokens directly to vault/pool contract to inflate exchange rate without receiving shares. Subsequent depositors get fewer shares than expected. In Sui Move: Check if exchange rate uses coin::value(&vault.balance) which can be manipulated by direct transfer.", "recommendation": "Track internal balance on every operation instead of using actual balance. Or use virtual shares approach. Never trust external balance for critical calculations.", "remediation_status": "", "detection_cues": ["balance::value", "coin::value", "exchange_rate", "total_assets", "donation"], "suggested_checks": ["// Use internal tracking: vault.tracked_balance instead of balance::value", "// Or use virtual offset approach"]}
{"id": "HUNT-ORACLE-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Oracle Price Manipulation via Flash Loan / Low Liquidity", "severity": "critical", "issue_tags": ["oracle", "price", "flash_loan", "manipulation", "amm", "hunting"], "description": "Price from AMM spot price can be manipulated with flash loan. Attack: Flash borrow large amount, swap to move price, exploit protocol using manipulated price, reverse swap, repay. Check: Does protocol use spot price? Is there TWAP? Are there deviation checks?", "recommendation": "Never use spot AMM price for critical operations. Use TWAP with sufficient time window. Implement price deviation checks. Use multiple oracle sources. Add circuit breakers.", "remediation_status": "", "detection_cues": ["price", "oracle", "get_price", "spot_price", "reserve", "amm"], "suggested_checks": ["requires(abs(spot_price - twap_price) < MAX_DEVIATION);", "requires(clock::timestamp_ms(clock) - oracle.last_update < MAX_STALENESS);"]}
{"id": "HUNT-GOVERNANCE-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Governance Attack - Flash Loan Voting / Token Concentration", "severity": "high", "issue_tags": ["governance", "voting", "flash_loan", "timelock", "hunting"], "description": "Attacker uses flash loan or concentrated tokens to pass malicious proposals. Can bypass timelock via emergency mechanisms. Check: Is voting power snapshot-based? Are there anti-flash-loan protections? Is timelock enforced?", "recommendation": "Use snapshot-based voting at proposal creation. Add minimum delay between proposal and voting. Implement quorum requirements. Enforce timelock without bypass. Consider vote escrow mechanisms.", "remediation_status": "", "detection_cues": ["vote", "proposal", "governance", "quorum", "timelock", "emergency"], "suggested_checks": ["requires(voting_power_at_snapshot(proposer) >= MIN_PROPOSAL_THRESHOLD);", "requires(block_delay >= MIN_VOTING_DELAY);"]}
{"id": "HUNT-PARAM-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Input Parameter Validation Bypass - Unchecked User Input", "severity": "critical", "issue_tags": ["input", "validation", "parameter", "bypass", "hunting"], "description": "Function parameters not validated before processing. Example: _repayAmount not checked allows transferring borrowed assets without triggering repayment. In Sui Move: Check all public entry function parameters for bounds and sanity checks.", "recommendation": "Validate ALL input parameters at function entry. Check bounds, non-zero, type correctness. Use assertions liberally. Never trust user input.", "remediation_status": "", "detection_cues": ["public entry", "entry fun", "amount", "parameter", "user input"], "suggested_checks": ["requires(amount > 0 && amount <= MAX_AMOUNT);", "requires(recipient != @0x0);", "// Validate all parameters before processing"]}
{"id": "HUNT-REWARD-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Reward Distribution Manipulation - Unfair Incentive Extraction", "severity": "high", "issue_tags": ["reward", "incentive", "distribution", "manipulation", "hunting"], "description": "Exploiting reward calculation logic to extract disproportionate incentives. Examples: overly generous price thresholds, time-weighted calculation gaming, reward claiming without proper stake. Check: Can rewards be claimed multiple times? Is timing exploitable?", "recommendation": "Use accurate time-weighted calculations. Prevent multiple claims. Add minimum stake duration. Implement reward caps. Verify stake exists before distribution.", "remediation_status": "", "detection_cues": ["reward", "claim", "distribute", "incentive", "stake", "time_weighted"], "suggested_checks": ["requires(last_claim_time + MIN_CLAIM_INTERVAL <= current_time);", "ensures(reward <= MAX_REWARD_PER_EPOCH);"]}
{"id": "HUNT-READONLY-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Read-Only Reentrancy - View Function State Inconsistency", "severity": "high", "issue_tags": ["reentrancy", "view", "readonly", "cross_contract", "hunting"], "description": "View functions return inconsistent data during state transitions. In Solidity: get_virtual_price exploited during remove_liquidity. In Sui Move: Check if view functions read state that could be mid-transition during cross-module calls. Move eliminates classic reentrancy but cross-module state reading could be vulnerable.", "recommendation": "In Sui Move: Be cautious with cross-module reads during state changes. Use internal state tracking. Consider state consistency checks.", "remediation_status": "", "detection_cues": ["get_price", "get_balance", "view", "cross_module", "state read"], "suggested_checks": ["// Ensure view functions return consistent state", "// Consider state locks for multi-step operations"]}
{"id": "HUNT-PRECISION-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Precision Loss Accumulation - Rounding Error Exploitation", "severity": "high", "issue_tags": ["precision", "rounding", "accumulation", "fee", "hunting"], "description": "Small rounding errors accumulate over many operations to significant losses. Division before multiplication, fee calculations rounding to zero, interest accrual precision loss. In Sui Move: Move has no floats, all division truncates. Check all arithmetic for precision issues.", "recommendation": "Multiply before divide. Use higher precision intermediates (u128/u256). Set minimum thresholds. Round in protocol's favor for fees. Track accumulated errors.", "remediation_status": "", "detection_cues": ["/", "fee", "interest", "precision", "decimal", "truncate"], "suggested_checks": ["// Order: multiply first, then divide", "ensures(fee > 0 || amount < MIN_FEE_THRESHOLD);"]}
{"id": "HUNT-ACCESS-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Missing Access Control - Unprotected Sensitive Functions", "severity": "critical", "issue_tags": ["access_control", "admin", "capability", "unprotected", "hunting"], "description": "Sensitive functions (withdraw, set parameters, pause) lack proper authorization. In Sui Move: Check all public/entry functions for capability requirements. Look for functions that modify critical state without AdminCap or similar.", "recommendation": "Require capability for all sensitive operations. Use Sui's capability pattern. Never expose admin functions as public without cap check.", "remediation_status": "", "detection_cues": ["withdraw", "set_", "update_", "pause", "admin", "public fun"], "suggested_checks": ["requires(object::owner(admin_cap) == tx_context::sender(ctx));", "// All sensitive functions must require capability"]}
{"id": "HUNT-SLIPPAGE-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Missing Slippage Protection - Sandwich Attack Vulnerability", "severity": "high", "issue_tags": ["slippage", "sandwich", "mev", "swap", "hunting"], "description": "Swap/trade functions without min_amount_out allow sandwich attacks. Attacker front-runs victim's trade, moves price, victim gets worse rate, attacker back-runs for profit. In Sui Move: Check all swap functions for slippage parameters.", "recommendation": "Always require min_amount_out parameter. Add deadline parameter. Consider using private mempools or commit-reveal schemes.", "remediation_status": "", "detection_cues": ["swap", "trade", "exchange", "min_amount_out", "deadline"], "suggested_checks": ["requires(amount_out >= min_amount_out, E_SLIPPAGE);", "requires(clock::timestamp_ms(clock) <= deadline, E_EXPIRED);"]}
{"id": "HUNT-LIQUIDATION-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Liquidation Logic Flaws - Self-Liquidation / Bad Debt", "severity": "high", "issue_tags": ["liquidation", "collateral", "bad_debt", "lending", "hunting"], "description": "Lending protocol liquidation issues: self-liquidation for profit, insufficient liquidation incentive, bad debt accumulation, liquidation frontrunning. Check: Can users liquidate themselves? Is liquidation bonus reasonable? What happens with underwater positions?", "recommendation": "Prevent self-liquidation. Set appropriate liquidation incentives. Implement bad debt socialization. Add liquidation delays or randomization.", "remediation_status": "", "detection_cues": ["liquidate", "collateral", "health_factor", "debt", "underwater"], "suggested_checks": ["requires(liquidator != borrower, E_SELF_LIQUIDATION);", "requires(health_factor < LIQUIDATION_THRESHOLD);"]}
{"id": "HUNT-FLASHLOAN-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Flash Loan Integration Risks - Amplified Attack Vectors", "severity": "high", "issue_tags": ["flash_loan", "amplification", "integration", "hunting"], "description": "Flash loans amplify other vulnerabilities: oracle manipulation, governance attacks, arbitrage exploitation. Check: Does protocol integrate with flash loan providers? Can operations be executed atomically that shouldn't be?", "recommendation": "Add flash loan detection where needed. Implement operation cooldowns. Use snapshot-based values. Consider flash loan fees.", "remediation_status": "", "detection_cues": ["flash", "borrow", "loan", "callback", "atomic"], "suggested_checks": ["// Consider flash loan scenarios in all economic calculations"]}
{"id": "HUNT-UPGRADE-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Uninitialized/Upgradeable Contract State - Migration Vulnerabilities", "severity": "high", "issue_tags": ["upgrade", "initialization", "migration", "state", "hunting"], "description": "Critical state variables uninitialized or improperly migrated during upgrades. In Sui Move: init only runs once on first publish. Check upgrade migration logic. Are all state variables properly initialized?", "recommendation": "Verify all state initialized before use. Test upgrade migrations thoroughly. Consider version checks in functions.", "remediation_status": "", "detection_cues": ["init", "upgrade", "migration", "version", "uninitialized"], "suggested_checks": ["requires(is_initialized == true);", "requires(version >= MIN_SUPPORTED_VERSION);"]}
{"id": "HUNT-EXTERNAL-001", "project": "VulnHunting-DeFi", "source_file": "hunting-methodology", "module_path": null, "function": null, "title": "Arbitrary External Calls - Unvalidated Cross-Module Interactions", "severity": "critical", "issue_tags": ["external", "cross_module", "callback", "untrusted", "hunting"], "description": "Unvalidated external contract/module calls execute malicious operations. In Solidity: arbitrary calldata. In Sui Move: Check cross-module calls for proper validation. Are module addresses hardcoded or user-provided?", "recommendation": "Validate all external call targets. Use whitelists for allowed modules. Validate callback data. Never execute arbitrary user-provided addresses.", "remediation_status": "", "detection_cues": ["call", "external", "callback", "module", "address"], "suggested_checks": ["requires(target_module in ALLOWED_MODULES);", "// Validate all cross-module call parameters"]}
{"id": "SUI-PROVER-001", "title": "Move Prover Specification Inconsistency - False Verification", "severity": "high", "category": "formal_verification", "description": "Move Prover may accept buggy code as correct if specifications contain inconsistencies. Functions that always abort can make any postcondition vacuously true, leading to false positives.", "detection_cues": ["spec", "ensures", "requires", "abort"], "recommendation": "Enable `--check-inconsistency` and `--unconditional-abort-as-inconsistency` flags. Have specification reviewers verify specs independently.", "sui_move_applicable": true, "source": "CertiK Move Prover Quality Assurance"}
{"id": "SUI-CAP-SHARE-001", "title": "AdminCap Shared via public_share_object - Everyone Becomes Admin", "severity": "critical", "category": "access_control", "description": "AdminCap or other capability objects mistakenly shared using transfer::share_object() instead of transfer::transfer(). This makes the capability globally accessible, allowing anyone to call admin functions.", "detection_cues": ["AdminCap", "share_object", "public_share_object", "init"], "code_pattern": "transfer::share_object(admin_cap)", "recommendation": "Use transfer::transfer(admin_cap, tx_context::sender(ctx)) for capabilities. Only use share_object for intentionally shared resources.", "sui_move_applicable": true, "source": "Mirage Audits - Sui Move Ability Mistakes"}
{"id": "SUI-PTB-GAS-001", "title": "PTB Gas Exhaustion Attack - Selective Reversion", "severity": "medium", "category": "denial_of_service", "description": "Attacker controls gas budget to selectively revert transactions. By providing gas sufficient for 'happy path' but not 'unhappy path', attacker can ensure winning outcomes while reverting losing ones.", "detection_cues": ["gas", "abort", "assert", "if", "else"], "recommendation": "Design functions to have consistent gas costs across all code paths. Consider flat gas requirements for critical operations.", "sui_move_applicable": true, "source": "Sui Documentation - Gas-Based Exploits"}
{"id": "SUI-PTB-RANDOM-001", "title": "PTB Randomness Composition Attack Bypass", "severity": "high", "category": "randomness", "description": "While Sui rejects PTBs with commands after MoveCall using Random, attackers may still exploit by splitting logic across multiple transactions. First tx stores random value, second tx uses it.", "detection_cues": ["Random", "random", "sui::random", "store"], "recommendation": "Store random values in objects unreadable by other commands. Use commit-reveal patterns for sensitive random operations.", "sui_move_applicable": true, "source": "Sui Documentation - On-Chain Randomness"}
{"id": "SUI-EQUIVOCATION-001", "title": "Owned Object Equivocation - Object Lock DoS", "severity": "high", "category": "denial_of_service", "description": "Using same owned object (ObjectId, SequenceNumber) in multiple non-finalized transactions causes equivocation. Objects become locked until epoch end, enabling DoS attacks on dApps.", "detection_cues": ["owned", "transfer", "concurrent", "parallel"], "recommendation": "Use Sui_Owned_Object_Pools library or ParallelTransactionExecutor. Consider shared object wrappers for high-concurrency scenarios.", "sui_move_applicable": true, "source": "MystenLabs - Sui Owned Object Pools"}
{"id": "SUI-SHARED-CHILD-001", "title": "Effectively Shared Object DDoS via Child Objects", "severity": "medium", "category": "denial_of_service", "description": "Child objects of shared objects are owned but accessible by anyone. Attackers can spam function calls on these 'hot' objects to create congestion and delay legitimate transactions during consensus.", "detection_cues": ["shared", "child", "dynamic_field", "borrow_mut"], "recommendation": "Minimize mutable operations on shared object children. Use rate limiting or access control for sensitive child objects.", "sui_move_applicable": true, "source": "Sui Developer Forum - Shared Custody"}
{"id": "SUI-ENTRY-FLASH-001", "title": "Entry Function Prevents Flash Loan Abuse", "severity": "advisory", "category": "design_pattern", "description": "Using 'entry' modifier prevents function from receiving results of previous PTB commands, blocking flash loan integration. Useful for swap protocols that shouldn't interact with borrowed funds.", "detection_cues": ["entry", "public fun", "Coin", "swap"], "recommendation": "Use 'entry' for functions that should not receive flash loaned assets. Use 'public' when cross-module calls are needed.", "sui_move_applicable": true, "source": "Sui Documentation - Entry Functions"}
{"id": "SUI-KIOSK-CAP-001", "title": "Kiosk NFT TransferPolicy Bypass via KioskOwnerCap Transfer", "severity": "high", "category": "nft_security", "description": "With 1 NFT per Kiosk pattern, transferring KioskOwnerCap instead of the NFT bypasses creator-defined TransferPolicy rules (royalties, restrictions).", "detection_cues": ["Kiosk", "KioskOwnerCap", "TransferPolicy", "NFT"], "recommendation": "Always define kiosk_lock_rule to prevent item removal. Place NFTs directly into user Kiosk during mint. Consider personal kiosks for additional protection.", "sui_move_applicable": true, "source": "Sui Developer Forum - Bypassing Kiosk Rules"}
{"id": "SUI-REF-VERIFY-001", "title": "Move Reference Safety Verification Bypass", "severity": "critical", "category": "vm_security", "description": "Vulnerabilities in Move's reference safety verification module can allow bypassing boundary checks. Attackers may obtain multiple mutable references or retain references to moved objects.", "detection_cues": ["borrow_mut", "&mut", "reference", "move"], "recommendation": "Keep Move VM updated to latest version. This is a system-level vulnerability fixed by Sui core team.", "sui_move_applicable": true, "source": "Numen Cyber Labs - Move Reference Safety Bug"}
{"id": "SUI-DEX-PAUSE-001", "title": "DEX Missing Pause State Validation", "severity": "high", "category": "business_logic", "description": "Swap functions may not check if liquidity pool is paused. Users can continue trading even when pool should be frozen (during emergency, exploit mitigation).", "detection_cues": ["swap", "paused", "is_paused", "emergency"], "recommendation": "Check pause state at beginning of all swap/liquidity functions. Implement circuit breaker pattern for emergency stops.", "sui_move_applicable": true, "source": "Sui DEX Audit Common Findings"}
{"id": "SUI-WITNESS-ABILITY-001", "title": "Witness Type with Unnecessary Abilities", "severity": "medium", "category": "type_safety", "description": "Adding unnecessary abilities (copy, store, key) to witness types can cause security issues. Witness should only have 'drop' ability to ensure one-time use.", "detection_cues": ["witness", "has copy", "has store", "has key", "OTW"], "recommendation": "Witness types should only have 'drop' ability. Remove any additional abilities that could allow reuse or storage.", "sui_move_applicable": true, "source": "Sui Move Intro Course - Witness Pattern"}
{"id": "SUI-EVENT-STORE-001", "title": "Event Type with Redundant store Ability", "severity": "low", "category": "code_quality", "description": "Event types passed to sui::event::emit only need 'copy' and 'drop' abilities. Adding 'store' is redundant and may indicate misunderstanding of event lifecycle.", "detection_cues": ["event", "emit", "has store", "has copy", "has drop"], "recommendation": "Event types should only have 'copy' and 'drop' abilities per sui::event requirements.", "sui_move_applicable": true, "source": "Sui Event Module Documentation"}
{"id": "SUI-U256-TRUNCATE-001", "title": "DEX u256 to u64 Truncation in Price Calculation", "severity": "critical", "category": "arithmetic", "description": "Converting u256 calculation results to u64 can silently truncate values exceeding MAX_U64, causing incorrect prices or amounts in large transactions.", "detection_cues": ["as u64", "u256", "price", "amount", "calculate"], "recommendation": "Validate u256 value fits in u64 before casting: assert!(value <= MAX_U64). Consider keeping calculations in u256 throughout.", "sui_move_applicable": true, "source": "Sui DEX Audit - Cetus Related Findings"}
{"id": "SUI-COIN-COPY-001", "title": "Token Type with copy Ability - Double Spend", "severity": "critical", "category": "token_security", "description": "Adding 'copy' ability to token/coin types allows unlimited duplication, enabling double-spending and infinite token inflation.", "detection_cues": ["Coin", "Token", "has copy", "Balance"], "recommendation": "Token types must NEVER have 'copy' ability. Use only 'key' and 'store' for transferable assets.", "sui_move_applicable": true, "source": "CertiK - Move Security Best Practices"}
{"id": "SUI-FLASH-DROP-001", "title": "Flash Loan Receipt with drop Ability - Non-Repayment", "severity": "critical", "category": "defi_security", "description": "If flash loan receipt struct has 'drop' ability, borrowers can destroy it without repayment. Hot potato pattern requires receipt to be consumed by repay function.", "detection_cues": ["FlashLoan", "Receipt", "has drop", "borrow", "repay"], "recommendation": "Flash loan receipt must have NO abilities (hot potato). Force consumption through repay function only.", "sui_move_applicable": true, "source": "Zellic - Move Security Primer"}
{"id": "MOVESCAN-RES-001", "title": "Resource Leak - Unconsomed Resource on Execution Path", "severity": "high", "category": "resource_safety", "description": "Resources created but not properly consumed (transferred, destroyed, or stored) on all execution paths. MoveScanner found 0.4% of mainnet contracts have this issue.", "detection_cues": ["let", "Coin", "Balance", "return", "abort", "if"], "recommendation": "Ensure all resources are handled on every execution path. Use hot potato pattern or explicit destroy functions.", "sui_move_applicable": true, "source": "MoveScanner arXiv:2508.17964"}
{"id": "MOVESCAN-RET-001", "title": "Unchecked Return Value - Ignored Function Results", "severity": "medium", "category": "code_quality", "description": "Function return values not properly handled, especially Boolean or Option returns. 9.8% of mainnet contracts have this issue. May hide failures or unexpected states.", "detection_cues": ["let _", "option::", "bool", "result"], "recommendation": "Always check return values. Use pattern matching for Option types. Handle all possible return cases.", "sui_move_applicable": true, "source": "MoveScanner arXiv:2508.17964"}
{"id": "MOVESCAN-CROSS-001", "title": "Cross-Module State Pollution - Uncontrolled Global State Modification", "severity": "high", "category": "access_control", "description": "Public functions that modify other modules' global state without proper access control. 18.5% of mainnet vulnerabilities. Enables unauthorized state changes.", "detection_cues": ["public fun", "borrow_global_mut", "&mut", "external"], "recommendation": "Add capability checks for cross-module state modifications. Use friend visibility where appropriate.", "sui_move_applicable": true, "source": "MoveScanner arXiv:2508.17964"}
{"id": "MOVESCAN-PRIV-001", "title": "Privilege Leakage - Capability Resource Exposure", "severity": "critical", "category": "access_control", "description": "Capability resources transferred to untrusted recipients or exposed via public functions. 10% of mainnet vulnerabilities. Enables privilege escalation.", "detection_cues": ["Cap", "transfer", "public fun", "return"], "recommendation": "Never expose capabilities in public function returns. Validate recipients before capability transfers.", "sui_move_applicable": true, "source": "MoveScanner arXiv:2508.17964"}
{"id": "SUI-UPGRADE-KEY-001", "title": "Single-Key UpgradeCap Risk - Centralized Upgrade Control", "severity": "medium", "category": "governance", "description": "Package upgrade capability controlled by single private key creates centralization risks: key compromise, unilateral changes without community input, key loss.", "detection_cues": ["UpgradeCap", "upgrade", "sui::package"], "recommendation": "Use multi-sig governance for UpgradeCap. Consider time-locks for upgrades. Make package immutable when mature.", "sui_move_applicable": true, "source": "Sui Documentation - Custom Upgrade Policies"}
{"id": "SUI-PUBLIC-FRIEND-001", "title": "Internal Function Exposed via public(friend) Misuse", "severity": "high", "category": "visibility", "description": "Functions intended for internal use accidentally exposed through overly permissive friend declarations. Move 2024 replaces with public(package) for better scoping.", "detection_cues": ["public(friend)", "friend", "internal"], "recommendation": "Use public(package) in Move 2024. Audit all friend declarations. Minimize friend scope.", "sui_move_applicable": true, "source": "SlowMist Sui Move Audit Guidelines"}
{"id": "SUI-TYPUS-AUTH-001", "title": "Oracle Update Function Missing Authorization - Typus Exploit Pattern", "severity": "critical", "category": "access_control", "description": "Oracle update functions without authorization checks allow anyone to manipulate prices. Typus Finance lost $3.44M due to missing assert in update_v2 function.", "detection_cues": ["update", "oracle", "price", "public fun"], "recommendation": "Add capability requirements to all oracle update functions. Use established oracle providers. Include all modules in audit scope.", "sui_move_applicable": true, "source": "Typus Finance Exploit October 2025"}
{"id": "SUI-MATH-LIB-001", "title": "Third-Party Math Library Vulnerability - Cetus Pattern", "severity": "critical", "category": "dependency", "description": "Vulnerabilities in shared math libraries can affect multiple protocols. Cetus lost $223M due to flawed checked_shlw in dependency. Multiple audits failed to detect.", "detection_cues": ["use", "math", "lib", "checked", "external"], "recommendation": "Audit all dependencies including math libraries. Test edge cases with extreme values. Consider formal verification for math functions.", "sui_move_applicable": true, "source": "Cetus Protocol Exploit May 2025"}
{"id": "SUI-VECTOR-BOUND-001", "title": "Vector Out-of-Bounds Access - Array Index Overflow", "severity": "high", "category": "runtime_safety", "description": "Accessing vector elements without bounds checking can cause runtime aborts. Unlike some languages, Move does check bounds but aborts ungracefully.", "detection_cues": ["vector", "borrow", "borrow_mut", "[", "]"], "recommendation": "Use vector::length() checks before access. Consider vector::borrow_with_default or Option returns for safe access.", "sui_move_applicable": true, "source": "Move Security Best Practices"}
{"id": "SUI-DIV-ZERO-001", "title": "Division by Zero - Unguarded Denominator", "severity": "high", "category": "arithmetic", "description": "Division operations where denominator can be zero cause runtime aborts. Common in share calculations when pool is empty or total supply is zero.", "detection_cues": ["/", "total_supply", "total_shares", "denominator"], "recommendation": "Add zero checks before division: assert!(denominator > 0, E_DIV_ZERO). Handle empty pool edge cases explicitly.", "sui_move_applicable": true, "source": "DeFi Audit Common Findings"}
{"id": "SUI-LOOP-GAS-001", "title": "Unbounded Loop Gas Exhaustion", "severity": "medium", "category": "denial_of_service", "description": "Loops iterating over user-controlled data can exhaust gas limits. Attackers can grow arrays to make transactions fail or become expensive.", "detection_cues": ["while", "loop", "vector", "length", "for"], "recommendation": "Limit loop iterations with maximum bounds. Use pagination for large datasets. Consider off-chain processing for unbounded operations.", "sui_move_applicable": true, "source": "Smart Contract Gas Vulnerabilities"}
{"id": "SUI-TIMESTAMP-DRIFT-001", "title": "Clock Timestamp Reliance Without Buffer", "severity": "low", "category": "time_dependency", "description": "Relying on exact timestamps without buffers. Sui Clock updates every ~250ms with consensus, but exact timing depends on network conditions.", "detection_cues": ["Clock", "timestamp_ms", "deadline", "expire"], "recommendation": "Use grace periods in time comparisons. Allow buffer for timestamp variations. Don't rely on exact second precision.", "sui_move_applicable": true, "source": "Sui Clock Module Documentation"}
{"id": "MOVE24-ENUM-001", "title": "Enum Match Non-Exhaustive with Guard Expression", "severity": "medium", "category": "move_2024", "description": "When using guard expressions in match, a default case is required. Adding new enum variants later won't trigger compiler errors, potentially missing handling for new cases.", "detection_cues": ["match", "if", "guard", "enum", "_"], "recommendation": "Avoid guard expressions when possible. If used, add comments documenting all expected variants. Review match expressions when adding enum variants.", "sui_move_applicable": true, "source": "Move Book - Enums and Match"}
{"id": "MOVE24-ENUM-002", "title": "Wildcard Pattern Masking New Enum Variants", "severity": "medium", "category": "move_2024", "description": "Using wildcard (_) in match expressions prevents compiler warnings when new enum variants are added. Logic for new variants silently falls through to default case.", "detection_cues": ["match", "_", "=>", "enum"], "recommendation": "Explicitly match all known variants before using wildcard. Document expected behavior for unknown variants.", "sui_move_applicable": true, "source": "Move 2024 Edition Documentation"}
{"id": "MOVE24-MACRO-001", "title": "Macro Lambda Scope Confusion", "severity": "low", "category": "move_2024", "description": "While Move macros are hygienic, developers may be confused by lambda parameter scoping. Variables in lambda are distinct from same-named variables in macro body.", "detection_cues": ["macro", "!", "|", "lambda"], "recommendation": "Use distinct variable names in lambdas. Understand hygiene: macro body and lambda have separate scopes.", "sui_move_applicable": true, "source": "Move 2024 Macro Functions Guide"}
{"id": "MOVE24-MACRO-002", "title": "Macro Argument Not Evaluated When Branch Not Taken", "severity": "low", "category": "move_2024", "description": "Macro arguments are substituted, not evaluated. If argument is in unreached branch, side effects won't occur. Different from regular function call semantics.", "detection_cues": ["macro", "!", "if", "else"], "recommendation": "Don't rely on macro argument side effects for control flow. Understand substitution vs evaluation semantics.", "sui_move_applicable": true, "source": "Move 2024 Macro Functions Guide"}
{"id": "MOVE24-MUT-001", "title": "Missing let mut for Mutable Variables", "severity": "low", "category": "move_2024", "description": "Move 2024 requires explicit 'let mut' for mutable variables. Migration from older code may miss mutation points, causing compile errors or incorrect immutable usage.", "detection_cues": ["let", "mut", "="], "recommendation": "Use 'sui move migrate' for automatic migration. Review all variable mutations after migration.", "sui_move_applicable": true, "source": "Move 2024 Migration Guide"}
{"id": "MOVE24-PKG-001", "title": "public(package) Replaces public(friend) - Scope Change", "severity": "low", "category": "move_2024", "description": "public(package) automatically allows all modules in same package, unlike public(friend) which required explicit declarations. May unintentionally expose functions to more modules.", "detection_cues": ["public(package)", "public(friend)", "friend"], "recommendation": "Audit which modules can access public(package) functions. Consider if broader access is intended.", "sui_move_applicable": true, "source": "Move 2024 Migration Guide"}
{"id": "MOVE24-METHOD-001", "title": "Method Syntax Auto-Borrowing Confusion", "severity": "low", "category": "move_2024", "description": "Method syntax automatically borrows receiver (&self or &mut self). Developers may not realize mutation is occurring when using obj.method() syntax.", "detection_cues": [".", "()", "self", "&mut"], "recommendation": "Check function signatures for &mut receivers. Understand auto-borrowing semantics.", "sui_move_applicable": true, "source": "Move 2024 Method Syntax"}
{"id": "MOVE24-INDEX-001", "title": "Index Syntax #[syntax(index)] Bounds Not Visible", "severity": "medium", "category": "move_2024", "description": "Using v[i] index syntax hides underlying bounds checking. Developers may assume safe access without realizing potential abort on out-of-bounds.", "detection_cues": ["[", "]", "#[syntax(index)]"], "recommendation": "Check length before index access. Understand that v[i] can abort. Consider using get_with_default patterns.", "sui_move_applicable": true, "source": "Move 2024 Index Syntax"}
{"id": "MOVE24-LOOP-001", "title": "Loop Label Break Value Type Mismatch", "severity": "medium", "category": "move_2024", "description": "Named loops with break values must have consistent types across all break points. Complex nested loops may have type mismatches that are hard to track.", "detection_cues": ["'label:", "break", "loop", "while"], "recommendation": "Ensure all break points return same type. Use explicit type annotations on loop expressions.", "sui_move_applicable": true, "source": "Move 2024 Loop Labels"}
{"id": "MOVE24-POSITIONAL-001", "title": "Positional Field Access Index Confusion", "severity": "low", "category": "move_2024", "description": "Structs with positional fields (p.0, p.1) may cause confusion about field ordering. Refactoring field order silently changes access semantics.", "detection_cues": [".0", ".1", ".2", "struct", "("], "recommendation": "Consider named fields for structs with more than 2 fields. Document field ordering clearly.", "sui_move_applicable": true, "source": "Move 2024 Positional Fields"}
{"id": "SUI-ZKLOGIN-KEY-001", "title": "zkLogin Ephemeral Key Exposure", "severity": "critical", "category": "authentication", "description": "If both ephemeral private key and ZK proof are exposed, attacker can sign transactions on behalf of user. Ephemeral key must be treated as secret.", "detection_cues": ["zkLogin", "ephemeral", "key", "proof"], "recommendation": "Never store ephemeral keys in insecure storage. Regenerate keys regularly. Don't expose proofs unnecessarily.", "sui_move_applicable": true, "source": "Sui zkLogin Documentation"}
{"id": "SUI-ZKLOGIN-JWT-001", "title": "zkLogin JWT Token Leakage - Privacy Risk", "severity": "high", "category": "authentication", "description": "Leaked JWT tokens reveal sensitive information (username, email). Combined with salt compromise, enables account takeover.", "detection_cues": ["JWT", "token", "OAuth", "OIDC"], "recommendation": "Protect JWT tokens in transit and storage. Use short-lived tokens. Implement proper logout flows.", "sui_move_applicable": true, "source": "Sui zkLogin Security"}
{"id": "SUI-ZKLOGIN-SALT-001", "title": "zkLogin Salt Compromise Enables Account Takeover", "severity": "critical", "category": "authentication", "description": "User salt combined with compromised OAuth account allows transaction signing. Salt must be kept secret and unique per user.", "detection_cues": ["salt", "zkLogin", "user_salt"], "recommendation": "Generate unique salts per user. Store salts securely. Consider salt derivation from secure sources.", "sui_move_applicable": true, "source": "Sui zkLogin Documentation"}
{"id": "SUI-ZKLOGIN-QUANTUM-001", "title": "zkLogin Quantum Vulnerability - Groth16 and RSA", "severity": "advisory", "category": "cryptography", "description": "zkLogin uses Groth16 proofs over RSA-signed JWTs. Both are vulnerable to quantum attacks. Long-term security may require migration.", "detection_cues": ["zkLogin", "Groth16", "RSA", "quantum"], "recommendation": "Monitor post-quantum cryptography developments. Plan for potential algorithm migration.", "sui_move_applicable": true, "source": "Sui Post-Quantum Security Blog"}
{"id": "SUI-MULTISIG-THRESH-001", "title": "Multisig Threshold Misconfiguration", "severity": "high", "category": "governance", "description": "Incorrect threshold settings (too low or equal to total keys) create security risks. Threshold=1 defeats purpose; threshold=total requires all signers.", "detection_cues": ["MultiSig", "threshold", "weight"], "recommendation": "Set threshold appropriately (e.g., 2-of-3, 3-of-5). Document key holder responsibilities. Test recovery scenarios.", "sui_move_applicable": true, "source": "Sui Multisig Documentation"}
{"id": "SUI-GROTH16-SETUP-001", "title": "Groth16 Trusted Setup Ceremony Required", "severity": "critical", "category": "zk_security", "description": "Groth16 requires trusted setup per circuit. Using randomly generated keys instead of ceremony-generated keys is insecure and allows proof forgery.", "detection_cues": ["Groth16", "verify", "setup", "ceremony", "vk"], "recommendation": "Always use ceremony-generated proving/verification keys. Never use randomly generated keys in production.", "sui_move_applicable": true, "source": "Sui Groth16 Documentation"}
{"id": "SUI-GROTH16-VK-001", "title": "Groth16 Verification Key Not Prepared", "severity": "medium", "category": "zk_security", "description": "Sui's Groth16 API expects prepared verification key. Using unprepared key or re-preparing every verification wastes gas and may cause issues.", "detection_cues": ["prepare_verifying_key", "groth16", "verify"], "recommendation": "Prepare verification key once per circuit using sui::groth16::prepare_verifying_key. Store prepared key for reuse.", "sui_move_applicable": true, "source": "Sui Groth16 Documentation"}
{"id": "SUI-GROTH16-INPUT-001", "title": "Groth16 Public Input Limit (8 inputs)", "severity": "medium", "category": "zk_security", "description": "Sui's Groth16 API supports up to 8 public inputs. Circuits requiring more inputs need redesign or input compression.", "detection_cues": ["groth16", "public_inputs", "verify"], "recommendation": "Design circuits with 8 or fewer public inputs. Use hashing to compress multiple inputs if needed.", "sui_move_applicable": true, "source": "Sui Groth16 Documentation"}
{"id": "AI-CODE-HALLUCINATION-001", "title": "AI-Generated Code Hallucinated Vulnerabilities (False Positives)", "severity": "advisory", "category": "ai_security", "description": "LLM-based auditing tools may report ~10% hallucinated vulnerabilities that don't exist. Over-reliance on AI findings without verification wastes resources.", "detection_cues": ["AI", "LLM", "audit", "vulnerability"], "recommendation": "Always verify AI-reported vulnerabilities manually. Use AI as augmentation, not replacement for human review.", "sui_move_applicable": true, "source": "LLM-SmartAudit Research"}
{"id": "AI-CODE-HIDDEN-001", "title": "AI-Generated Smart Contract Hidden Flaws", "severity": "high", "category": "ai_security", "description": "AI-generated contract code may contain subtle vulnerabilities that pass human audits. Studies show AI agents can autonomously find and exploit such flaws.", "detection_cues": ["generated", "AI", "LLM", "ChatGPT", "Copilot"], "recommendation": "Apply extra scrutiny to AI-generated code. Use multiple audit methods. Test extensively with edge cases.", "sui_move_applicable": true, "source": "AI Smart Contract Security Research"}
{"id": "AI-CODE-OVERRELIANCE-001", "title": "Over-Reliance on AI Security Audits", "severity": "medium", "category": "ai_security", "description": "AI audit tools have limitations: context-dependent vulnerabilities, hallucinations, and inability to understand business logic fully. Sole reliance on AI is risky.", "detection_cues": ["automated", "scan", "AI", "audit"], "recommendation": "Combine AI scanning with manual expert review. Use AI for initial triage, humans for final verification.", "sui_move_applicable": true, "source": "Smart Contract AI Audit Best Practices"}
{"id": "SUI-SPONSORED-001", "title": "Sponsored Transaction Gas Manipulation", "severity": "medium", "category": "transaction", "description": "Sponsor pays gas but user controls transaction content. Malicious users may craft expensive transactions or exploit sponsor's gas budget.", "detection_cues": ["sponsor", "gas", "GasData", "sponsored"], "recommendation": "Set gas limits on sponsored transactions. Validate transaction content before sponsoring. Implement rate limiting.", "sui_move_applicable": true, "source": "Sui Sponsored Transaction Security"}
{"id": "SUI25-WALRUS-001", "title": "Walrus Blob Storage Access Control Misconfiguration", "severity": "high", "category": "storage_security", "description": "Walrus stores data across distributed nodes. Without proper Seal encryption and access control, sensitive data may be accessible to unauthorized parties.", "detection_cues": ["walrus", "blob", "store", "storage"], "recommendation": "Use Seal for encryption before storing sensitive data on Walrus. Define clear access policies. Never store plaintext secrets.", "sui_move_applicable": true, "source": "Walrus 2025 Documentation"}
{"id": "SUI25-WALRUS-002", "title": "Walrus Data Availability Assumption", "severity": "medium", "category": "storage_security", "description": "Walrus uses 2D erasure coding (RedStuff) requiring ~1/3 of shards. If more than 2/3 nodes are unavailable, data cannot be recovered.", "detection_cues": ["walrus", "availability", "shard", "recover"], "recommendation": "Design for potential data unavailability. Implement fallback mechanisms. Consider critical data redundancy strategies.", "sui_move_applicable": true, "source": "Walrus Technical Architecture"}
{"id": "SUI25-SEAL-001", "title": "Seal Key Management - Policy Misconfiguration", "severity": "critical", "category": "encryption", "description": "Seal provides on-chain access control for encrypted data. Incorrect policy conditions may grant unintended access or permanently lock data.", "detection_cues": ["seal", "encrypt", "decrypt", "policy", "access"], "recommendation": "Thoroughly test access policies before deployment. Use time-locks carefully. Implement recovery mechanisms for critical data.", "sui_move_applicable": true, "source": "Seal Decentralized Key Management"}
{"id": "SUI25-NAUTILUS-001", "title": "Nautilus TEE Verification - Off-chain Computation Trust", "severity": "high", "category": "tee_security", "description": "Nautilus runs off-chain computation in TEE. Smart contracts must verify TEE attestations correctly. Invalid verification allows forged results.", "detection_cues": ["nautilus", "tee", "attestation", "verify", "off-chain"], "recommendation": "Verify TEE attestations on-chain. Validate computation results match expected format. Don't trust off-chain data without proof.", "sui_move_applicable": true, "source": "Nautilus TEE Documentation"}
{"id": "SUI25-DEEPBOOK-001", "title": "DeepBook V3 Flash Loan - Price Manipulation Risk", "severity": "high", "category": "defi_security", "description": "DeepBook V3 supports flash loans. Attackers can borrow large amounts to manipulate orderbook prices within single transaction.", "detection_cues": ["deepbook", "flash", "loan", "borrow", "CLOB"], "recommendation": "Implement price deviation checks. Use TWAP for price-sensitive operations. Consider flash loan attack vectors in AMM integrations.", "sui_move_applicable": true, "source": "DeepBook V3 Documentation"}
{"id": "SUI25-DEEPBOOK-002", "title": "DeepBook V3 Permissionless Pool - Malicious Token Listing", "severity": "medium", "category": "defi_security", "description": "DeepBook V3.1 allows permissionless pool creation. Malicious actors may create fake token pools to deceive users.", "detection_cues": ["deepbook", "pool", "create", "permissionless"], "recommendation": "Verify token contract addresses before trading. Check pool creator reputation. Use only verified token listings.", "sui_move_applicable": true, "source": "DeepBook V3.1 Updates"}
{"id": "SUI25-MVR-001", "title": "Move Registry (MVR) - Unverified Package Trust", "severity": "medium", "category": "dependency", "description": "MVR provides package discovery but trust is user responsibility. Installing unverified packages may introduce vulnerabilities.", "detection_cues": ["mvr", "registry", "package", "dependency", "use"], "recommendation": "Verify package authors and audit status. Check package source code. Use only packages with security audits for production.", "sui_move_applicable": true, "source": "Move Registry Documentation"}
{"id": "SUI25-AI-ASSIST-001", "title": "AI Coding Assistant Generated Code - Unvalidated Security", "severity": "high", "category": "ai_security", "description": "Sui/Alibaba AI coding assistant may generate vulnerable code. Auto-completion and templates may not follow security best practices.", "detection_cues": ["generated", "AI", "assistant", "template", "autocomplete"], "recommendation": "Always review AI-generated code manually. Run security scanning on generated code. Don't blindly trust AI suggestions for sensitive logic.", "sui_move_applicable": true, "source": "Sui AI Coding Assistant Launch"}
{"id": "SUI25-MYSTICETI-001", "title": "Mysticeti V2 Shared Object Timing Assumptions", "severity": "low", "category": "consensus", "description": "Mysticeti V2 reduces latency significantly (<1s). Code assuming longer confirmation times may have race condition issues.", "detection_cues": ["timing", "latency", "confirmation", "shared"], "recommendation": "Don't hardcode timing assumptions. Design for variable latency. Test with fast finality scenarios.", "sui_move_applicable": true, "source": "Mysticeti V2 Consensus Update"}
{"id": "SUI25-YLDS-001", "title": "YLDS Auto-Conversion - Unexpected Token Behavior", "severity": "medium", "category": "defi_security", "description": "DeepBook stablecoins may auto-convert to YLDS (yield-bearing token). Contracts expecting specific token types may break.", "detection_cues": ["YLDS", "stablecoin", "convert", "yield"], "recommendation": "Handle token type changes gracefully. Check actual received token type. Update contract logic for yield-bearing tokens.", "sui_move_applicable": true, "source": "DeepBook YLDS Integration"}
{"id": "SUI25-QUILT-001", "title": "Walrus Quilt Small File Bundling - Partial Retrieval Risk", "severity": "low", "category": "storage_security", "description": "Quilt bundles up to 660 small files into single blob. Failure to retrieve bundle affects all contained files.", "detection_cues": ["quilt", "bundle", "small", "file"], "recommendation": "Consider file criticality before bundling. Implement separate storage for critical small files. Handle partial bundle failures.", "sui_move_applicable": true, "source": "Walrus Quilt Feature"}
